<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extension: Json and NetCDF utilities: Legacy NetCDF-C utility</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Extension: Json and NetCDF utilities
   </div>
   <div id="projectbrief">#include &quot;dg/file/file.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__legacy.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Legacy NetCDF-C utility</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1file_1_1_n_c___error___handle.html">dg::file::NC_Error_Handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Empty utitlity class that handles return values of netcdf functions and throws NC_Error(status) if( status != NC_NOERR)  <a href="structdg_1_1file_1_1_n_c___error___handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga78d87c9a7c5160ec417eb30c9770fe07" id="r_ga78d87c9a7c5160ec417eb30c9770fe07"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga78d87c9a7c5160ec417eb30c9770fe07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga78d87c9a7c5160ec417eb30c9770fe07">dg::file::check_real_time</a> (int ncid, const char *name, int *dimID, int *tvarID)</td></tr>
<tr class="memdesc:ga78d87c9a7c5160ec417eb30c9770fe07"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Check if an unlimited dimension exists as if <code>define_real_time</code> was called.  <br /></td></tr>
<tr class="separator:ga78d87c9a7c5160ec417eb30c9770fe07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8124a7e611f88c559d73e7f8e6ed90" id="r_ga9a8124a7e611f88c559d73e7f8e6ed90"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9a8124a7e611f88c559d73e7f8e6ed90"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9a8124a7e611f88c559d73e7f8e6ed90">dg::file::define_real_time</a> (int ncid, const char *name, int *dimID, int *tvarID, bool full_check=false)</td></tr>
<tr class="memdesc:ga9a8124a7e611f88c559d73e7f8e6ed90"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Define an unlimited time dimension and coordinate variable.  <br /></td></tr>
<tr class="separator:ga9a8124a7e611f88c559d73e7f8e6ed90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ea40baa3d8079e782feda4a8213d12" id="r_ga34ea40baa3d8079e782feda4a8213d12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga34ea40baa3d8079e782feda4a8213d12">dg::file::define_time</a> (int ncid, const char *name, int *dimID, int *tvarID)</td></tr>
<tr class="memdesc:ga34ea40baa3d8079e782feda4a8213d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED An alias for <code> define_real_time&lt;double&gt; </code>  <br /></td></tr>
<tr class="separator:ga34ea40baa3d8079e782feda4a8213d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77dc6a6a355f5dc9bb7b90c00a282343" id="r_ga77dc6a6a355f5dc9bb7b90c00a282343"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga77dc6a6a355f5dc9bb7b90c00a282343">dg::file::define_limited_time</a> (int ncid, const char *name, int size, int *dimID, int *tvarID)</td></tr>
<tr class="memdesc:ga77dc6a6a355f5dc9bb7b90c00a282343"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Define a limited time dimension and coordinate variable.  <br /></td></tr>
<tr class="separator:ga77dc6a6a355f5dc9bb7b90c00a282343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga571a711e97639667de8a961457aa0e0a" id="r_ga571a711e97639667de8a961457aa0e0a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga571a711e97639667de8a961457aa0e0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga571a711e97639667de8a961457aa0e0a">dg::file::check_dimension</a> (int ncid, int *dimID, const dg::RealGrid1d&lt; T &gt; &amp;g, std::string name_dim=&quot;x&quot;, std::string=&quot;X&quot;)</td></tr>
<tr class="memdesc:ga571a711e97639667de8a961457aa0e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Check if a dimension exists as if <code>define_dimension</code> was called.  <br /></td></tr>
<tr class="separator:ga571a711e97639667de8a961457aa0e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9352cfdb1f5617ace7517aff9cd2a9" id="r_ga2c9352cfdb1f5617ace7517aff9cd2a9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2c9352cfdb1f5617ace7517aff9cd2a9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2c9352cfdb1f5617ace7517aff9cd2a9">dg::file::define_dimension</a> (int ncid, int *dimID, const dg::RealGrid1d&lt; T &gt; &amp;g, std::string name_dim=&quot;x&quot;, std::string axis=&quot;X&quot;, bool full_check=false)</td></tr>
<tr class="memdesc:ga2c9352cfdb1f5617ace7517aff9cd2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Define a 1d dimension and associated coordinate variable.  <br /></td></tr>
<tr class="separator:ga2c9352cfdb1f5617ace7517aff9cd2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599a843015b888cef34158206305ab5b" id="r_ga599a843015b888cef34158206305ab5b"><td class="memTemplParams" colspan="2">template&lt;class Topology , std::enable_if_t&lt; dg::is_vector_v&lt; typename Topology::host_vector, dg::SharedVectorTag &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:ga599a843015b888cef34158206305ab5b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga599a843015b888cef34158206305ab5b">dg::file::define_dimensions</a> (int ncid, int *dimsIDs, const Topology &amp;g, std::vector&lt; std::string &gt; name_dims={}, bool full_check=false)</td></tr>
<tr class="memdesc:ga599a843015b888cef34158206305ab5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Define dimensions and associated coordiante variables.  <br /></td></tr>
<tr class="separator:ga599a843015b888cef34158206305ab5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0a7b8c0cc3655732921631fab4a1c64" id="r_gad0a7b8c0cc3655732921631fab4a1c64"><td class="memTemplParams" colspan="2">template&lt;class Topology , std::enable_if_t&lt; dg::is_vector_v&lt; typename Topology::host_vector, dg::SharedVectorTag &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:gad0a7b8c0cc3655732921631fab4a1c64"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad0a7b8c0cc3655732921631fab4a1c64">dg::file::define_dimensions</a> (int ncid, int *dimsIDs, int *tvarID, const Topology &amp;g, std::vector&lt; std::string &gt; name_dims={}, bool full_check=false)</td></tr>
<tr class="memdesc:gad0a7b8c0cc3655732921631fab4a1c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Define an unlimited time and grid dimensions together with their coordinate variables.  <br /></td></tr>
<tr class="separator:gad0a7b8c0cc3655732921631fab4a1c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6688acaf522ecb5dd00f0dba885b3776" id="r_ga6688acaf522ecb5dd00f0dba885b3776"><td class="memTemplParams" colspan="2">template&lt;class Topology , std::enable_if_t&lt; dg::is_vector_v&lt; typename Topology::host_vector, dg::SharedVectorTag &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:ga6688acaf522ecb5dd00f0dba885b3776"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6688acaf522ecb5dd00f0dba885b3776">dg::file::check_dimensions</a> (int ncid, int *dimsIDs, const Topology &amp;g, std::vector&lt; std::string &gt; name_dims={})</td></tr>
<tr class="memdesc:ga6688acaf522ecb5dd00f0dba885b3776"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Check if dimensions exist as if <code>define_dimensions</code> was called.  <br /></td></tr>
<tr class="separator:ga6688acaf522ecb5dd00f0dba885b3776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacda023dea68367505cde287e135af3db" id="r_gacda023dea68367505cde287e135af3db"><td class="memTemplParams" colspan="2">template&lt;class Topology , std::enable_if_t&lt; dg::is_vector_v&lt; typename Topology::host_vector, dg::SharedVectorTag &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:gacda023dea68367505cde287e135af3db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacda023dea68367505cde287e135af3db">dg::file::check_dimensions</a> (int ncid, int *dimsIDs, int *tvarID, const Topology &amp;g, std::vector&lt; std::string &gt; name_dims={})</td></tr>
<tr class="memdesc:gacda023dea68367505cde287e135af3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Check if dimensions exist as if <code>define_dimensions</code> was called.  <br /></td></tr>
<tr class="separator:gacda023dea68367505cde287e135af3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5d07e3ad0dd4cc28bc266a2122398c" id="r_ga0f5d07e3ad0dd4cc28bc266a2122398c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga0f5d07e3ad0dd4cc28bc266a2122398c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0f5d07e3ad0dd4cc28bc266a2122398c">dg::file::define_limtime_xy</a> (int ncid, int *dimsIDs, int size, int *tvarID, const dg::aRealTopology2d&lt; T &gt; &amp;g, std::vector&lt; std::string &gt; name_dims={&quot;time&quot;, &quot;y&quot;, &quot;x&quot;})</td></tr>
<tr class="memdesc:ga0f5d07e3ad0dd4cc28bc266a2122398c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Define a limited time and 2 dimensions and associated coordinate variables.  <br /></td></tr>
<tr class="separator:ga0f5d07e3ad0dd4cc28bc266a2122398c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6d0fc548abe0a86e74270bf3969964" id="r_gacf6d0fc548abe0a86e74270bf3969964"><td class="memTemplParams" colspan="2">template&lt;class MPITopology , std::enable_if_t&lt; dg::is_vector_v&lt; typename MPITopology::host_vector, dg::MPIVectorTag &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:gacf6d0fc548abe0a86e74270bf3969964"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacf6d0fc548abe0a86e74270bf3969964">dg::file::define_dimensions</a> (int ncid, int *dimsIDs, const MPITopology &amp;g, std::vector&lt; std::string &gt; name_dims={}, bool full_check=false)</td></tr>
<tr class="memdesc:gacf6d0fc548abe0a86e74270bf3969964"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED All processes may call this but only master process has to and will execute!! Convenience function that just calls the corresponding serial version with the global grid.  <br /></td></tr>
<tr class="separator:gacf6d0fc548abe0a86e74270bf3969964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd73afba89cf1449ed1f87f9a40b988c" id="r_gabd73afba89cf1449ed1f87f9a40b988c"><td class="memTemplParams" colspan="2">template&lt;class MPITopology , std::enable_if_t&lt; dg::is_vector_v&lt; typename MPITopology::host_vector, dg::MPIVectorTag &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:gabd73afba89cf1449ed1f87f9a40b988c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabd73afba89cf1449ed1f87f9a40b988c">dg::file::define_dimensions</a> (int ncid, int *dimsIDs, int *tvarID, const MPITopology &amp;g, std::vector&lt; std::string &gt; name_dims={}, bool full_check=false)</td></tr>
<tr class="memdesc:gabd73afba89cf1449ed1f87f9a40b988c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED All processes may call this but only master process has to and will execute!! Convenience function that just calls the corresponding serial version with the global grid.  <br /></td></tr>
<tr class="separator:gabd73afba89cf1449ed1f87f9a40b988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e282fe3b0cd07f32ebe2239201025b" id="r_gaa1e282fe3b0cd07f32ebe2239201025b"><td class="memTemplParams" colspan="2">template&lt;class MPITopology , std::enable_if_t&lt; dg::is_vector_v&lt; typename MPITopology::host_vector, dg::MPIVectorTag &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:gaa1e282fe3b0cd07f32ebe2239201025b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa1e282fe3b0cd07f32ebe2239201025b">dg::file::check_dimensions</a> (int ncid, int *dimsIDs, const MPITopology &amp;g, std::vector&lt; std::string &gt; name_dims={})</td></tr>
<tr class="memdesc:gaa1e282fe3b0cd07f32ebe2239201025b"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED All processes may call this and all will execute!! Convenience function that just calls the corresponding serial version with the global grid.  <br /></td></tr>
<tr class="separator:gaa1e282fe3b0cd07f32ebe2239201025b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f65af367acd02ce0da62c7a84ca2520" id="r_ga3f65af367acd02ce0da62c7a84ca2520"><td class="memTemplParams" colspan="2">template&lt;class MPITopology , std::enable_if_t&lt; dg::is_vector_v&lt; typename MPITopology::host_vector, dg::MPIVectorTag &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:ga3f65af367acd02ce0da62c7a84ca2520"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3f65af367acd02ce0da62c7a84ca2520">dg::file::check_dimensions</a> (int ncid, int *dimsIDs, int *tvarID, const MPITopology &amp;g, std::vector&lt; std::string &gt; name_dims={})</td></tr>
<tr class="memdesc:ga3f65af367acd02ce0da62c7a84ca2520"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED All processes may call this and all will execute!! Convenience function that just calls the corresponding serial version with the global grid.  <br /></td></tr>
<tr class="separator:ga3f65af367acd02ce0da62c7a84ca2520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293f7dc2261814a9ead22057eb3e983d" id="r_ga293f7dc2261814a9ead22057eb3e983d"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class Topology &gt; </td></tr>
<tr class="memitem:ga293f7dc2261814a9ead22057eb3e983d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga293f7dc2261814a9ead22057eb3e983d">dg::file::get_var</a> (int ncid, int varid, const Topology &amp;, host_vector &amp;data, bool=true)</td></tr>
<tr class="memdesc:ga293f7dc2261814a9ead22057eb3e983d"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Convenience wrapper around <code>nc_get_var</code>.  <br /></td></tr>
<tr class="separator:ga293f7dc2261814a9ead22057eb3e983d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb208712f3ac5506c86eccfc5710fa4a" id="r_gabb208712f3ac5506c86eccfc5710fa4a"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class Topology &gt; </td></tr>
<tr class="memitem:gabb208712f3ac5506c86eccfc5710fa4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabb208712f3ac5506c86eccfc5710fa4a">dg::file::get_vara</a> (int ncid, int varid, unsigned slice, const Topology &amp;grid, host_vector &amp;data, bool=true)</td></tr>
<tr class="memdesc:gabb208712f3ac5506c86eccfc5710fa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Convenience wrapper around <code>nc_get_vara()</code>  <br /></td></tr>
<tr class="separator:gabb208712f3ac5506c86eccfc5710fa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b0a28d41680dd01fb53f2d71dd7d39" id="r_ga31b0a28d41680dd01fb53f2d71dd7d39"><td class="memTemplParams" colspan="2">template&lt;class T , class real_type &gt; </td></tr>
<tr class="memitem:ga31b0a28d41680dd01fb53f2d71dd7d39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga31b0a28d41680dd01fb53f2d71dd7d39">dg::file::get_var</a> (int ncid, int varid, const RealGrid0d&lt; real_type &gt; &amp;, T &amp;data, bool=true)</td></tr>
<tr class="memdesc:ga31b0a28d41680dd01fb53f2d71dd7d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Read a scalar from the netcdf file.  <br /></td></tr>
<tr class="separator:ga31b0a28d41680dd01fb53f2d71dd7d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca40a2828a6fea4f100a566815827e68" id="r_gaca40a2828a6fea4f100a566815827e68"><td class="memTemplParams" colspan="2">template&lt;class T , class real_type &gt; </td></tr>
<tr class="memitem:gaca40a2828a6fea4f100a566815827e68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaca40a2828a6fea4f100a566815827e68">dg::file::get_vara</a> (int ncid, int varid, unsigned slice, const RealGrid0d&lt; real_type &gt; &amp;, T &amp;data, bool=true)</td></tr>
<tr class="memdesc:gaca40a2828a6fea4f100a566815827e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Read a scalar to the netcdf file.  <br /></td></tr>
<tr class="separator:gaca40a2828a6fea4f100a566815827e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f343a346443fcc5bedb670b3ec8e7c3" id="r_ga1f343a346443fcc5bedb670b3ec8e7c3"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class Topology &gt; </td></tr>
<tr class="memitem:ga1f343a346443fcc5bedb670b3ec8e7c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1f343a346443fcc5bedb670b3ec8e7c3">dg::file::put_var</a> (int ncid, int varid, const Topology &amp;, const host_vector &amp;data, bool=false)</td></tr>
<tr class="memdesc:ga1f343a346443fcc5bedb670b3ec8e7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Write an array to NetCDF file.  <br /></td></tr>
<tr class="separator:ga1f343a346443fcc5bedb670b3ec8e7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6216fb6b41a9dddba170370aaa8be86" id="r_gae6216fb6b41a9dddba170370aaa8be86"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class Topology &gt; </td></tr>
<tr class="memitem:gae6216fb6b41a9dddba170370aaa8be86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae6216fb6b41a9dddba170370aaa8be86">dg::file::put_vara</a> (int ncid, int varid, unsigned slice, const Topology &amp;grid, const host_vector &amp;data, bool=false)</td></tr>
<tr class="memdesc:gae6216fb6b41a9dddba170370aaa8be86"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Write an array to NetCDF file.  <br /></td></tr>
<tr class="separator:gae6216fb6b41a9dddba170370aaa8be86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a98c3fa45ebcd2c27a892051d48d84" id="r_ga74a98c3fa45ebcd2c27a892051d48d84"><td class="memTemplParams" colspan="2">template&lt;class T , class real_type &gt; </td></tr>
<tr class="memitem:ga74a98c3fa45ebcd2c27a892051d48d84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga74a98c3fa45ebcd2c27a892051d48d84">dg::file::put_var</a> (int ncid, int varid, const RealGrid0d&lt; real_type &gt; &amp;, T data, bool=false)</td></tr>
<tr class="memdesc:ga74a98c3fa45ebcd2c27a892051d48d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Write a scalar to the NetCDF file.  <br /></td></tr>
<tr class="separator:ga74a98c3fa45ebcd2c27a892051d48d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga438dcf46e76244fcf9a41622aed45032" id="r_ga438dcf46e76244fcf9a41622aed45032"><td class="memTemplParams" colspan="2">template&lt;class T , class real_type &gt; </td></tr>
<tr class="memitem:ga438dcf46e76244fcf9a41622aed45032"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga438dcf46e76244fcf9a41622aed45032">dg::file::put_vara</a> (int ncid, int varid, unsigned slice, const RealGrid0d&lt; real_type &gt; &amp;, T data, bool=false)</td></tr>
<tr class="memdesc:ga438dcf46e76244fcf9a41622aed45032"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Write a scalar to the NetCDF file.  <br /></td></tr>
<tr class="separator:ga438dcf46e76244fcf9a41622aed45032"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga571a711e97639667de8a961457aa0e0a" name="ga571a711e97639667de8a961457aa0e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga571a711e97639667de8a961457aa0e0a">&#9670;&#160;</a></span>check_dimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool dg::file::check_dimension </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dg::RealGrid1d&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name_dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;x&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;X&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Check if a dimension exists as if <code>define_dimension</code> was called. </p>
<p>This function returns false if the dimension with the given name does not exist.</p>
<p>This function throws <code>std::runtime_error</code> if</p><ul>
<li>The length of the dimension does not match the grid size</li>
<li>The dimension variable has wrong type or dimensions</li>
<li>The dimension variable entries do not match the grid abscissas</li>
</ul>
<p>This function throws an <code><a class="el" href="structdg_1_1file_1_1_n_c___error.html" title="Class thrown by the NC_Error_Handle.">dg::file::NC_Error</a></code> if</p><ul>
<li>The dimension exists but the variable does not</li>
<li>The dimension variable has no entries</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function does not write anything to the file, only read </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">dimID</td><td>dimension ID (output) </td></tr>
    <tr><td class="paramname">g</td><td>The 1d DG grid from which data points for coordinate variable are generated using <code>g.abscissas()</code> </td></tr>
    <tr><td class="paramname">name_dim</td><td>Name of dimension and coordinate variable (input) [unnamed string] axis The axis attribute (input) is ignored but kept for now as a future placeholder </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>determines the datatype of the dimension variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if dimension with given name does not exist, if no errors are thrown True </dd></dl>

</div>
</div>
<a id="gaa1e282fe3b0cd07f32ebe2239201025b" name="gaa1e282fe3b0cd07f32ebe2239201025b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1e282fe3b0cd07f32ebe2239201025b">&#9670;&#160;</a></span>check_dimensions() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MPITopology , std::enable_if_t&lt; dg::is_vector_v&lt; typename MPITopology::host_vector, dg::MPIVectorTag &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dg::file::check_dimensions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimsIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPITopology &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>name_dims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED All processes may call this and all will execute!! Convenience function that just calls the corresponding serial version with the global grid. </p>

</div>
</div>
<a id="ga6688acaf522ecb5dd00f0dba885b3776" name="ga6688acaf522ecb5dd00f0dba885b3776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6688acaf522ecb5dd00f0dba885b3776">&#9670;&#160;</a></span>check_dimensions() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Topology , std::enable_if_t&lt; dg::is_vector_v&lt; typename Topology::host_vector, dg::SharedVectorTag &gt;, bool &gt;  = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool dg::file::check_dimensions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimsIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Topology &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>name_dims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Check if dimensions exist as if <code>define_dimensions</code> was called. </p>
<p>This function checks if the given file contains dimensions and their associated dimension variables in the same way that the corresponding <code>define_dimensions</code> creates them. If anything is amiss, an error will be thrown. </p><dl class="section note"><dt>Note</dt><dd>In order to do this the function will actually read in the coordinate variable and compare to the given grid abscissas </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">dimsIDs</td><td>(write - only) dimension IDs, Must be of size <code> g.ndim() </code> </td></tr>
    <tr><td class="paramname">g</td><td>The dG grid from which data points for coordinate variable are generated using <code>g.abscissas()</code> in each dimension </td></tr>
    <tr><td class="paramname">name_dims</td><td>Names for the dimension and coordinate variables (Must have size <code> g.ndim() </code>) <b>in numpy python ordering</b> e.g. in 3d we have <code> {"z", "y", "x"}</code>; If <code>name_dims.empty()</code> then default names in <code> {"z", "y", "x"} </code> will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Topology</td><td><code> typename Topology::value_type </code> determines the datatype of the dimension variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For a 0d grid, the default dimension name is "i", axis "I" and the dimension will be of size 1 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>False if any dimension with given name does not exist, if no errors are thrown True </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga571a711e97639667de8a961457aa0e0a" title="DEPRECATED Check if a dimension exists as if define_dimension was called.">check_dimension</a> </dd></dl>

</div>
</div>
<a id="ga3f65af367acd02ce0da62c7a84ca2520" name="ga3f65af367acd02ce0da62c7a84ca2520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f65af367acd02ce0da62c7a84ca2520">&#9670;&#160;</a></span>check_dimensions() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MPITopology , std::enable_if_t&lt; dg::is_vector_v&lt; typename MPITopology::host_vector, dg::MPIVectorTag &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dg::file::check_dimensions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimsIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>tvarID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPITopology &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>name_dims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED All processes may call this and all will execute!! Convenience function that just calls the corresponding serial version with the global grid. </p>

</div>
</div>
<a id="gacda023dea68367505cde287e135af3db" name="gacda023dea68367505cde287e135af3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacda023dea68367505cde287e135af3db">&#9670;&#160;</a></span>check_dimensions() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Topology , std::enable_if_t&lt; dg::is_vector_v&lt; typename Topology::host_vector, dg::SharedVectorTag &gt;, bool &gt;  = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool dg::file::check_dimensions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimsIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>tvarID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Topology &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>name_dims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Check if dimensions exist as if <code>define_dimensions</code> was called. </p>
<p>Semantically equivalent to the following: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ( !<a class="code hl_function" href="#ga78d87c9a7c5160ec417eb30c9770fe07">check_real_time&lt;typename Topology::value_type&gt;</a>( ncid, name_dims[0].data(), &amp;dimsIDs[0], tvarID))</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_function" href="#ga6688acaf522ecb5dd00f0dba885b3776">check_dimensions</a>( ncid, &amp;dimsIDs[1], g, {name_dims.begin()+1, name_dims.end()});</div>
<div class="ttc" id="agroup__legacy_html_ga6688acaf522ecb5dd00f0dba885b3776"><div class="ttname"><a href="#ga6688acaf522ecb5dd00f0dba885b3776">dg::file::check_dimensions</a></div><div class="ttdeci">bool check_dimensions(int ncid, int *dimsIDs, const Topology &amp;g, std::vector&lt; std::string &gt; name_dims={})</div><div class="ttdoc">DEPRECATED Check if dimensions exist as if define_dimensions was called.</div><div class="ttdef"><b>Definition</b> easy_dims.h:392</div></div>
<div class="ttc" id="agroup__legacy_html_ga78d87c9a7c5160ec417eb30c9770fe07"><div class="ttname"><a href="#ga78d87c9a7c5160ec417eb30c9770fe07">dg::file::check_real_time</a></div><div class="ttdeci">bool check_real_time(int ncid, const char *name, int *dimID, int *tvarID)</div><div class="ttdoc">DEPRECATED Check if an unlimited dimension exists as if define_real_time was called.</div><div class="ttdef"><b>Definition</b> easy_dims.h:107</div></div>
</div><!-- fragment --><p> This function checks if the given file contains dimensions and their associated dimension variables in the same way that the corresponding <code>define_dimensions</code> creates them. If anything is amiss, an error will be thrown. </p><dl class="section note"><dt>Note</dt><dd>In order to do this the function will actually read in the coordinate variable and compare to the given grid abscissas </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">dimsIDs</td><td>(write - only) dimension IDs, Must be of size <code> g.ndim()+1 </code> </td></tr>
    <tr><td class="paramname">tvarID</td><td>(write - only) time coordinate variable ID (unlimited) </td></tr>
    <tr><td class="paramname">g</td><td>The dG grid from which data points for coordinate variable are generated using <code>g.abscissas()</code> </td></tr>
    <tr><td class="paramname">name_dims</td><td>Names for the dimension and coordinate variables (Must have size <code> g.ndim()+1 </code>) <b>in numpy python ordering</b> e.g. in 3d we have <code> {"time", "z", "y", "x"}</code>; If <code>name_dims.empty()</code> then default names in <code> {"time", "z", "y", "x"} </code> will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Topology</td><td><code> typename Topology::value_type </code> determines the datatype of the dimension variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if any dimension with given name does not exist, if no errors are thrown True </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga571a711e97639667de8a961457aa0e0a" title="DEPRECATED Check if a dimension exists as if define_dimension was called.">check_dimension</a> <a class="el" href="#ga78d87c9a7c5160ec417eb30c9770fe07" title="DEPRECATED Check if an unlimited dimension exists as if define_real_time was called.">check_real_time</a> </dd></dl>

</div>
</div>
<a id="ga78d87c9a7c5160ec417eb30c9770fe07" name="ga78d87c9a7c5160ec417eb30c9770fe07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78d87c9a7c5160ec417eb30c9770fe07">&#9670;&#160;</a></span>check_real_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool dg::file::check_real_time </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>tvarID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Check if an unlimited dimension exists as if <code>define_real_time</code> was called. </p>
<p>This function returns false if the dimension with the given name does not exist.</p>
<p>This function throws <code>std::runtime_error</code> if</p><ul>
<li>The dimension exists but is not unlimited</li>
<li>The dimension variable has wrong type or dimensions</li>
</ul>
<p>This function throws an <code><a class="el" href="structdg_1_1file_1_1_n_c___error.html" title="Class thrown by the NC_Error_Handle.">dg::file::NC_Error</a></code> if</p><ul>
<li>The dimension exists but the variable does not</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function does not write anything to the file, only read </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">name</td><td>Name of unlimited dimension and associated variable </td></tr>
    <tr><td class="paramname">dimID</td><td>(write-only) time-dimension ID </td></tr>
    <tr><td class="paramname">tvarID</td><td>(write-only) time-variable ID (for a time variable of type <code>T</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>determine type of dimension variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if dimension with given name does not exist, if no errors are thrown True </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Dimensions in the parent group are visible in groups, but variables are not, so groups should have separate time dimension <a href="https://docs.unidata.ucar.edu/netcdf-c/current/group__groups.html">https://docs.unidata.ucar.edu/netcdf-c/current/group__groups.html</a> </dd></dl>

</div>
</div>
<a id="ga2c9352cfdb1f5617ace7517aff9cd2a9" name="ga2c9352cfdb1f5617ace7517aff9cd2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c9352cfdb1f5617ace7517aff9cd2a9">&#9670;&#160;</a></span>define_dimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dg::file::define_dimension </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dg::RealGrid1d&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name_dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;x&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;X&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>full_check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED Define a 1d dimension and associated coordinate variable. </p>
<dl class="section note"><dt>Note</dt><dd>By <a href="https://docs.unidata.ucar.edu/nug/current/best_practices.html">NetCDF conventions</a> a variable with the same name as a dimension is called a coordinate variable. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">dimID</td><td>dimension ID (output) </td></tr>
    <tr><td class="paramname">g</td><td>The 1d DG grid from which data points for coordinate variable are generated using <code>g.abscissas()</code> </td></tr>
    <tr><td class="paramname">name_dim</td><td>Name of dimension and coordinate variable (input) </td></tr>
    <tr><td class="paramname">axis</td><td>The axis attribute (input), ("X", "Y" or "Z") </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>determines the datatype of the dimension variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full_check</td><td>If true, will call <code>check_dimension</code> before definition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NetCDF error code if any </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__legacy_ga2c9352cfdb1f5617ace7517aff9cd2a9_cgraph.svg" width="438" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="gacf6d0fc548abe0a86e74270bf3969964" name="gacf6d0fc548abe0a86e74270bf3969964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf6d0fc548abe0a86e74270bf3969964">&#9670;&#160;</a></span>define_dimensions() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MPITopology , std::enable_if_t&lt; dg::is_vector_v&lt; typename MPITopology::host_vector, dg::MPIVectorTag &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dg::file::define_dimensions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimsIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPITopology &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>name_dims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>full_check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED All processes may call this but only master process has to and will execute!! Convenience function that just calls the corresponding serial version with the global grid. </p>

</div>
</div>
<a id="ga599a843015b888cef34158206305ab5b" name="ga599a843015b888cef34158206305ab5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga599a843015b888cef34158206305ab5b">&#9670;&#160;</a></span>define_dimensions() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Topology , std::enable_if_t&lt; dg::is_vector_v&lt; typename Topology::host_vector, dg::SharedVectorTag &gt;, bool &gt;  = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int dg::file::define_dimensions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimsIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Topology &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>name_dims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>full_check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Define dimensions and associated coordiante variables. </p>
<dl class="section note"><dt>Note</dt><dd>By <a href="https://docs.unidata.ucar.edu/nug/current/best_practices.html">NetCDF conventions</a> a variable with the same name as a dimension is called a coordinate variable.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">dimsIDs</td><td>(write - only) dimension IDs, Must be of size <code> g.ndim() </code> </td></tr>
    <tr><td class="paramname">g</td><td>The dG grid from which data points for coordinate variable are generated using <code>g.abscissas()</code> in each dimension </td></tr>
    <tr><td class="paramname">name_dims</td><td>Names for the dimension and coordinate variables (Must have size <code> g.ndim() </code>) <b>in numpy python ordering</b> e.g. in 3d we have <code> {"z", "y", "x"}</code>; If <code>name_dims.empty()</code> then default names in <code> {"z", "y", "x"} </code> will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Topology</td><td><code> typename Topology::value_type </code> determines the datatype of the dimension variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For a 0d grid, the function does nothing </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full_check</td><td>If true, will call <code>check_dimensions</code> before definition. In this case dimensions can already exist in the file and will not trigger a throw (it is also possible for some dimensions to exist while other do not)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if anything goes wrong, return the NetCDF error code, else NC_NOERR </dd></dl>

</div>
</div>
<a id="gabd73afba89cf1449ed1f87f9a40b988c" name="gabd73afba89cf1449ed1f87f9a40b988c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd73afba89cf1449ed1f87f9a40b988c">&#9670;&#160;</a></span>define_dimensions() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MPITopology , std::enable_if_t&lt; dg::is_vector_v&lt; typename MPITopology::host_vector, dg::MPIVectorTag &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dg::file::define_dimensions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimsIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>tvarID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPITopology &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>name_dims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>full_check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED All processes may call this but only master process has to and will execute!! Convenience function that just calls the corresponding serial version with the global grid. </p>

</div>
</div>
<a id="gad0a7b8c0cc3655732921631fab4a1c64" name="gad0a7b8c0cc3655732921631fab4a1c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0a7b8c0cc3655732921631fab4a1c64">&#9670;&#160;</a></span>define_dimensions() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Topology , std::enable_if_t&lt; dg::is_vector_v&lt; typename Topology::host_vector, dg::SharedVectorTag &gt;, bool &gt;  = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int dg::file::define_dimensions </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimsIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>tvarID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Topology &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>name_dims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>full_check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Define an unlimited time and grid dimensions together with their coordinate variables. </p>
<dl class="section note"><dt>Note</dt><dd>By <a href="https://docs.unidata.ucar.edu/nug/current/best_practices.html">NetCDF conventions</a> a variable with the same name as a dimension is called a coordinate variable.</dd></dl>
<p>Semantically equivalent to the following: </p><div class="fragment"><div class="line">retval = <a class="code hl_function" href="#ga9a8124a7e611f88c559d73e7f8e6ed90">define_real_time&lt;typename Topology::value_type&gt;</a>( ncid, name_dims[0].data(), &amp;dimsIDs[0], tvarID);</div>
<div class="line"><span class="keywordflow">if</span>(retval)</div>
<div class="line">    <span class="keywordflow">return</span> retval;</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_function" href="#ga599a843015b888cef34158206305ab5b">define_dimensions</a>( ncid, &amp;dimsIDs[1], g, {name_dims.begin()+1, name_dims.end()});</div>
<div class="ttc" id="agroup__legacy_html_ga599a843015b888cef34158206305ab5b"><div class="ttname"><a href="#ga599a843015b888cef34158206305ab5b">dg::file::define_dimensions</a></div><div class="ttdeci">int define_dimensions(int ncid, int *dimsIDs, const Topology &amp;g, std::vector&lt; std::string &gt; name_dims={}, bool full_check=false)</div><div class="ttdoc">DEPRECATED Define dimensions and associated coordiante variables.</div><div class="ttdef"><b>Definition</b> easy_dims.h:317</div></div>
<div class="ttc" id="agroup__legacy_html_ga9a8124a7e611f88c559d73e7f8e6ed90"><div class="ttname"><a href="#ga9a8124a7e611f88c559d73e7f8e6ed90">dg::file::define_real_time</a></div><div class="ttdeci">int define_real_time(int ncid, const char *name, int *dimID, int *tvarID, bool full_check=false)</div><div class="ttdoc">DEPRECATED Define an unlimited time dimension and coordinate variable.</div><div class="ttdef"><b>Definition</b> easy_dims.h:157</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">dimsIDs</td><td>(write - only) dimension IDs, Must be of size <code> g.ndim()+1 </code> </td></tr>
    <tr><td class="paramname">tvarID</td><td>(write - only) time coordinate variable ID (unlimited) </td></tr>
    <tr><td class="paramname">g</td><td>The dG grid from which data points for coordinate variable are generated using <code>g.abscissas()</code> </td></tr>
    <tr><td class="paramname">name_dims</td><td>Names for the dimension and coordinate variables (Must have size <code> g.ndim()+1 </code>) <b>in numpy python ordering</b> e.g. in 3d we have <code> {"time", "z", "y", "x"}</code>; If <code>name_dims.empty()</code> then default names in <code> {"time", "z", "y", "x"} </code> will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Topology</td><td><code> typename Topology::value_type </code> determines the datatype of the dimension variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For 0d grids only the "time" dimension is defined, no spatial dimension </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full_check</td><td>If true, will call <code>check_dimensions</code> before definition. In this case dimensions can already exist in the file and will not trigger a throw (it is also possible for some dimensions to exist while other do not)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if anything goes wrong, return the NetCDF error code, else NC_NOERR </dd></dl>

</div>
</div>
<a id="ga77dc6a6a355f5dc9bb7b90c00a282343" name="ga77dc6a6a355f5dc9bb7b90c00a282343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77dc6a6a355f5dc9bb7b90c00a282343">&#9670;&#160;</a></span>define_limited_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dg::file::define_limited_time </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>tvarID</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED Define a limited time dimension and coordinate variable. </p>
<dl class="section note"><dt>Note</dt><dd>By <a href="https://docs.unidata.ucar.edu/nug/current/best_practices.html">NetCDF conventions</a> a variable with the same name as a dimension is called a coordinate variable. The CF conventions dictate that the units attribute must be defined for a time variable: we give it the value "time
since start". Furthermore, we define the "axis" : "T" attribute to mark the time dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">name</td><td>Name of the time variable (usually "time") </td></tr>
    <tr><td class="paramname">size</td><td>The number of timesteps </td></tr>
    <tr><td class="paramname">dimID</td><td>time-dimension ID </td></tr>
    <tr><td class="paramname">tvarID</td><td>time-variable ID (for a time variable of type <code>NC_DOUBLE</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NetCDF error code if any </dd></dl>

</div>
</div>
<a id="ga0f5d07e3ad0dd4cc28bc266a2122398c" name="ga0f5d07e3ad0dd4cc28bc266a2122398c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f5d07e3ad0dd4cc28bc266a2122398c">&#9670;&#160;</a></span>define_limtime_xy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dg::file::define_limtime_xy </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimsIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>tvarID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dg::aRealTopology2d&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>name_dims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&quot;time&quot;,&#160;&quot;y&quot;,&#160;&quot;x&quot;}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED Define a limited time and 2 dimensions and associated coordinate variables. </p>
<dl class="section note"><dt>Note</dt><dd>By <a href="https://docs.unidata.ucar.edu/nug/current/best_practices.html">NetCDF conventions</a> a variable with the same name as a dimension is called a coordinate variable.</dd></dl>
<p>Semantically equivalent to the following: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#ga77dc6a6a355f5dc9bb7b90c00a282343">define_limited_time</a>( ncid, name_dims[0], size, &amp;dimsIDs[0], tvarID);</div>
<div class="line"><a class="code hl_function" href="#ga599a843015b888cef34158206305ab5b">define_dimensions</a>( ncid, &amp;dimsIDs[1], g, {name_dims[1], name_dims[2]});</div>
<div class="ttc" id="agroup__legacy_html_ga77dc6a6a355f5dc9bb7b90c00a282343"><div class="ttname"><a href="#ga77dc6a6a355f5dc9bb7b90c00a282343">dg::file::define_limited_time</a></div><div class="ttdeci">int define_limited_time(int ncid, const char *name, int size, int *dimID, int *tvarID)</div><div class="ttdoc">DEPRECATED Define a limited time dimension and coordinate variable.</div><div class="ttdef"><b>Definition</b> easy_dims.h:197</div></div>
</div><!-- fragment --><p> Dimensions have attributes of (time, Y, X) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">dimsIDs</td><td>(write - only) 3D array of dimension IDs (time, Y,X) </td></tr>
    <tr><td class="paramname">size</td><td>The size of the time variable </td></tr>
    <tr><td class="paramname">tvarID</td><td>(write - only) The ID of the time variable (limited) </td></tr>
    <tr><td class="paramname">g</td><td>The 2d DG grid from which data points for coordinate variable are generated using <code>g.abscissas()</code> </td></tr>
    <tr><td class="paramname">name_dims</td><td>Names for the dimension variables (time, Y, X) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>determines the datatype of the dimension variables</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if anything goes wrong it returns the NetCDF code, else SUCCESS </dd></dl>
<dl class="section note"><dt>Note</dt><dd>File stays in define mode </dd></dl>

</div>
</div>
<a id="ga9a8124a7e611f88c559d73e7f8e6ed90" name="ga9a8124a7e611f88c559d73e7f8e6ed90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a8124a7e611f88c559d73e7f8e6ed90">&#9670;&#160;</a></span>define_real_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dg::file::define_real_time </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>tvarID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>full_check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED Define an unlimited time dimension and coordinate variable. </p>
<dl class="section note"><dt>Note</dt><dd>By <a href="https://docs.unidata.ucar.edu/nug/current/best_practices.html">NetCDF conventions</a> a variable with the same name as a dimension is called a coordinate variable. The CF conventions dictate that the "units" attribute must be defined for a time variable: we give it the value "time
since start". Furthermore, we define the "axis" : "T" attribute to mark the time dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">name</td><td>Name of unlimited dimension and associated variable </td></tr>
    <tr><td class="paramname">dimID</td><td>(write-only) time-dimension ID </td></tr>
    <tr><td class="paramname">tvarID</td><td>(write-only) time-variable ID (for a time variable of type <code>T</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>determine type of dimension variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full_check</td><td>If true, will call <code>check_real_time</code> before definition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NetCDF error code if any </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__legacy_ga9a8124a7e611f88c559d73e7f8e6ed90_cgraph.svg" width="427" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ga34ea40baa3d8079e782feda4a8213d12" name="ga34ea40baa3d8079e782feda4a8213d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34ea40baa3d8079e782feda4a8213d12">&#9670;&#160;</a></span>define_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dg::file::define_time </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>dimID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>tvarID</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED An alias for <code> define_real_time&lt;double&gt; </code> </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__legacy_ga34ea40baa3d8079e782feda4a8213d12_cgraph.svg" width="628" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ga31b0a28d41680dd01fb53f2d71dd7d39" name="ga31b0a28d41680dd01fb53f2d71dd7d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31b0a28d41680dd01fb53f2d71dd7d39">&#9670;&#160;</a></span>get_var() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::file::get_var </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>varid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealGrid0d&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Read a scalar from the netcdf file. </p>
<dl class="section note"><dt>Note</dt><dd>This function throws a <code><a class="el" href="structdg_1_1file_1_1_n_c___error.html" title="Class thrown by the NC_Error_Handle.">dg::file::NC_Error</a></code> if an error occurs </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Determines data type to read </td></tr>
    <tr><td class="paramname">real_type</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">varid</td><td>Variable ID</td></tr>
  </table>
  </dd>
</dl>
<p>[unnamed RealGrid0d] a Tag to signify scalar ouput (and help the compiler choose this function over the array input function). Can be of type <code> dg::RealMPIGrid0d&lt;real_type&gt; </code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The (single) datum read from file.</td></tr>
  </table>
  </dd>
</dl>
<p>[unnamed bool] This parameter is ignored in both serial and MPI versions. In an MPI program all processes call this function and all processes read.  </p>
<dl class="section note"><dt>Note</dt><dd>In contrast to writing, reading a NetCDF-4 file can always be done in parallel See <a href="https://docs.h5py.org/en/stable/mpi.html">https://docs.h5py.org/en/stable/mpi.html</a> So all processes in MPI <b>can</b> open a file, get variable ids and subsequently read it, etc. even if only serial NetCDF is used. The default for <code>parallel</code> is always <code>true</code> in which case all processes <b>must</b> have previously opened the file and inquire e.g. the varid    </dd></dl>

</div>
</div>
<a id="ga293f7dc2261814a9ead22057eb3e983d" name="ga293f7dc2261814a9ead22057eb3e983d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga293f7dc2261814a9ead22057eb3e983d">&#9670;&#160;</a></span>get_var() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class Topology &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::file::get_var </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>varid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Topology &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Convenience wrapper around <code>nc_get_var</code>. </p>
<p>The purpose of this function is mainly to simplify input in an MPI environment and to provide the same interface also in a shared memory system for uniform programming. This version is for a time-independent variable, i.e. reads a single variable in one go and is actually equivalent to <code>nc_get_var</code>. The dimensionality is given by the grid. </p><dl class="section note"><dt>Note</dt><dd>This function throws a <code><a class="el" href="structdg_1_1file_1_1_n_c___error.html" title="Class thrown by the NC_Error_Handle.">dg::file::NC_Error</a></code> if an error occurs </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Topology</td><td>One of the dG defined grids (e.g. <code>dg::RealGrid2d</code>) Determines if shared memory or MPI version is called  </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">host_vector</td><td>For shared Topology: Type with <code>data()</code> member that returns pointer to first element in CPU (host) adress space, meaning it cannot be a GPU vector. For MPI Topology: must be <code>MPI_Vector</code> <code>host_vector::value_type</code> must match data type of variable in file.    </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">varid</td><td>Variable ID [unnamed Topology] The grid from which to construct <code>start</code> and <code>count</code> variables to forward to <code>nc_get_vara</code> </td></tr>
    <tr><td class="paramname">data</td><td>contains the read data on return (must be of size <code>grid.size()</code> ) [unnamed bool] This parameter is there to make serial and parallel interface equal.  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The "master" thread is assumed to be the process with <code>rank==0</code> in <code>MPI_COMM_WORLD</code>. The <code>MPI_COMM_WORLD</code> rank of a process is usually the same in a Cartesian communicator of the same size but is not guaranteed. So always check <code>MPI_COMM_WORLD</code> ranks for file write operations.     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>In contrast to writing, reading a NetCDF-4 file can always be done in parallel See <a href="https://docs.h5py.org/en/stable/mpi.html">https://docs.h5py.org/en/stable/mpi.html</a> So all processes in MPI <b>can</b> open a file, get variable ids and subsequently read it, etc. even if only serial NetCDF is used. The default for <code>parallel</code> is always <code>true</code> in which case all processes <b>must</b> have previously opened the file and inquire e.g. the varid    </dd></dl>

</div>
</div>
<a id="gaca40a2828a6fea4f100a566815827e68" name="gaca40a2828a6fea4f100a566815827e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca40a2828a6fea4f100a566815827e68">&#9670;&#160;</a></span>get_vara() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::file::get_vara </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>varid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealGrid0d&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Read a scalar to the netcdf file. </p>
<dl class="section note"><dt>Note</dt><dd>This function throws a <code><a class="el" href="structdg_1_1file_1_1_n_c___error.html" title="Class thrown by the NC_Error_Handle.">dg::file::NC_Error</a></code> if an error occurs </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Determines data type to read </td></tr>
    <tr><td class="paramname">real_type</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">varid</td><td>Variable ID </td></tr>
    <tr><td class="paramname">slice</td><td>The number of the time-slice to read (first element of the <code>startp</code> array in <code>nc_get_vara</code>)</td></tr>
  </table>
  </dd>
</dl>
<p>[unnamed RealGrid0d] a Tag to signify scalar ouput (and help the compiler choose this function over the array output function). Can be of type <code> dg::RealMPIGrid&lt;real_type&gt; </code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The (single) datum to read.</td></tr>
  </table>
  </dd>
</dl>
<p>[unnamed bool] This parameter is ignored in both serial and MPI versions. In an MPI program all processes call this function and all processes read.  </p>
<dl class="section note"><dt>Note</dt><dd>The "master" thread is assumed to be the process with <code>rank==0</code> in <code>MPI_COMM_WORLD</code>. The <code>MPI_COMM_WORLD</code> rank of a process is usually the same in a Cartesian communicator of the same size but is not guaranteed. So always check <code>MPI_COMM_WORLD</code> ranks for file write operations.     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>In contrast to writing, reading a NetCDF-4 file can always be done in parallel See <a href="https://docs.h5py.org/en/stable/mpi.html">https://docs.h5py.org/en/stable/mpi.html</a> So all processes in MPI <b>can</b> open a file, get variable ids and subsequently read it, etc. even if only serial NetCDF is used. The default for <code>parallel</code> is always <code>true</code> in which case all processes <b>must</b> have previously opened the file and inquire e.g. the varid    </dd></dl>

</div>
</div>
<a id="gabb208712f3ac5506c86eccfc5710fa4a" name="gabb208712f3ac5506c86eccfc5710fa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb208712f3ac5506c86eccfc5710fa4a">&#9670;&#160;</a></span>get_vara() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class Topology &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::file::get_vara </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>varid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Topology &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Convenience wrapper around <code>nc_get_vara()</code> </p>
<p>The purpose of this function is mainly to simplify input in an MPI environment and to provide the same interface also in a shared memory system for uniform programming. This version is for a time-dependent variable, i.e. reads a single time-slice from the file. The dimensionality is given by the grid. </p><dl class="section note"><dt>Note</dt><dd>This function throws a <code><a class="el" href="structdg_1_1file_1_1_n_c___error.html" title="Class thrown by the NC_Error_Handle.">dg::file::NC_Error</a></code> if an error occurs </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Topology</td><td>One of the dG defined grids (e.g. <code>dg::RealGrid2d</code>) Determines if shared memory or MPI version is called  </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">host_vector</td><td>For shared Topology: Type with <code>data()</code> member that returns pointer to first element in CPU (host) adress space, meaning it cannot be a GPU vector. For MPI Topology: must be <code>MPI_Vector</code> <code>host_vector::value_type</code> must match data type of variable in file.    </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">varid</td><td>Variable ID </td></tr>
    <tr><td class="paramname">slice</td><td>The number of the time-slice to read (first element of the <code>startp</code> array in <code>nc_get_vara</code>) </td></tr>
    <tr><td class="paramname">grid</td><td>The grid from which to construct <code>start</code> and <code>count</code> variables to forward to <code>nc_get_vara</code> </td></tr>
    <tr><td class="paramname">data</td><td>contains the read data on return (must be of size <code>grid.size()</code> )</td></tr>
  </table>
  </dd>
</dl>
<p>[unnamed bool] This parameter is there to make serial and parallel interface equal.  </p>
<dl class="section note"><dt>Note</dt><dd>The "master" thread is assumed to be the process with <code>rank==0</code> in <code>MPI_COMM_WORLD</code>. The <code>MPI_COMM_WORLD</code> rank of a process is usually the same in a Cartesian communicator of the same size but is not guaranteed. So always check <code>MPI_COMM_WORLD</code> ranks for file write operations.     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>In contrast to writing, reading a NetCDF-4 file can always be done in parallel See <a href="https://docs.h5py.org/en/stable/mpi.html">https://docs.h5py.org/en/stable/mpi.html</a> So all processes in MPI <b>can</b> open a file, get variable ids and subsequently read it, etc. even if only serial NetCDF is used. The default for <code>parallel</code> is always <code>true</code> in which case all processes <b>must</b> have previously opened the file and inquire e.g. the varid    </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__legacy_gabb208712f3ac5506c86eccfc5710fa4a_cgraph.svg" width="350" height="115"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ga74a98c3fa45ebcd2c27a892051d48d84" name="ga74a98c3fa45ebcd2c27a892051d48d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74a98c3fa45ebcd2c27a892051d48d84">&#9670;&#160;</a></span>put_var() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::file::put_var </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>varid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealGrid0d&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Write a scalar to the NetCDF file. </p>
<dl class="section note"><dt>Note</dt><dd>This function throws a <code><a class="el" href="structdg_1_1file_1_1_n_c___error.html" title="Class thrown by the NC_Error_Handle.">dg::file::NC_Error</a></code> if an error occurs </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Determines data type to write </td></tr>
    <tr><td class="paramname">real_type</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">varid</td><td>Variable ID (Note that in NetCDF variables without dimensions are scalars)</td></tr>
  </table>
  </dd>
</dl>
<p>[unnamed RealGrid0d] a Tag to signify scalar ouput (and help the compiler choose this function over the array output function). Can be of type <code> dg::RealMPIGrid&lt;real_type&gt; </code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The (single) datum to write.</td></tr>
  </table>
  </dd>
</dl>
<p>[unnamed bool] This parameter is ignored in both serial and MPI versions. In an MPI program all processes can call this function but only the master thread writes.  </p>
<dl class="section note"><dt>Note</dt><dd>The "master" thread is assumed to be the process with <code>rank==0</code> in <code>MPI_COMM_WORLD</code>. The <code>MPI_COMM_WORLD</code> rank of a process is usually the same in a Cartesian communicator of the same size but is not guaranteed. So always check <code>MPI_COMM_WORLD</code> ranks for file write operations.    </dd></dl>

</div>
</div>
<a id="ga1f343a346443fcc5bedb670b3ec8e7c3" name="ga1f343a346443fcc5bedb670b3ec8e7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f343a346443fcc5bedb670b3ec8e7c3">&#9670;&#160;</a></span>put_var() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class Topology &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::file::put_var </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>varid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Topology &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Write an array to NetCDF file. </p>
<p>Convenience wrapper around <code>nc_put_var</code> </p>
<p>The purpose of this function is mainly to simplify output in an MPI environment and to provide the same interface also in a shared memory system for uniform programming. This version is for a time-independent variable, i.e. writes a single variable in one go and is actually equivalent to <code>nc_put_var</code>. The dimensionality is given by the grid. </p><dl class="section note"><dt>Note</dt><dd>This function throws a <code><a class="el" href="structdg_1_1file_1_1_n_c___error.html" title="Class thrown by the NC_Error_Handle.">dg::file::NC_Error</a></code> if an error occurs </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Topology</td><td>One of the dG defined grids (e.g. <code>dg::RealGrid2d</code>) Determines if shared memory or MPI version is called  </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">host_vector</td><td>For shared Topology: Type with <code>data()</code> member that returns pointer to first element in CPU (host) adress space, meaning it cannot be a GPU vector. For MPI Topology: must be <code>MPI_Vector</code> <code>host_vector::value_type</code> must match data type of variable in file.    </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">varid</td><td>Variable ID</td></tr>
  </table>
  </dd>
</dl>
<p>[unnamed grid] Make serial and mpi interface equal </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data to be written to the NetCDF file</td></tr>
  </table>
  </dd>
</dl>
<p>[unnamed bool] This parameter is there to make serial and parallel interface equal.  </p>
<dl class="section note"><dt>Note</dt><dd>The "master" thread is assumed to be the process with <code>rank==0</code> in <code>MPI_COMM_WORLD</code>. The <code>MPI_COMM_WORLD</code> rank of a process is usually the same in a Cartesian communicator of the same size but is not guaranteed. So always check <code>MPI_COMM_WORLD</code> ranks for file write operations.     </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>With the serial NetCDF library only a single "master" process can <b>write</b> in a NetCDF file (creation, defining dimension ids, variables ids, writing etc). Thus, in an MPI program<ul>
<li><code>parallel</code> should be <code>false</code> </li>
<li>the program links to <b>serial NetCDF and hdf5</b></li>
<li>only the master thread needs to know the <code>ncid</code>, variable or dimension names, the slice to write etc.</li>
</ul>
There is a parallel NetCDF library where all processes can have write access in parallel. In this case<ul>
<li><code>parallel</code> should be <code>true</code> </li>
<li>the program links to <b>parallel NetCDF and hdf5</b></li>
<li>the file must be opened with the <code>NC_MPIIO</code> flag from the <code>NetCDF_par.h</code> header and the variable be marked with <code>NC_COLLECTIVE</code> access</li>
<li>all threads need to know the <code>ncid</code>, variable and dimension names, the slice to write etc.</li>
</ul>
Note that serious performance penalties have been observed on some platforms for parallel writing NetCDF.    </dd></dl>

</div>
</div>
<a id="ga438dcf46e76244fcf9a41622aed45032" name="ga438dcf46e76244fcf9a41622aed45032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga438dcf46e76244fcf9a41622aed45032">&#9670;&#160;</a></span>put_vara() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::file::put_vara </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>varid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealGrid0d&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Write a scalar to the NetCDF file. </p>
<dl class="section note"><dt>Note</dt><dd>This function throws a <code><a class="el" href="structdg_1_1file_1_1_n_c___error.html" title="Class thrown by the NC_Error_Handle.">dg::file::NC_Error</a></code> if an error occurs </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Determines data type to write </td></tr>
    <tr><td class="paramname">real_type</td><td>ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">varid</td><td>Variable ID (Note that in NetCDF variables without dimensions are scalars) </td></tr>
    <tr><td class="paramname">slice</td><td>The number of the time-slice to write (first element of the <code>startp</code> array in <code>nc_put_vara</code>)  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In NetCDF all variables that share an unlimited dimension are considered to have the same size in that dimension. In fact, the size of the unlimited dimension is the maximum of the sizes of all the variables sharing that unlimited dimension. All variables are artificially filled up with filler Values to match that maximum size. It is entirely possible to skip writing data for variables for some times. It is also possible to write data to unlimited variables at <code>slice&gt;=size</code> (in which case all variables sharing the unlimited dimension will increase in size) but it is not possible to read data at <code>slice&gt;=size</code>. It is the user's responsibility to manage the slice value across variables.   </dd></dl>
<p>[unnamed RealGrid0d] a Tag to signify scalar ouput (and help the compiler choose this function over the array output function). Can be of type <code> dg::RealMPIGrid&lt;real_type&gt; </code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The (single) datum to write.</td></tr>
  </table>
  </dd>
</dl>
<p>[unnamed bool] This parameter is ignored in both serial and MPI versions. In an MPI program all processes can call this function but only the master thread writes.  </p>
<dl class="section note"><dt>Note</dt><dd>The "master" thread is assumed to be the process with <code>rank==0</code> in <code>MPI_COMM_WORLD</code>. The <code>MPI_COMM_WORLD</code> rank of a process is usually the same in a Cartesian communicator of the same size but is not guaranteed. So always check <code>MPI_COMM_WORLD</code> ranks for file write operations.    </dd></dl>

</div>
</div>
<a id="gae6216fb6b41a9dddba170370aaa8be86" name="gae6216fb6b41a9dddba170370aaa8be86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6216fb6b41a9dddba170370aaa8be86">&#9670;&#160;</a></span>put_vara() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class Topology &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::file::put_vara </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>varid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Topology &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Write an array to NetCDF file. </p>
<p>Convenience wrapper around <code>nc_put_vara</code> </p>
<p>The purpose of this function is mainly to simplify output in an MPI environment and to provide the same interface also in a shared memory system for uniform programming. This version is for a time-dependent variable, i.e. writes a single time-slice into the file. The dimensionality is given by the grid. </p><dl class="section note"><dt>Note</dt><dd>This function throws a <code><a class="el" href="structdg_1_1file_1_1_n_c___error.html" title="Class thrown by the NC_Error_Handle.">dg::file::NC_Error</a></code> if an error occurs </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Topology</td><td>One of the dG defined grids (e.g. <code>dg::RealGrid2d</code>) Determines if shared memory or MPI version is called  </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">host_vector</td><td>For shared Topology: Type with <code>data()</code> member that returns pointer to first element in CPU (host) adress space, meaning it cannot be a GPU vector. For MPI Topology: must be <code>MPI_Vector</code> <code>host_vector::value_type</code> must match data type of variable in file.    </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>NetCDF file or group ID </td></tr>
    <tr><td class="paramname">varid</td><td>Variable ID </td></tr>
    <tr><td class="paramname">slice</td><td>The number of the time-slice to write (first element of the <code>startp</code> array in <code>nc_put_vara</code>)  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In NetCDF all variables that share an unlimited dimension are considered to have the same size in that dimension. In fact, the size of the unlimited dimension is the maximum of the sizes of all the variables sharing that unlimited dimension. All variables are artificially filled up with filler Values to match that maximum size. It is entirely possible to skip writing data for variables for some times. It is also possible to write data to unlimited variables at <code>slice&gt;=size</code> (in which case all variables sharing the unlimited dimension will increase in size) but it is not possible to read data at <code>slice&gt;=size</code>. It is the user's responsibility to manage the slice value across variables.    </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>The grid from which to construct <code>start</code> and <code>count</code> variables to forward to <code>nc_put_vara</code> </td></tr>
    <tr><td class="paramname">data</td><td>data to be written to the NetCDF file</td></tr>
  </table>
  </dd>
</dl>
<p>[unnamed bool] This parameter is there to make serial and parallel interface equal.  </p>
<dl class="section note"><dt>Note</dt><dd>The "master" thread is assumed to be the process with <code>rank==0</code> in <code>MPI_COMM_WORLD</code>. The <code>MPI_COMM_WORLD</code> rank of a process is usually the same in a Cartesian communicator of the same size but is not guaranteed. So always check <code>MPI_COMM_WORLD</code> ranks for file write operations.     </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>With the serial NetCDF library only a single "master" process can <b>write</b> in a NetCDF file (creation, defining dimension ids, variables ids, writing etc). Thus, in an MPI program<ul>
<li><code>parallel</code> should be <code>false</code> </li>
<li>the program links to <b>serial NetCDF and hdf5</b></li>
<li>only the master thread needs to know the <code>ncid</code>, variable or dimension names, the slice to write etc.</li>
</ul>
There is a parallel NetCDF library where all processes can have write access in parallel. In this case<ul>
<li><code>parallel</code> should be <code>true</code> </li>
<li>the program links to <b>parallel NetCDF and hdf5</b></li>
<li>the file must be opened with the <code>NC_MPIIO</code> flag from the <code>NetCDF_par.h</code> header and the variable be marked with <code>NC_COLLECTIVE</code> access</li>
<li>all threads need to know the <code>ncid</code>, variable and dimension names, the slice to write etc.</li>
</ul>
Note that serious performance penalties have been observed on some platforms for parallel writing NetCDF.    </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__legacy_gae6216fb6b41a9dddba170370aaa8be86_cgraph.svg" width="350" height="115"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:39 for Extension: Json and NetCDF utilities by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
