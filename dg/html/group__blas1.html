<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: BLAS level 1 routines: Vector-Vector</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__blas1.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">BLAS level 1 routines: Vector-Vector<div class="ingroups"><a class="el" href="group__level1.html">Level 1: Vectors, Matrices and basic operations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>\( f( x_{0i}, x_{1i}, x_{2i}, ...) \) and \( x^T y\)  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for BLAS level 1 routines: Vector-Vector:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__blas1.svg" width="411" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1blas1.html">dg::blas1</a></td></tr>
<tr class="memdesc:namespacedg_1_1blas1"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level 1 routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga46d63d18eddaa34b72ea3f197f7d51fb" id="r_ga46d63d18eddaa34b72ea3f197f7d51fb"><td class="memTemplParams" colspan="2">template&lt;class Functor , class ContainerType , class ... ContainerTypes&gt; </td></tr>
<tr class="memitem:ga46d63d18eddaa34b72ea3f197f7d51fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga46d63d18eddaa34b72ea3f197f7d51fb">dg::blas1::vdot</a> (Functor f, const ContainerType &amp;x, const ContainerTypes &amp;...xs) -&gt; std::invoke_result_t&lt; Functor, <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type</a>&lt; ContainerType &gt;, <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type</a>&lt; ContainerTypes &gt;... &gt;</td></tr>
<tr class="memdesc:ga46d63d18eddaa34b72ea3f197f7d51fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( \sum_i f(x_{0i}, x_{1i}, ...)\) Extended Precision transform reduce  <br /></td></tr>
<tr class="separator:ga46d63d18eddaa34b72ea3f197f7d51fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaab22d8f057bb35466d2bfcfddf1cf4d" id="r_gaaab22d8f057bb35466d2bfcfddf1cf4d"><td class="memTemplParams" colspan="2">template&lt;class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:gaaab22d8f057bb35466d2bfcfddf1cf4d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaaab22d8f057bb35466d2bfcfddf1cf4d">dg::blas1::dot</a> (const ContainerType1 &amp;x, const ContainerType2 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:gaaab22d8f057bb35466d2bfcfddf1cf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x^T y\) Binary reproducible Euclidean dot product between two vectors  <br /></td></tr>
<tr class="separator:gaaab22d8f057bb35466d2bfcfddf1cf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61cf5da3d6fd6325cb24522b7ac8a037" id="r_ga61cf5da3d6fd6325cb24522b7ac8a037"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class OutputType , class BinaryOp , class UnaryOp  = IDENTITY&gt; </td></tr>
<tr class="memitem:ga61cf5da3d6fd6325cb24522b7ac8a037"><td class="memTemplItemLeft" align="right" valign="top">OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga61cf5da3d6fd6325cb24522b7ac8a037">dg::blas1::reduce</a> (const ContainerType &amp;x, OutputType <a class="el" href="group__basics.html#gafc655fd420e1508e1fa0a12bc3c98480">zero</a>, BinaryOp binary_op, UnaryOp unary_op=UnaryOp())</td></tr>
<tr class="memdesc:ga61cf5da3d6fd6325cb24522b7ac8a037"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( f(x_0) \otimes f(x_1) \otimes \dots \otimes f(x_{N-1}) \) Custom (transform) reduction  <br /></td></tr>
<tr class="separator:ga61cf5da3d6fd6325cb24522b7ac8a037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ed8d5b1a17d0e8882b2d253a0d3fbed" id="r_ga0ed8d5b1a17d0e8882b2d253a0d3fbed"><td class="memTemplParams" colspan="2">template&lt;class ContainerTypeIn , class ContainerTypeOut &gt; </td></tr>
<tr class="memitem:ga0ed8d5b1a17d0e8882b2d253a0d3fbed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0ed8d5b1a17d0e8882b2d253a0d3fbed">dg::blas1::copy</a> (const ContainerTypeIn &amp;source, ContainerTypeOut &amp;target)</td></tr>
<tr class="memdesc:ga0ed8d5b1a17d0e8882b2d253a0d3fbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y=x \)  <br /></td></tr>
<tr class="separator:ga0ed8d5b1a17d0e8882b2d253a0d3fbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4e67d4aa98cc3b8601903570828e415" id="r_gac4e67d4aa98cc3b8601903570828e415"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> &gt; </td></tr>
<tr class="memitem:gac4e67d4aa98cc3b8601903570828e415"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac4e67d4aa98cc3b8601903570828e415">dg::blas1::scal</a> (ContainerType &amp;x, <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>)</td></tr>
<tr class="memdesc:gac4e67d4aa98cc3b8601903570828e415"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x = \alpha x\)  <br /></td></tr>
<tr class="separator:gac4e67d4aa98cc3b8601903570828e415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56955c8d6fbec095c1f5b1e57779b91d" id="r_ga56955c8d6fbec095c1f5b1e57779b91d"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> &gt; </td></tr>
<tr class="memitem:ga56955c8d6fbec095c1f5b1e57779b91d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga56955c8d6fbec095c1f5b1e57779b91d">dg::blas1::plus</a> (ContainerType &amp;x, <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>)</td></tr>
<tr class="memdesc:ga56955c8d6fbec095c1f5b1e57779b91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x = x + \alpha \)  <br /></td></tr>
<tr class="separator:ga56955c8d6fbec095c1f5b1e57779b91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20db094207e2f58e77ca01ff034ce41f" id="r_ga20db094207e2f58e77ca01ff034ce41f"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 &gt; </td></tr>
<tr class="memitem:ga20db094207e2f58e77ca01ff034ce41f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga20db094207e2f58e77ca01ff034ce41f">dg::blas1::axpby</a> (<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>, const ContainerType1 &amp;x, value_type1 <a class="elRef" href="../../matrix/html/polarization__b_8cpp.html#a4049344c4d6020a322197047b513967f">beta</a>, ContainerType &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:ga20db094207e2f58e77ca01ff034ce41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x + \beta y\)  <br /></td></tr>
<tr class="separator:ga20db094207e2f58e77ca01ff034ce41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16f5c5c01d352263aee6d8b4c282d7ad" id="r_ga16f5c5c01d352263aee6d8b4c282d7ad"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 , class value_type2 &gt; </td></tr>
<tr class="memitem:ga16f5c5c01d352263aee6d8b4c282d7ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga16f5c5c01d352263aee6d8b4c282d7ad">dg::blas1::axpbypgz</a> (<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>, const ContainerType1 &amp;x, value_type1 <a class="elRef" href="../../matrix/html/polarization__b_8cpp.html#a4049344c4d6020a322197047b513967f">beta</a>, const ContainerType2 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, value_type2 gamma, ContainerType &amp;<a class="el" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>)</td></tr>
<tr class="memdesc:ga16f5c5c01d352263aee6d8b4c282d7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( z = \alpha x + \beta y + \gamma z\)  <br /></td></tr>
<tr class="separator:ga16f5c5c01d352263aee6d8b4c282d7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87ab17f2a8331d6210c59b3775db0f7" id="r_gae87ab17f2a8331d6210c59b3775db0f7"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 &gt; </td></tr>
<tr class="memitem:gae87ab17f2a8331d6210c59b3775db0f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae87ab17f2a8331d6210c59b3775db0f7">dg::blas1::axpby</a> (<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>, const ContainerType1 &amp;x, value_type1 <a class="elRef" href="../../matrix/html/polarization__b_8cpp.html#a4049344c4d6020a322197047b513967f">beta</a>, const ContainerType2 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, ContainerType &amp;<a class="el" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>)</td></tr>
<tr class="memdesc:gae87ab17f2a8331d6210c59b3775db0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( z = \alpha x + \beta y\)  <br /></td></tr>
<tr class="separator:gae87ab17f2a8331d6210c59b3775db0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3fcab87e4c6df59ba719cf085ba2ad" id="r_ga3d3fcab87e4c6df59ba719cf085ba2ad"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 &gt; </td></tr>
<tr class="memitem:ga3d3fcab87e4c6df59ba719cf085ba2ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3d3fcab87e4c6df59ba719cf085ba2ad">dg::blas1::pointwiseDot</a> (<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>, const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, value_type1 <a class="elRef" href="../../matrix/html/polarization__b_8cpp.html#a4049344c4d6020a322197047b513967f">beta</a>, ContainerType &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:ga3d3fcab87e4c6df59ba719cf085ba2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x_1 x_2 + \beta y\)  <br /></td></tr>
<tr class="separator:ga3d3fcab87e4c6df59ba719cf085ba2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga117cb07cd3e8b6a8580bb42a9c00ab40" id="r_ga117cb07cd3e8b6a8580bb42a9c00ab40"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga117cb07cd3e8b6a8580bb42a9c00ab40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga117cb07cd3e8b6a8580bb42a9c00ab40">dg::blas1::pointwiseDot</a> (const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, ContainerType &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:ga117cb07cd3e8b6a8580bb42a9c00ab40"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = x_1 x_2 \)  <br /></td></tr>
<tr class="separator:ga117cb07cd3e8b6a8580bb42a9c00ab40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30bed3d80b7a8ef52d6ff8f82c5b6daf" id="r_ga30bed3d80b7a8ef52d6ff8f82c5b6daf"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class ContainerType3 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 &gt; </td></tr>
<tr class="memitem:ga30bed3d80b7a8ef52d6ff8f82c5b6daf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga30bed3d80b7a8ef52d6ff8f82c5b6daf">dg::blas1::pointwiseDot</a> (<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>, const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, const ContainerType3 &amp;x3, value_type1 <a class="elRef" href="../../matrix/html/polarization__b_8cpp.html#a4049344c4d6020a322197047b513967f">beta</a>, ContainerType &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:ga30bed3d80b7a8ef52d6ff8f82c5b6daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x_1 x_2 x_3 + \beta y\)  <br /></td></tr>
<tr class="separator:ga30bed3d80b7a8ef52d6ff8f82c5b6daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed1b7322791a0ac7ec25b9abe1608a02" id="r_gaed1b7322791a0ac7ec25b9abe1608a02"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 &gt; </td></tr>
<tr class="memitem:gaed1b7322791a0ac7ec25b9abe1608a02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaed1b7322791a0ac7ec25b9abe1608a02">dg::blas1::pointwiseDivide</a> (<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>, const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, value_type1 <a class="elRef" href="../../matrix/html/polarization__b_8cpp.html#a4049344c4d6020a322197047b513967f">beta</a>, ContainerType &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:gaed1b7322791a0ac7ec25b9abe1608a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha x_1/ x_2 + \beta y \)  <br /></td></tr>
<tr class="separator:gaed1b7322791a0ac7ec25b9abe1608a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e30e54e32bab62357425a0240d519ea" id="r_ga4e30e54e32bab62357425a0240d519ea"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga4e30e54e32bab62357425a0240d519ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4e30e54e32bab62357425a0240d519ea">dg::blas1::pointwiseDivide</a> (const ContainerType1 &amp;x1, const ContainerType2 &amp;x2, ContainerType &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:ga4e30e54e32bab62357425a0240d519ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = x_1/ x_2\)  <br /></td></tr>
<tr class="separator:ga4e30e54e32bab62357425a0240d519ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1332b3d86bc6e48b44a48d04c4da43b" id="r_gab1332b3d86bc6e48b44a48d04c4da43b"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class ContainerType3 , class ContainerType4 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 , class value_type2 &gt; </td></tr>
<tr class="memitem:gab1332b3d86bc6e48b44a48d04c4da43b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab1332b3d86bc6e48b44a48d04c4da43b">dg::blas1::pointwiseDot</a> (<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>, const ContainerType1 &amp;x1, const ContainerType2 &amp;y1, value_type1 <a class="elRef" href="../../matrix/html/polarization__b_8cpp.html#a4049344c4d6020a322197047b513967f">beta</a>, const ContainerType3 &amp;x2, const ContainerType4 &amp;y2, value_type2 gamma, ContainerType &amp;<a class="el" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>)</td></tr>
<tr class="memdesc:gab1332b3d86bc6e48b44a48d04c4da43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( z = \alpha x_1y_1 + \beta x_2y_2 + \gamma z\)  <br /></td></tr>
<tr class="separator:gab1332b3d86bc6e48b44a48d04c4da43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga493c6b70c8c889beaec1c3a669e3809b" id="r_ga493c6b70c8c889beaec1c3a669e3809b"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class ContainerType1 , class UnaryOp &gt; </td></tr>
<tr class="memitem:ga493c6b70c8c889beaec1c3a669e3809b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga493c6b70c8c889beaec1c3a669e3809b">dg::blas1::transform</a> (const ContainerType1 &amp;x, ContainerType &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, UnaryOp op)</td></tr>
<tr class="memdesc:ga493c6b70c8c889beaec1c3a669e3809b"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = op(x)\)  <br /></td></tr>
<tr class="separator:ga493c6b70c8c889beaec1c3a669e3809b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad7b58d466d813898b68189b44619210" id="r_gaad7b58d466d813898b68189b44619210"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class BinarySubroutine , class Functor , class ContainerType0 , class ... ContainerTypes&gt; </td></tr>
<tr class="memitem:gaad7b58d466d813898b68189b44619210"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaad7b58d466d813898b68189b44619210">dg::blas1::evaluate</a> (ContainerType &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, BinarySubroutine f, Functor g, const ContainerType0 &amp;x0, const ContainerTypes &amp;...xs)</td></tr>
<tr class="memdesc:gaad7b58d466d813898b68189b44619210"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( f(g(x_0,x_1,...), y)\)  <br /></td></tr>
<tr class="separator:gaad7b58d466d813898b68189b44619210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7386b5cb0144d5364b8ea8c8ce1482a5" id="r_ga7386b5cb0144d5364b8ea8c8ce1482a5"><td class="memTemplParams" colspan="2">template&lt;class Subroutine , class ContainerType , class ... ContainerTypes&gt; </td></tr>
<tr class="memitem:ga7386b5cb0144d5364b8ea8c8ce1482a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7386b5cb0144d5364b8ea8c8ce1482a5">dg::blas1::subroutine</a> (Subroutine f, ContainerType &amp;&amp;x, ContainerTypes &amp;&amp;... xs)</td></tr>
<tr class="memdesc:ga7386b5cb0144d5364b8ea8c8ce1482a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( f(x_0, x_1, ...)\); Customizable and generic <a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a> function  <br /></td></tr>
<tr class="separator:ga7386b5cb0144d5364b8ea8c8ce1482a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb2af43e4e5cf87153ede64c181ba61e" id="r_gadb2af43e4e5cf87153ede64c181ba61e"><td class="memTemplParams" colspan="2">template&lt;class ContainerType0 , class BinarySubroutine , class Functor , class ContainerType1 , class ... ContainerTypes&gt; </td></tr>
<tr class="memitem:gadb2af43e4e5cf87153ede64c181ba61e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadb2af43e4e5cf87153ede64c181ba61e">dg::blas1::kronecker</a> (ContainerType0 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, BinarySubroutine f, Functor g, const ContainerType1 &amp;x0, const ContainerTypes &amp;...xs)</td></tr>
<tr class="memdesc:gadb2af43e4e5cf87153ede64c181ba61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( f(g(x_{0i_0},x_{1i_1},...), y_I)\) (Kronecker evaluation)  <br /></td></tr>
<tr class="separator:gadb2af43e4e5cf87153ede64c181ba61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ca1b8d3f70004e25ddc2010f7e9e0d" id="r_gab0ca1b8d3f70004e25ddc2010f7e9e0d"><td class="memTemplParams" colspan="2">template&lt;class from_ContainerType , class ContainerType , class ... Params&gt; </td></tr>
<tr class="memitem:gab0ca1b8d3f70004e25ddc2010f7e9e0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab0ca1b8d3f70004e25ddc2010f7e9e0d">dg::assign</a> (const from_ContainerType &amp;from, ContainerType &amp;<a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40">to</a>, Params &amp;&amp;... ps)</td></tr>
<tr class="memdesc:gab0ca1b8d3f70004e25ddc2010f7e9e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic way to assign the contents of a <code>from_ContainerType</code> object to a <code>ContainerType</code> object optionally given additional parameters.  <br /></td></tr>
<tr class="separator:gab0ca1b8d3f70004e25ddc2010f7e9e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dbfc632d4d66d2d926dd525ed7fcea8" id="r_ga5dbfc632d4d66d2d926dd525ed7fcea8"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class from_ContainerType , class ... Params&gt; </td></tr>
<tr class="memitem:ga5dbfc632d4d66d2d926dd525ed7fcea8"><td class="memTemplItemLeft" align="right" valign="top">ContainerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5dbfc632d4d66d2d926dd525ed7fcea8">dg::construct</a> (const from_ContainerType &amp;from, Params &amp;&amp;... ps)</td></tr>
<tr class="memdesc:ga5dbfc632d4d66d2d926dd525ed7fcea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic way to construct an object of <code>ContainerType</code> given a <code>from_ContainerType</code> object and optional additional parameters.  <br /></td></tr>
<tr class="separator:ga5dbfc632d4d66d2d926dd525ed7fcea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a5fec2b7e6325a3f4c44ab223cdc81" id="r_ga04a5fec2b7e6325a3f4c44ab223cdc81"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class Functor , class ... ContainerTypes&gt; </td></tr>
<tr class="memitem:ga04a5fec2b7e6325a3f4c44ab223cdc81"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga04a5fec2b7e6325a3f4c44ab223cdc81">dg::kronecker</a> (Functor &amp;&amp;f, const ContainerType &amp;x0, const ContainerTypes &amp;... xs)</td></tr>
<tr class="memdesc:ga04a5fec2b7e6325a3f4c44ab223cdc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y_I = f(x_{0i_0}, x_{1i_1}, ...) \) Memory allocating version of <code><a class="el" href="#gadb2af43e4e5cf87153ede64c181ba61e" title="(Kronecker evaluation)">dg::blas1::kronecker</a></code>  <br /></td></tr>
<tr class="separator:ga04a5fec2b7e6325a3f4c44ab223cdc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>\( f( x_{0i}, x_{1i}, x_{2i}, ...) \) and \( x^T y\) </p>
<dl class="section note"><dt>Note</dt><dd>Successive calls to blas routines are executed sequentially </dd>
<dd>
A manual synchronization of threads or devices is never needed in an application using these functions. All functions returning a value block until the value is ready.</dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab0ca1b8d3f70004e25ddc2010f7e9e0d" name="gab0ca1b8d3f70004e25ddc2010f7e9e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0ca1b8d3f70004e25ddc2010f7e9e0d">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class from_ContainerType , class ContainerType , class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::assign </td>
          <td>(</td>
          <td class="paramtype">const from_ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic way to assign the contents of a <code>from_ContainerType</code> object to a <code>ContainerType</code> object optionally given additional parameters. </p>
<p>The idea of this function is to convert between types with the same data layout but different execution policies (e.g. from a thrust::host_vector to a thrust::device_vector). If the layout differs, additional parameters can be used to achieve what you want.</p>
<p>For example </p><div class="fragment"><div class="line">        <span class="comment">//Assign a host vector to a device vector</span></div>
<div class="line">        <a class="code hl_typedef" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef">dg::HVec</a> host( 100, 1.);</div>
<div class="line">        <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> device(100);</div>
<div class="line">        <a class="code hl_function" href="#gab0ca1b8d3f70004e25ddc2010f7e9e0d">dg::assign</a>( host, device );</div>
<div class="line">        CHECK( device == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, 1.));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//Assign a host vector to all elements of a std::vector of 3 dg::DVec</span></div>
<div class="line">        std::vector&lt;dg::DVec&gt; device_vec;</div>
<div class="line">        <a class="code hl_function" href="#gab0ca1b8d3f70004e25ddc2010f7e9e0d">dg::assign</a>( host, device_vec, 3);</div>
<div class="line">        REQUIRE( device_vec.size() == 3);</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> u=0; u&lt;3; u ++)</div>
<div class="line">            CHECK( device_vec[u] == device);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>source vector </td></tr>
    <tr><td class="paramname">to</td><td>target vector contains a copy of <code>from</code> on output (memory is automatically resized if necessary) </td></tr>
    <tr><td class="paramname">ps</td><td>additional parameters usable for the transfer operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>it is possible to assign a <code>from_ContainerType</code> to a <code> std::array&lt;ContainerType, N&gt; </code> (all elements are initialized with from_ContainerType) and also a <code> std::vector&lt;ContainerType&gt;</code> ( the desired size of the <code>std::vector</code> must be provided as an additional parameter) </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">from_ContainerType</td><td>must have the same data policy derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> as <code>ContainerType</code> (with the exception of <code>std::array</code> and <code>std::vector</code>) but can have different execution policy </td></tr>
    <tr><td class="paramname">Params</td><td>in some cases additional parameters that are necessary to assign objects of Type <code>ContainerType</code>  </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="gae87ab17f2a8331d6210c59b3775db0f7" name="gae87ab17f2a8331d6210c59b3775db0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae87ab17f2a8331d6210c59b3775db0f7">&#9670;&#160;</a></span>axpby() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::axpby </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type1</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( z = \alpha x + \beta y\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ z_i =  \alpha x_i + \beta y_i \]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), three(100,3), result(100);</div>
<div class="line"><a class="code hl_function" href="#ga20db094207e2f58e77ca01ff034ce41f">dg::blas1::axpby</a>( 2, two, 3., three, result);</div>
<div class="line">CHECK( result == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, 13.)); <span class="comment">// 2*2+3*3</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>ContainerType x may alias z </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">y</td><td>ContainerType y may alias z </td></tr>
    <tr><td class="paramname">z</td><td>(write-only) ContainerType z contains solution on output  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>Any type that can be used in an arithmetic operation with <code><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type&lt;ContainerType&gt;</a></code>    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga20db094207e2f58e77ca01ff034ce41f" name="ga20db094207e2f58e77ca01ff034ce41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20db094207e2f58e77ca01ff034ce41f">&#9670;&#160;</a></span>axpby() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::axpby </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type1</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x + \beta y\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ y_i =  \alpha x_i + \beta y_i \]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), three(100,3);</div>
<div class="line"><a class="code hl_function" href="#ga20db094207e2f58e77ca01ff034ce41f">dg::blas1::axpby</a>( 2, two, 3., three);</div>
<div class="line">CHECK( three == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, 13.)); <span class="comment">// 2*2+3*3</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>ContainerType x may alias y </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">y</td><td>(read/write) ContainerType y contains solution on output  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="ga16f5c5c01d352263aee6d8b4c282d7ad" name="ga16f5c5c01d352263aee6d8b4c282d7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16f5c5c01d352263aee6d8b4c282d7ad">&#9670;&#160;</a></span>axpbypgz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 , class value_type2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::axpbypgz </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type1</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type2</td>          <td class="paramname"><span class="paramname"><em>gamma</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( z = \alpha x + \beta y + \gamma z\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ z_i =  \alpha x_i + \beta y_i + \gamma z_i \]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), three(100,3);</div>
<div class="line"><a class="code hl_function" href="#ga20db094207e2f58e77ca01ff034ce41f">dg::blas1::axpby</a>( 2, two, 3., three);</div>
<div class="line">CHECK( three == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, 13.)); <span class="comment">// 2*2+3*3</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>ContainerType x may alias result </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">y</td><td>ContainerType y may alias result </td></tr>
    <tr><td class="paramname">gamma</td><td>Scalar </td></tr>
    <tr><td class="paramname">z</td><td>(read/write) ContainerType contains solution on output  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>Any type that can be used in an arithmetic operation with <code><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type&lt;ContainerType&gt;</a></code>    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5dbfc632d4d66d2d926dd525ed7fcea8" name="ga5dbfc632d4d66d2d926dd525ed7fcea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dbfc632d4d66d2d926dd525ed7fcea8">&#9670;&#160;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class from_ContainerType , class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ContainerType dg::construct </td>
          <td>(</td>
          <td class="paramtype">const from_ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic way to construct an object of <code>ContainerType</code> given a <code>from_ContainerType</code> object and optional additional parameters. </p>
<p>The idea of this function is to convert between types with the same data layout but different execution policies (e.g. from a thrust::host_vector to a thrust::device_vector) If the layout differs, additional parameters can be used to achieve what you want.</p>
<p>For example </p><div class="fragment"><div class="line">        <span class="comment">//Construct a device vector from host vector</span></div>
<div class="line">        <a class="code hl_typedef" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef">dg::HVec</a> host( 100, 1.);</div>
<div class="line">        <span class="keyword">auto</span> device = <a class="code hl_function" href="#ga5dbfc632d4d66d2d926dd525ed7fcea8">dg::construct&lt;dg::DVec&gt;</a>( host );</div>
<div class="line">        CHECK( device == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, 1.));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Construct an array of vectors</span></div>
<div class="line">        <span class="keyword">auto</span> device_arr = <a class="code hl_function" href="#ga5dbfc632d4d66d2d926dd525ed7fcea8">dg::construct&lt;std::array&lt;dg::DVec, 3&gt;</a>&gt;( host );</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> u=0; u&lt;3; u ++)</div>
<div class="line">            CHECK( device_arr[u] == device);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//Construct a std::vector of 3 dg::DVec from a host vector</span></div>
<div class="line">        <span class="keyword">auto</span> device_vec = <a class="code hl_function" href="#ga5dbfc632d4d66d2d926dd525ed7fcea8">dg::construct&lt;std::vector&lt;dg::DVec&gt;</a>&gt;( host, 3);</div>
<div class="line">        REQUIRE( device_vec.size() == 3);</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> u=0; u&lt;3; u++)</div>
<div class="line">            CHECK( device_vec[u] == device);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Can also be used to change value type, e.g. complex:</span></div>
<div class="line">        <span class="keyword">auto</span> complex_dev = <a class="code hl_function" href="#ga5dbfc632d4d66d2d926dd525ed7fcea8">dg::construct&lt;dg::cDVec&gt;</a>( host );</div>
<div class="line">        CHECK( complex_dev == <a class="code hl_typedef" href="group__typedefs.html#ga74a6de853762072b070e72b2311a04b2">dg::cDVec</a>( 100, thrust::complex&lt;double&gt;(1.)));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>source vector </td></tr>
    <tr><td class="paramname">ps</td><td>additional parameters necessary to construct a <code>ContainerType</code> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>from</code> converted to the new format (memory is allocated accordingly) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>it is possible to construct a <code> std::array&lt;ContainerType, N&gt; </code> (all elements are initialized with from_ContainerType) and also a <code> std::vector&lt;ContainerType&gt;</code> ( the desired size of the <code>std::vector</code> must be provided as an additional parameter) given a <code>from_ContainerType</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">from_ContainerType</td><td>must have the same data policy derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> as <code>ContainerType</code> (with the exception of <code>std::array</code> and <code>std::vector</code>) but can have different execution policy </td></tr>
    <tr><td class="paramname">Params</td><td>in some cases additional parameters that are necessary to construct objects of Type <code>ContainerType</code>  </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="ga0ed8d5b1a17d0e8882b2d253a0d3fbed" name="ga0ed8d5b1a17d0e8882b2d253a0d3fbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ed8d5b1a17d0e8882b2d253a0d3fbed">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerTypeIn , class ContainerTypeOut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::copy </td>
          <td>(</td>
          <td class="paramtype">const ContainerTypeIn &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerTypeOut &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y=x \) </p>
<p>explicit pointwise assignment \( y_i = x_i\)  </p>
<p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), two_copy(100);</div>
<div class="line"><a class="code hl_function" href="#ga0ed8d5b1a17d0e8882b2d253a0d3fbed">dg::blas1::copy</a>( two, two_copy);</div>
<div class="line">CHECK( two_copy == two);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>vector to copy </td></tr>
    <tr><td class="paramname">target</td><td>(write-only) destination </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>in contrast to the <code><a class="el" href="#gab0ca1b8d3f70004e25ddc2010f7e9e0d" title="Generic way to assign the contents of a from_ContainerType object to a ContainerType object optionall...">dg::assign</a></code> functions the <code>copy</code> function uses the execution policy to determine the implementation and thus works only on types with same execution policy </dd>
<dd>
catches self-assignment  </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="gaaab22d8f057bb35466d2bfcfddf1cf4d" name="gaaab22d8f057bb35466d2bfcfddf1cf4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaab22d8f057bb35466d2bfcfddf1cf4d">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto dg::blas1::dot </td>
          <td>(</td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x^T y\) Binary reproducible Euclidean dot product between two vectors </p>
<p>This routine computes </p><p class="formulaDsp">
\[ x^T y = \sum_{i=0}^{N-1} x_i y_i \]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2.0), three(100,3.0);</div>
<div class="line"><span class="keywordtype">double</span> result = <a class="code hl_function" href="#gaaab22d8f057bb35466d2bfcfddf1cf4d">dg::blas1::dot</a>(two, three);</div>
<div class="line">CHECK( result == 600.0); <span class="comment">//100*(2*3)</span></div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">std::vector&lt;thrust::complex&lt;double&gt;&gt; c0( 100, {1,1}), c1(100, {1,-1});</div>
<div class="line"><span class="keyword">auto</span> cresult = <a class="code hl_function" href="#gaaab22d8f057bb35466d2bfcfddf1cf4d">dg::blas1::dot</a>(c0, c1);</div>
<div class="line"><span class="comment">// Result is of complex type</span></div>
<div class="line">CHECK( cresult == thrust::complex&lt;double&gt;{200,0});</div>
</div><!-- fragment --> <dl class="section attention"><dt>Attention</dt><dd>if one of the input vectors contains <code>Inf</code> or <code>NaN</code> or the product of the input numbers reaches <code>Inf</code> or <code>Nan</code> then the behaviour is undefined and the function may throw. See <a class="el" href="structdg_1_1_i_s_n_f_i_n_i_t_e.html">dg::ISNFINITE</a> and <a class="el" href="structdg_1_1_i_s_n_s_a_n_e.html">dg::ISNSANE</a> in that case </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Our implementation guarantees <b>binary reproducible</b> results. The sum is computed with <b>infinite precision</b> and the result is rounded to the nearest double precision number. This is possible with the help of an adapted version of the <code><a class="elRef" href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></code> library and works for single and double precision. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Binary Reproducible results are only guaranteed for <b>float</b> or <b>double</b> input. All other value types redirect to <code> dg::blas1::vdot( dg::Product(), x, y);</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left Container </td></tr>
    <tr><td class="paramname">y</td><td>Right Container may alias x </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar product as defined above </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is always executed synchronously due to the implicit memcpy of the result. With mpi the result is broadcasted to all processes.  </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="gaad7b58d466d813898b68189b44619210" name="gaad7b58d466d813898b68189b44619210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad7b58d466d813898b68189b44619210">&#9670;&#160;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class BinarySubroutine , class Functor , class ContainerType0 , class ... ContainerTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::evaluate </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinarySubroutine</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType0 &amp;</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerTypes &amp;...</td>          <td class="paramname"><span class="paramname"><em>xs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( f(g(x_0,x_1,...), y)\) </p>
<p>This routine elementwise evaluates </p><p class="formulaDsp">
\[ f(g(x_{0i}, x_{1i}, ...), y_i) \]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><span class="keyword">auto</span> function = [](<span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>, <span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>){</div>
<div class="line">    <span class="keywordflow">return</span> sin(x)*sin(y);</div>
<div class="line">};</div>
<div class="line"><a class="code hl_typedef" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef">dg::HVec</a> pi2(20, <a class="code hl_define" href="functors_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>/2.), pi3( 20, 3*<a class="code hl_define" href="functors_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>/2.), result(20, 0);</div>
<div class="line"><a class="code hl_function" href="#gaad7b58d466d813898b68189b44619210">dg::blas1::evaluate</a>( result, <a class="code hl_struct" href="structdg_1_1equals.html">dg::equals</a>(), function, pi2, pi3);</div>
<div class="line">CHECK( result == <a class="code hl_typedef" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef">dg::HVec</a>( 20, -1.)); <span class="comment">// sin(M_PI/2.)*sin(3*M_PI/2.) = -1</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinarySubroutine</td><td>Functor with signature: <code> void ( value_type_g, value_type_y&amp;) </code> i.e. it reads the first (and second) and writes into the second argument </td></tr>
    <tr><td class="paramname">Functor</td><td>signature: <code> value_type_g operator()( value_type_x0, value_type_x1, ...) </code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Both <code>BinarySubroutine</code> and <code>Functor</code> must be callable on the device in use. In particular, with CUDA they must be functor tpyes (<b>not</b> functions) and their signatures must contain the __device__ specifier. (s.a. <a class="el" href="group__typedefs.html#gaa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>contains result </td></tr>
    <tr><td class="paramname">f</td><td>The subroutine, for example <code><a class="el" href="structdg_1_1equals.html">dg::equals</a></code> or <code><a class="el" href="structdg_1_1plus__equals.html">dg::plus_equals</a></code>, see <a class="el" href="group__binary__operators.html">dg::blas1::evaluate binary operators</a> for a collection of predefined functors to use here </td></tr>
    <tr><td class="paramname">g</td><td>The functor to evaluate, see <a class="el" href="group__functions.html">A large collection</a> and <a class="el" href="group__variadic__evaluates.html">dg::blas1::evaluate variadic functors</a> for a collection of predefined functors to use here </td></tr>
    <tr><td class="paramname">x0</td><td>first input </td></tr>
    <tr><td class="paramname">xs</td><td>more input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>all aliases allowed  </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="gadb2af43e4e5cf87153ede64c181ba61e" name="gadb2af43e4e5cf87153ede64c181ba61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb2af43e4e5cf87153ede64c181ba61e">&#9670;&#160;</a></span>kronecker() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType0 , class BinarySubroutine , class Functor , class ContainerType1 , class ... ContainerTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::kronecker </td>
          <td>(</td>
          <td class="paramtype">ContainerType0 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinarySubroutine</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerTypes &amp;...</td>          <td class="paramname"><span class="paramname"><em>xs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( f(g(x_{0i_0},x_{1i_1},...), y_I)\) (Kronecker evaluation) </p>
<p>This routine elementwise evaluates </p><p class="formulaDsp">
\[ f(g(x_{0i_0}, x_{1i_1}, ..., x_{(n-1)i_{n-1}}), y_{((i_{n-1} N_{n-2} +...)N_1+i_1)N_0+i_0}) \]
</p>
<p> for all <b>combinations</b> of input values. \( N_i\) is the size of the vector \( x_i\). The **first index \(i_0\) is the fastest varying in the output**, then \( i_1\), etc. If \( x_i\) is a scalar then the size \( N_i = 1\). </p><dl class="section attention"><dt>Attention</dt><dd>None of the \( x_i\) or \( y\) can have the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">dg::RecursiveVectorTag</a></code> </dd></dl>
<p>The size of the output \( y\) must match the product of sizes of input vectors i.e. </p><p class="formulaDsp">
\[ N_y = \prod_{i=0}^{n-1} N_i \]
</p>
<p> The order of evaluations is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.</p>
<p>For example </p><div class="fragment"><div class="line">        <span class="keyword">auto</span> function = []( <span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>, <span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>) {</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>+<a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>;</div>
<div class="line">        };</div>
<div class="line">        std::vector&lt;double&gt; xs{1,2,3,4}, ys{ 10,20,30,40}, <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(16, 0);</div>
<div class="line">        <a class="code hl_function" href="#gadb2af43e4e5cf87153ede64c181ba61e">dg::blas1::kronecker</a>( y, <a class="code hl_struct" href="structdg_1_1equals.html">dg::equals</a>(), function, xs, ys);</div>
<div class="line">        <span class="comment">// Note how xs varies fastest in result:</span></div>
<div class="line">        std::vector&lt;double&gt; result = { 11,12,13,14,21,22,23,24,31,32,33,34,41,42,43,44};</div>
<div class="line">        CHECK( y == result);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Note that the following code is equivalent</span></div>
<div class="line">        <span class="comment">// but that dg::blas1::kronecker has a performance advantage since</span></div>
<div class="line">        <span class="comment">// it never explicitly forms XS or YS</span></div>
<div class="line">        std::vector&lt;double&gt; XS(16), YS(16);</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;4; i++)</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> k=0; k&lt;4; k++)</div>
<div class="line">        {</div>
<div class="line">            XS[i*4+k] = xs[k];</div>
<div class="line">            YS[i*4+k] = ys[i];</div>
<div class="line">        }</div>
<div class="line">        <a class="code hl_function" href="#gaad7b58d466d813898b68189b44619210">dg::blas1::evaluate</a>( y, <a class="code hl_struct" href="structdg_1_1equals.html">dg::equals</a>(), function, XS, YS);</div>
<div class="line">        CHECK( y == result);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Finally, we could also write</span></div>
<div class="line">        <a class="code hl_function" href="#gadb2af43e4e5cf87153ede64c181ba61e">dg::blas1::kronecker</a>( XS, <a class="code hl_struct" href="structdg_1_1equals.html">dg::equals</a>(), []( <span class="keywordtype">double</span> x, <span class="keywordtype">double</span>){ <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>;}, xs, ys);</div>
<div class="line">        <a class="code hl_function" href="#gadb2af43e4e5cf87153ede64c181ba61e">dg::blas1::kronecker</a>( YS, <a class="code hl_struct" href="structdg_1_1equals.html">dg::equals</a>(), []( <span class="keywordtype">double</span>, <span class="keywordtype">double</span> y){ <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>;}, xs, ys);</div>
<div class="line">        <a class="code hl_function" href="#gaad7b58d466d813898b68189b44619210">dg::blas1::evaluate</a>( y, <a class="code hl_struct" href="structdg_1_1equals.html">dg::equals</a>(), function, XS, YS);</div>
<div class="line">        CHECK( y == result);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function is trivially parallel and the MPI version simply calls the appropriate shared memory version The user is responsible for making sure that the result has the correct communicator </dd>
<dd>
For the function \( f(x_0, x_1, ..., x_{n-1}) = x_0 x_1 ... x_{n-1} \) <code> dg::blas1::kronecker(y, dg::equals(), x_0, x_1, ...) </code>computes the actual Kronecker product of the arguments <b>in reversed order</b> <p class="formulaDsp">
\[ y = x_{n-1} \otimes x_{n-2} \otimes ... \otimes x_1 \otimes x_0\]
</p>
 (or the outer product) With this behaviour we can in e.g. Cartesian coordinates naturally define functions \( f(x,y,z)\) and evaluate this function on product space coordinates and have ** \( x \) as the fastest varying coordinate in memory**.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinarySubroutine</td><td>Functor with signature: <code> void ( value_type_g, value_type_y&amp;) </code> i.e. it reads the first (and second) and writes into the second argument </td></tr>
    <tr><td class="paramname">Functor</td><td>signature: <code> value_type_g operator()( value_type_x0, value_type_x1, ...) </code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Both <code>BinarySubroutine</code> and <code>Functor</code> must be callable on the device in use. In particular, with CUDA they must be functor tpyes (<b>not</b> functions) and their signatures must contain the __device__ specifier. (s.a. <a class="el" href="group__typedefs.html#gaa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>contains result (size of y must match the product of sizes of \( x_i\)) </td></tr>
    <tr><td class="paramname">f</td><td>The subroutine, for example <code><a class="el" href="structdg_1_1equals.html">dg::equals</a></code> or <code><a class="el" href="structdg_1_1plus__equals.html">dg::plus_equals</a></code>, see <a class="el" href="group__binary__operators.html">dg::blas1::evaluate binary operators</a> for a collection of predefined functors to use here </td></tr>
    <tr><td class="paramname">g</td><td>The functor to evaluate, see <a class="el" href="group__functions.html">A large collection</a> and <a class="el" href="group__variadic__evaluates.html">dg::blas1::evaluate variadic functors</a> for a collection of predefined functors to use here </td></tr>
    <tr><td class="paramname">x0</td><td>first input </td></tr>
    <tr><td class="paramname">xs</td><td>more input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>all aliases allowed  </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system   </dd>
<dd>
<a class="el" href="#ga04a5fec2b7e6325a3f4c44ab223cdc81" title="Memory allocating version of dg::blas1::kronecker">dg::kronecker</a> </dd></dl>

</div>
</div>
<a id="ga04a5fec2b7e6325a3f4c44ab223cdc81" name="ga04a5fec2b7e6325a3f4c44ab223cdc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04a5fec2b7e6325a3f4c44ab223cdc81">&#9670;&#160;</a></span>kronecker() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class Functor , class ... ContainerTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto dg::kronecker </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerTypes &amp;...</td>          <td class="paramname"><span class="paramname"><em>xs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>\( y_I = f(x_{0i_0}, x_{1i_1}, ...) \) Memory allocating version of <code><a class="el" href="#gadb2af43e4e5cf87153ede64c181ba61e" title="(Kronecker evaluation)">dg::blas1::kronecker</a></code> </p>
<p>In a shared memory space with serial execution this function is implemented roughly as in the following pseudo-code </p><div class="fragment"><div class="line"><span class="comment">// assume x0, xs are host vectors</span></div>
<div class="line">size = product( x0.size(), xs.size(), ...)</div>
<div class="line">using <a class="code hl_typedefRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> = decltype( f(x0[0], xs[0]...));</div>
<div class="line">thrust::host_vector&lt;<a class="code hl_typedefRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a>&gt; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(size);</div>
<div class="line"><a class="code hl_namespace" href="namespacedg.html">dg</a>::blas1::<a class="code hl_function" href="#ga04a5fec2b7e6325a3f4c44ab223cdc81">kronecker</a>( <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, <a class="code hl_namespace" href="namespacedg.html">dg</a>::<a class="code hl_struct" href="structdg_1_1equals.html">equals</a>(), f, x0, xs...);</div>
<div class="ttc" id="agroup__blas1_html_ga04a5fec2b7e6325a3f4c44ab223cdc81"><div class="ttname"><a href="#ga04a5fec2b7e6325a3f4c44ab223cdc81">dg::kronecker</a></div><div class="ttdeci">auto kronecker(Functor &amp;&amp;f, const ContainerType &amp;x0, const ContainerTypes &amp;... xs)</div><div class="ttdoc">Memory allocating version of dg::blas1::kronecker</div><div class="ttdef"><b>Definition</b> blas1.h:857</div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">dg::coo2d::y</a></div><div class="ttdeci">@ y</div><div class="ttdoc">y direction</div></div>
<div class="ttc" id="anamespacedg_html"><div class="ttname"><a href="namespacedg.html">dg</a></div><div class="ttdoc">This is the namespace for all functions and classes defined and used by the discontinuous Galerkin li...</div></div>
<div class="ttc" id="astructdg_1_1equals_html"><div class="ttname"><a href="structdg_1_1equals.html">dg::equals</a></div><div class="ttdef"><b>Definition</b> subroutines.h:22</div></div>
<div class="ttc" id="atridiaginv__b_8cpp_html_a099c90519d34c2dbab58e4a771aa6f25"><div class="ttname"><a href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a></div><div class="ttdeci">double value_type</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The return type is inferred from the <code>execution_policy</code> and the <code>tensor_category</code> of the input vectors. It is unspecified. It is such that the resulting vector is exactly compatible in a call to <code> dg::kronecker( result, dg::equals(), f, x0, xs...); </code></dd></dl>
<p>The MPI distributed version of this function is implemented as </p><div class="fragment"><div class="line">MPI_Comm comm_kron = <a class="code hl_function" href="group__mpi__utility.html#gacb0e11d4d2ad14c3512f6773e351863f">dg::mpi_cart_kron</a>( x0.communicator(), xs.communicator()...);</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_struct" href="structdg_1_1_m_p_i___vector.html">MPI_Vector</a>{<a class="code hl_function" href="#ga04a5fec2b7e6325a3f4c44ab223cdc81">dg::kronecker</a>( f, x0.data(), xs.data()...), comm_kron}; <span class="comment">// a dg::MPI_Vector</span></div>
<div class="ttc" id="agroup__mpi__utility_html_gacb0e11d4d2ad14c3512f6773e351863f"><div class="ttname"><a href="group__mpi__utility.html#gacb0e11d4d2ad14c3512f6773e351863f">dg::mpi_cart_kron</a></div><div class="ttdeci">MPI_Comm mpi_cart_kron(std::vector&lt; MPI_Comm &gt; comms)</div><div class="ttdoc">Form a Kronecker product among Cartesian communicators.</div><div class="ttdef"><b>Definition</b> mpi_kron.h:178</div></div>
<div class="ttc" id="astructdg_1_1_m_p_i___vector_html"><div class="ttname"><a href="structdg_1_1_m_p_i___vector.html">dg::MPI_Vector</a></div><div class="ttdoc">A simple wrapper around a container object and an MPI_Comm.</div><div class="ttdef"><b>Definition</b> mpi_vector.h:37</div></div>
</div><!-- fragment --> <dl class="section attention"><dt>Attention</dt><dd>In particular this means that in MPI all the communicators in the input argument vectors need to be Cartesian communicators that were created from a common Cartesian root communicator and both root and all sub communicators need to be registered in the dg library through calls to <code>dg::register_mpi_cart_sub</code> or <code><a class="el" href="group__mpi__utility.html#ga9983503a764d29bffd43cc93878d2ebb" title="Call and register a call to MPI_Cart_sub with the dg library.">dg::mpi_cart_sub</a></code>. Further, the order of input-communicators must match the dimensions in the common root communicator (see <code><a class="el" href="group__mpi__utility.html#gacb0e11d4d2ad14c3512f6773e351863f" title="Form a Kronecker product among Cartesian communicators.">dg::mpi_cart_kron</a></code>) i.e. currently <b>in MPI it is not possible to transpose with this function</b></dd></dl>
<p>The rationale for this behaviour is that:</p>
<ol type="1">
<li>the MPI standard has no easy way of finding a common ancestor to Cartesin sub communicators</li>
<li>the MPI standard has no easy way of re-joining previously split Cartesian communicators</li>
<li>we want to avoid creating a new communicator every time this function is called.</li>
</ol>
<p>For example </p><div class="fragment"><div class="line"><span class="keyword">auto</span> function = []( <span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>, <span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>+<a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>;</div>
<div class="line">};</div>
<div class="line">std::vector&lt;double&gt; xs{1,2,3,4}, ys{ 10,20,30,40};</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a> = <a class="code hl_function" href="#ga04a5fec2b7e6325a3f4c44ab223cdc81">dg::kronecker</a>( function, xs, ys);</div>
<div class="line"><span class="comment">// Note how xs varies fastest in result:</span></div>
<div class="line">std::vector&lt;double&gt; result = { 11,12,13,14,21,22,23,24,31,32,33,34,41,42,43,44};</div>
<div class="line">CHECK( y == result);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>signature: <code> value_type_g operator()( value_type_x0, value_type_x1, ...) </code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><code>Functor</code> must be callable on the device in use. In particular, with CUDA it must be a functor tpye (<b>not</b> a function) and its signature must contain the __device__ specifier. (s.a. <a class="el" href="group__typedefs.html#gaa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The functor to evaluate, see <a class="el" href="group__functions.html">A large collection</a> and <a class="el" href="group__variadic__evaluates.html">dg::blas1::evaluate variadic functors</a> for a collection of predefined functors to use here </td></tr>
    <tr><td class="paramname">x0</td><td>first input </td></tr>
    <tr><td class="paramname">xs</td><td>more input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly allocated result (size of container matches the product of sizes of \( x_i\))</dd></dl>
<dl class="section note"><dt>Note</dt><dd>all aliases allowed  </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system   </dd>
<dd>
<a class="el" href="#gadb2af43e4e5cf87153ede64c181ba61e" title="(Kronecker evaluation)">dg::blas1::kronecker</a> <a class="el" href="group__mpi__utility.html#gacb0e11d4d2ad14c3512f6773e351863f" title="Form a Kronecker product among Cartesian communicators.">dg::mpi_cart_kron</a> </dd></dl>

</div>
</div>
<a id="ga56955c8d6fbec095c1f5b1e57779b91d" name="ga56955c8d6fbec095c1f5b1e57779b91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56955c8d6fbec095c1f5b1e57779b91d">&#9670;&#160;</a></span>plus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::plus </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x = x + \alpha \) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ x_i + \alpha \]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2);</div>
<div class="line"><a class="code hl_function" href="#ga56955c8d6fbec095c1f5b1e57779b91d">dg::blas1::plus</a>( two, 3.);</div>
<div class="line">CHECK( two == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, 5.));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) x  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>Any type that can be used in an arithmetic operation with <code><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type&lt;ContainerType&gt;</a></code>    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e30e54e32bab62357425a0240d519ea" name="ga4e30e54e32bab62357425a0240d519ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e30e54e32bab62357425a0240d519ea">&#9670;&#160;</a></span>pointwiseDivide() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDivide </td>
          <td>(</td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = x_1/ x_2\) </p>
<p>Divides two vectors element by element: </p><p class="formulaDsp">
\[ y_i = x_{1i}/x_{2i}\]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), three( 100,3), result(100);</div>
<div class="line"><a class="code hl_function" href="#gaed1b7322791a0ac7ec25b9abe1608a02">dg::blas1::pointwiseDivide</a>( two,  three, result );</div>
<div class="line">CHECK( result == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, 2./3.));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 may alias x1 </td></tr>
    <tr><td class="paramname">y</td><td>(write-only) ContainerType y contains result on output ( may alias x1 and/or x2)  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="gaed1b7322791a0ac7ec25b9abe1608a02" name="gaed1b7322791a0ac7ec25b9abe1608a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed1b7322791a0ac7ec25b9abe1608a02">&#9670;&#160;</a></span>pointwiseDivide() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDivide </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type1</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x_1/ x_2 + \beta y \) </p>
<p>Divides two vectors element by element: </p><p class="formulaDsp">
\[ y_i = \alpha x_{1i}/x_{2i} + \beta y_i \]
</p>
<p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), three( 100,3), result(100,1);</div>
<div class="line"><a class="code hl_function" href="#gaed1b7322791a0ac7ec25b9abe1608a02">dg::blas1::pointwiseDivide</a>( 3, two,  three, 5, result );</div>
<div class="line">CHECK( result == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, 7.)); <span class="comment">// 3*2/3+5*1</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 may alias x1 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">y</td><td>(read/write) ContainerType y contains result on output ( may alias x1 and/or x2)  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>Any type that can be used in an arithmetic operation with <code><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type&lt;ContainerType&gt;</a></code>    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga117cb07cd3e8b6a8580bb42a9c00ab40" name="ga117cb07cd3e8b6a8580bb42a9c00ab40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga117cb07cd3e8b6a8580bb42a9c00ab40">&#9670;&#160;</a></span>pointwiseDot() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = x_1 x_2 \) </p>
<p>Multiplies two vectors element by element: </p><p class="formulaDsp">
\[ y_i = x_{1i}x_{2i}\]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), three( 100,3), result(100);</div>
<div class="line"><a class="code hl_function" href="#ga3d3fcab87e4c6df59ba719cf085ba2ad">dg::blas1::pointwiseDot</a>( two,  three, result );</div>
<div class="line">CHECK( result == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, 6.)); <span class="comment">// 2*3</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 may alias x1 </td></tr>
    <tr><td class="paramname">y</td><td>(write-only) ContainerType y contains result on output ( may alias x1 or x2)  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="ga30bed3d80b7a8ef52d6ff8f82c5b6daf" name="ga30bed3d80b7a8ef52d6ff8f82c5b6daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30bed3d80b7a8ef52d6ff8f82c5b6daf">&#9670;&#160;</a></span>pointwiseDot() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class ContainerType3 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType3 &amp;</td>          <td class="paramname"><span class="paramname"><em>x3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type1</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x_1 x_2 x_3 + \beta y\) </p>
<p>Multiplies three vectors element by element: </p><p class="formulaDsp">
\[ y_i = \alpha x_{1i}x_{2i}x_{3i} + \beta y_i\]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), three( 100,3), four(100,4), result(100,6);</div>
<div class="line"><a class="code hl_function" href="#ga3d3fcab87e4c6df59ba719cf085ba2ad">dg::blas1::pointwiseDot</a>(2., two,  three, four, -4., result );</div>
<div class="line">CHECK( result == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, 24.)); <span class="comment">// 2*2*3*4-4*6</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 may alias x1 </td></tr>
    <tr><td class="paramname">x3</td><td>ContainerType x3 may alias x1 and/or x2 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">y</td><td>(read/write) ContainerType y contains result on output ( may alias x1,x2 or x3)  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>Any type that can be used in an arithmetic operation with <code><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type&lt;ContainerType&gt;</a></code>    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3d3fcab87e4c6df59ba719cf085ba2ad" name="ga3d3fcab87e4c6df59ba719cf085ba2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d3fcab87e4c6df59ba719cf085ba2ad">&#9670;&#160;</a></span>pointwiseDot() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type1</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha x_1 x_2 + \beta y\) </p>
<p>Multiplies two vectors element by element: </p><p class="formulaDsp">
\[ y_i = \alpha x_{1i}x_{2i} + \beta y_i\]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), three( 100,3), result(100,6);</div>
<div class="line"><a class="code hl_function" href="#ga3d3fcab87e4c6df59ba719cf085ba2ad">dg::blas1::pointwiseDot</a>(2., two,  three, -4., result );</div>
<div class="line">CHECK( result == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, -12.)); <span class="comment">// 2*2*3-4*6</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 may alias x1 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">y</td><td>(read/write) ContainerType y contains result on output ( may alias x1 or x2)  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>Any type that can be used in an arithmetic operation with <code><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type&lt;ContainerType&gt;</a></code>    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1332b3d86bc6e48b44a48d04c4da43b" name="gab1332b3d86bc6e48b44a48d04c4da43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1332b3d86bc6e48b44a48d04c4da43b">&#9670;&#160;</a></span>pointwiseDot() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class ContainerType2 , class ContainerType3 , class ContainerType4 , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> , class value_type1 , class value_type2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::pointwiseDot </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type1</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType3 &amp;</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType4 &amp;</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type2</td>          <td class="paramname"><span class="paramname"><em>gamma</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>\( z = \alpha x_1y_1 + \beta x_2y_2 + \gamma z\) </p>
<p>Multiplies and adds vectors element by element: </p><p class="formulaDsp">
\[ z_i = \alpha x_{1i}y_{1i} + \beta x_{2i}y_{2i} + \gamma z_i \]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two(100,2), three(100,3), four(100,4), five(100,5), result(100,6);</div>
<div class="line"><a class="code hl_function" href="#ga3d3fcab87e4c6df59ba719cf085ba2ad">dg::blas1::pointwiseDot</a>(2., two,  three, -4., four, five, 2., result );</div>
<div class="line">CHECK( result == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, -56.)); <span class="comment">// 2*2*3-4*4*5+2*6</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scalar </td></tr>
    <tr><td class="paramname">x1</td><td>ContainerType x1 </td></tr>
    <tr><td class="paramname">y1</td><td>ContainerType y1 </td></tr>
    <tr><td class="paramname">beta</td><td>scalar </td></tr>
    <tr><td class="paramname">x2</td><td>ContainerType x2 </td></tr>
    <tr><td class="paramname">y2</td><td>ContainerType y2 </td></tr>
    <tr><td class="paramname">gamma</td><td>scalar </td></tr>
    <tr><td class="paramname">z</td><td>(read/write) ContainerType z contains result on output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>all aliases are allowed  </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>Any type that can be used in an arithmetic operation with <code><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type&lt;ContainerType&gt;</a></code>    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga61cf5da3d6fd6325cb24522b7ac8a037" name="ga61cf5da3d6fd6325cb24522b7ac8a037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61cf5da3d6fd6325cb24522b7ac8a037">&#9670;&#160;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class OutputType , class BinaryOp , class UnaryOp  = IDENTITY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputType dg::blas1::reduce </td>
          <td>(</td>
          <td class="paramtype">const ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType</td>          <td class="paramname"><span class="paramname"><em>zero</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp</td>          <td class="paramname"><span class="paramname"><em>binary_op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOp</td>          <td class="paramname"><span class="paramname"><em>unary_op</em></span><span class="paramdefsep"> = </span><span class="paramdefval">UnaryOp()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( f(x_0) \otimes f(x_1) \otimes \dots \otimes f(x_{N-1}) \) Custom (transform) reduction </p>
<p>This routine computes </p><p class="formulaDsp">
\[ s = f(x_0) \otimes f(x_1) \otimes \dots \otimes f(x_i) \otimes \dots \otimes f(x_{N-1}) \]
</p>
<p> where \( \otimes \) is an arbitrary <b>commutative</b> and <b>associative</b> binary operator, \( f\) is an optional unary operator and  </p>
<p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<dl class="section note"><dt>Note</dt><dd>numerical addition/multiplication is <b>not</b> exactly associative which means that the associated reduction looses precision due to inexact arithmetic. For binary reproducible exactly rounded results use the <a class="el" href="#gaaab22d8f057bb35466d2bfcfddf1cf4d" title="Binary reproducible Euclidean dot product between two vectors">dg::blas1::dot</a> function. However, this function is more general and faster to execute than <a class="el" href="#gaaab22d8f057bb35466d2bfcfddf1cf4d" title="Binary reproducible Euclidean dot product between two vectors">dg::blas1::dot</a>.</dd></dl>
<p>For example </p><div class="fragment"><div class="line"><span class="comment">//Check if a vector contains Inf or NaN</span></div>
<div class="line">thrust::device_vector&lt;double&gt; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( 100, NAN );</div>
<div class="line"><span class="keywordtype">bool</span> hasnan = <span class="keyword">false</span>;</div>
<div class="line">hasnan = <a class="code hl_function" href="#ga61cf5da3d6fd6325cb24522b7ac8a037">dg::blas1::reduce</a>( x, <span class="keyword">false</span>, thrust::logical_or&lt;bool&gt;(),</div>
<div class="line">    <a class="code hl_struct" href="structdg_1_1_i_s_n_f_i_n_i_t_e.html">dg::ISNFINITE&lt;double&gt;</a>());</div>
<div class="line">CHECK( hasnan == <span class="keyword">true</span>);</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="comment">// Find minimum and maximum of a vector</span></div>
<div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">int</span> u=0; u&lt;100; u++)</div>
<div class="line">    x[u] = (<span class="keywordtype">double</span>)(u-10)*(u-10);</div>
<div class="line"><span class="comment">// Notice the zero elements of the min and max functions</span></div>
<div class="line"><span class="keywordtype">double</span> min = <a class="code hl_function" href="#ga61cf5da3d6fd6325cb24522b7ac8a037">dg::blas1::reduce</a>( x, +1e308, thrust::minimum&lt;double&gt;());</div>
<div class="line"><span class="keywordtype">double</span> max = <a class="code hl_function" href="#ga61cf5da3d6fd6325cb24522b7ac8a037">dg::blas1::reduce</a>( x, -1e308, thrust::maximum&lt;double&gt;());</div>
<div class="line">CHECK( min == 0);</div>
<div class="line">CHECK( max == 89*89);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container to reduce </td></tr>
    <tr><td class="paramname">zero</td><td>The neutral element with respect to binary_op that is <code> x == binary_op( zero, x) </code>. Determines the <code>OutputType</code> so make sure to make the type clear to the compiler (e.g. write <code> (double)0 </code> instead of <code>0</code> if you want <code>double</code> output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>In the current implementation <code>zero</code> is used to initialize partial sums e.g. when reducing MPI Vectors so it is important that <code>zero</code> is actually the neutral element. The reduction will yield wrong results if it is not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary_op</td><td>an associative and commutative binary operator </td></tr>
    <tr><td class="paramname">unary_op</td><td>a unary operator applies to each element of <code>x</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Custom reduction as defined above </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is always executed synchronously due to the implicit memcpy of the result. With mpi the result is broadcasted to all processes </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryOp</td><td>Functor with signature: <code> value_type operator()(
value_type, value_type) </code>, must be associative and commutative. <code>value_tpye</code> must be compatible with <code>OutputType</code> </td></tr>
    <tr><td class="paramname">UnaryOp</td><td>a unary operator. The argument type must be compatible with <code>get_value_type&lt;ContainerType&gt;</code>. The return type must be convertible to <code>OutputType</code> </td></tr>
    <tr><td class="paramname">OutputType</td><td>The type of the result. Infered from <code>zero</code> so make sure <code>zero's</code> type is clear to the compiler.  </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd>
<dd>
For partial reductions see <code><a class="el" href="structdg_1_1_average.html" title="Topological average computations in a Cartesian topology.">dg::Average</a></code> </dd></dl>

</div>
</div>
<a id="gac4e67d4aa98cc3b8601903570828e415" name="gac4e67d4aa98cc3b8601903570828e415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4e67d4aa98cc3b8601903570828e415">&#9670;&#160;</a></span>scal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class <a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::scal </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">value_type</a></td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x = \alpha x\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ \alpha x_i \]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2);</div>
<div class="line"><a class="code hl_function" href="#gac4e67d4aa98cc3b8601903570828e415">dg::blas1::scal</a>( two, 0.5);</div>
<div class="line">CHECK( two == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, 1));</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) x  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>Any type that can be used in an arithmetic operation with <code><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type&lt;ContainerType&gt;</a></code>    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7386b5cb0144d5364b8ea8c8ce1482a5" name="ga7386b5cb0144d5364b8ea8c8ce1482a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7386b5cb0144d5364b8ea8c8ce1482a5">&#9670;&#160;</a></span>subroutine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Subroutine , class ContainerType , class ... ContainerTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::subroutine </td>
          <td>(</td>
          <td class="paramtype">Subroutine</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerTypes &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>xs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( f(x_0, x_1, ...)\); Customizable and generic <a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a> function </p>
<p>This routine evaluates an arbitrary user-defined subroutine <code>f</code> with an arbitrary number of arguments \( x_s\) elementwise </p><p class="formulaDsp">
\[ f(x_{0i}, x_{1i}, ...)  \]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), four(100,4);</div>
<div class="line"><a class="code hl_function" href="#ga7386b5cb0144d5364b8ea8c8ce1482a5">dg::blas1::subroutine</a>( []<a class="code hl_define" href="group__typedefs.html#gaa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>( <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span>&amp; z){</div>
<div class="line">    <a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a> = 7*<a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a> + <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a> +<a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>;</div>
<div class="line">}, two, 3., four);</div>
<div class="line">CHECK( four == <a class="code hl_typedef" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef">dg::HVec</a>( 100, 21.)); <span class="comment">// 7*2+3+4</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the subroutine, see <a class="el" href="group__variadic__subroutines.html">dg::blas1::subroutine subroutines</a> for a collection of predefind subroutines to use here </td></tr>
    <tr><td class="paramname">x</td><td>the first argument </td></tr>
    <tr><td class="paramname">xs</td><td>other arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can compute <b>any</b> trivial parallel expression for <b>any</b> number of input and output arguments, which is quite remarkable really. In this sense it replaces all other <code><a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a></code> functions except the scalar product, which is not trivially parallel. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The user has to decide whether or not it is safe to alias input or output vectors. If in doubt, do not alias output vectors. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Subroutine</td><td>a function or functor with an arbitrary number of arguments and no return type; taking a <code>value_type</code> argument for each input argument in the call and a <code> value_type&amp; </code> argument for each output argument. <code>Subroutine</code> must be callable on the device in use. In particular, with CUDA it must be a functor (<b>not</b> a function) and its signature must contain the __device__ specifier. (s.a. <a class="el" href="group__typedefs.html#gaa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>)  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="ga493c6b70c8c889beaec1c3a669e3809b" name="ga493c6b70c8c889beaec1c3a669e3809b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga493c6b70c8c889beaec1c3a669e3809b">&#9670;&#160;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType , class ContainerType1 , class UnaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas1::transform </td>
          <td>(</td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = op(x)\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ y_i = op(x_i) \]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), result(100);</div>
<div class="line"><a class="code hl_function" href="#ga493c6b70c8c889beaec1c3a669e3809b">dg::blas1::transform</a>( two, result, <a class="code hl_struct" href="structdg_1_1_e_x_p.html">dg::EXP&lt;double&gt;</a>());</div>
<div class="line">CHECK( result == <a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a>( 100, exp(2.)));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>ContainerType x may alias y </td></tr>
    <tr><td class="paramname">y</td><td>(write-only) ContainerType y contains result, may alias x </td></tr>
    <tr><td class="paramname">op</td><td>unary SquareMatrix to use on every element </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryOp</td><td>Functor with signature: <code> value_type operator()( value_type) </code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>UnaryOp</code> must be callable on the device in use. In particular, with CUDA it must be of functor tpye (<b>not</b> a function) and its signatures must contain the __device__ specifier. (s.a. <a class="el" href="group__typedefs.html#gaa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>)  </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>only result vectors that are <b>write-only</b> and do not alias input vectors contain correct results when the result vector contains NaN or Inf on input. In particular, <code>dg::blas1::scal( y, 0 )</code> does not remove NaN or Inf from y while <code>dg::blas1::copy( 0, y )</code> does.     </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="ga46d63d18eddaa34b72ea3f197f7d51fb" name="ga46d63d18eddaa34b72ea3f197f7d51fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46d63d18eddaa34b72ea3f197f7d51fb">&#9670;&#160;</a></span>vdot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor , class ContainerType , class ... ContainerTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto dg::blas1::vdot </td>
          <td>(</td>
          <td class="paramtype">Functor</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerTypes &amp;...</td>          <td class="paramname"><span class="paramname"><em>xs</em></span>&#160;) -&gt; std::invoke_result_t&lt;Functor, <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type</a>&lt;ContainerType&gt;, <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type</a>&lt;ContainerTypes&gt;...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>\( \sum_i f(x_{0i}, x_{1i}, ...)\) Extended Precision transform reduce </p>
<p>This routine computes </p><p class="formulaDsp">
\[ \sum_i f(x_{0i}, x_{1i}, ...)\]
</p>
  <p>where <code>i</code> iterates over <b>all</b> elements inside the given vectors. The order of iterations is undefined. Scalar arguments to container types are interpreted as vectors with all elements constant. If <code>ContainerType</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, <code>i</code> recursively loops over all entries. If the vector sizes do not match, the result is undefined. The compiler chooses the implementation and parallelization of this function based on given template parameters. For a full set of rules please refer to <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a>.   </p>
<p>For example </p><div class="fragment"><div class="line"><span class="comment">// A fun way to compute the size of a vector</span></div>
<div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> v( 100,2);</div>
<div class="line"><span class="keywordtype">unsigned</span> size = <a class="code hl_function" href="#ga46d63d18eddaa34b72ea3f197f7d51fb">dg::blas1::vdot</a>( []<a class="code hl_define" href="group__typedefs.html#gaa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>(<span class="keywordtype">double</span>){ <span class="keywordflow">return</span> 1u;},</div>
<div class="line">        v);</div>
<div class="line">CHECK( size == 100u); <span class="comment">//100*1</span></div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="comment">// Compute the weighted norm of a complex vector</span></div>
<div class="line">std::vector&lt;double&gt; ww( 100, 42.);</div>
<div class="line">std::vector&lt;std::complex&lt;double&gt;&gt; cc( 100, {1,1});</div>
<div class="line"><span class="comment">// Use auto to allow changing std::complex to thrust::complex</span></div>
<div class="line"><span class="comment">// Use norm instead of std::norm and let ADL work</span></div>
<div class="line"><span class="keywordtype">double</span> nrm = <a class="code hl_function" href="#ga46d63d18eddaa34b72ea3f197f7d51fb">dg::blas1::vdot</a>([](<span class="keywordtype">double</span> w, <span class="keyword">auto</span> z){ <span class="keywordflow">return</span> w*norm(z);},</div>
<div class="line">    ww, cc);</div>
<div class="line">CHECK( nrm == 100*42*2.0);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The main motivator for this version of <code>dot</code> is that it works for complex numbers. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>if one of the input vectors contains <code>Inf</code> or <code>NaN</code> or the product of the input numbers reaches <code>Inf</code> or <code>Nan</code> then the behaviour is undefined and the function may throw. See <a class="el" href="structdg_1_1_i_s_n_f_i_n_i_t_e.html">dg::ISNFINITE</a> and <a class="el" href="structdg_1_1_i_s_n_s_a_n_e.html">dg::ISNSANE</a> in that case </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This implementation does <b>not guarantee binary reproducible</b> results. The sum is computed with <b>extended precision</b> and the result is rounded to the nearest double precision number. This is possible with the help of an adapted version of the <code><a class="elRef" href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></code> library and works for single and double precision.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>signature: <code> value_type_g operator()( value_type_x0, value_type_x1, ...) </code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><code>Functor</code> must be callable on the device in use. In particular, with CUDA it must be a functor tpye (<b>not</b> function) and its signatures must contain the __device__ specifier. (s.a. <a class="el" href="group__typedefs.html#gaa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The functor to evaluate, see <a class="el" href="group__functions.html">A large collection</a> and <a class="el" href="group__variadic__evaluates.html">dg::blas1::evaluate variadic functors</a> for a collection of predefined functors to use here </td></tr>
    <tr><td class="paramname">x</td><td>First input </td></tr>
    <tr><td class="paramname">xs</td><td>More input (may alias x) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar product as defined above </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is always executed synchronously due to the implicit memcpy of the result. With mpi the result is broadcasted to all processes.  </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:30 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
