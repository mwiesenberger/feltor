<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: dg::MPIKroneckerGather&lt; Vector &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structdg_1_1_m_p_i_kronecker_gather.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structdg_1_1_m_p_i_kronecker_gather-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::MPIKroneckerGather&lt; Vector &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__level1.html">Level 1: Vectors, Matrices and basic operations</a> &raquo; <a class="el" href="group__mpi__structures.html">MPI backend</a> &raquo; <a class="el" href="group__mpi__comm.html">MPI Distributed Gather and Scatter</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Communicator for asynchronous communication of <code><a class="el" href="structdg_1_1_m_p_i_sparse_block_mat.html" title="Distributed memory Sparse block matrix class, asynchronous communication.">MPISparseBlockMat</a></code>.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9568f187e6ecfaf6e6c520558d6df750" id="r_a9568f187e6ecfaf6e6c520558d6df750"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9568f187e6ecfaf6e6c520558d6df750">MPIKroneckerGather</a> (MPI_Comm comm=MPI_COMM_NULL)</td></tr>
<tr class="memdesc:a9568f187e6ecfaf6e6c520558d6df750"><td class="mdescLeft">&#160;</td><td class="mdescRight">no communication     <br /></td></tr>
<tr class="separator:a9568f187e6ecfaf6e6c520558d6df750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac7276bf852057b4a6777ed6c8886c7" id="r_a5ac7276bf852057b4a6777ed6c8886c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ac7276bf852057b4a6777ed6c8886c7">MPIKroneckerGather</a> (unsigned left_size, const std::map&lt; int, thrust::host_vector&lt; int &gt; &gt; &amp;recvIdx, unsigned <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#afd53743d1af6bfa2856255b23b5a41a9">n</a>, unsigned num_cols, unsigned right_size, MPI_Comm comm_1d)</td></tr>
<tr class="memdesc:a5ac7276bf852057b4a6777ed6c8886c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from communication pattern.  <br /></td></tr>
<tr class="separator:a5ac7276bf852057b4a6777ed6c8886c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd5d02140e15bcbc3669e6d8122864c" id="r_a6fd5d02140e15bcbc3669e6d8122864c"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; typename OtherVector&gt; </td></tr>
<tr class="memitem:a6fd5d02140e15bcbc3669e6d8122864c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6fd5d02140e15bcbc3669e6d8122864c">MPIKroneckerGather</a> (const <a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">MPIKroneckerGather</a>&lt; OtherVector &gt; &amp;src)</td></tr>
<tr class="memdesc:a6fd5d02140e15bcbc3669e6d8122864c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from other execution policy.     <br /></td></tr>
<tr class="separator:a6fd5d02140e15bcbc3669e6d8122864c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329c8730aaffa68ac8df2871d6f2dfce" id="r_a329c8730aaffa68ac8df2871d6f2dfce"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a329c8730aaffa68ac8df2871d6f2dfce">communicator</a> () const</td></tr>
<tr class="memdesc:a329c8730aaffa68ac8df2871d6f2dfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal MPI communicator used.     <br /></td></tr>
<tr class="separator:a329c8730aaffa68ac8df2871d6f2dfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1387c22f96f13011188faf6f569726a" id="r_ab1387c22f96f13011188faf6f569726a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1387c22f96f13011188faf6f569726a">buffer_size</a> () const</td></tr>
<tr class="memdesc:ab1387c22f96f13011188faf6f569726a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of pointers in receive buffer equals number of indices in <code>recvIdx</code>.  <br /></td></tr>
<tr class="separator:ab1387c22f96f13011188faf6f569726a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812df286b978fc4c2de02c1cee14e7d5" id="r_a812df286b978fc4c2de02c1cee14e7d5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a812df286b978fc4c2de02c1cee14e7d5">chunk_size</a> () const</td></tr>
<tr class="memdesc:a812df286b978fc4c2de02c1cee14e7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>n*left_size*right_size</code>  <br /></td></tr>
<tr class="separator:a812df286b978fc4c2de02c1cee14e7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7deca2c95fbb4b11a3065316586044" id="r_a0d7deca2c95fbb4b11a3065316586044"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d7deca2c95fbb4b11a3065316586044">isCommunicating</a> () const</td></tr>
<tr class="memdesc:a0d7deca2c95fbb4b11a3065316586044"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the gather/scatter operation involves actual MPI communication.     <br /></td></tr>
<tr class="separator:a0d7deca2c95fbb4b11a3065316586044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a411a3c697c410dc0c38d8c9fa0b6d" id="r_a05a411a3c697c410dc0c38d8c9fa0b6d"><td class="memTemplParams" colspan="2">template&lt;class ContainerType &gt; </td></tr>
<tr class="memitem:a05a411a3c697c410dc0c38d8c9fa0b6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05a411a3c697c410dc0c38d8c9fa0b6d">global_gather_init</a> (const ContainerType &amp;gatherFrom) const</td></tr>
<tr class="memdesc:a05a411a3c697c410dc0c38d8c9fa0b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( w&#39; = P_{G,MPI} G_2 v\). Globally (across processes) asynchronously gather data into a buffer  <br /></td></tr>
<tr class="separator:a05a411a3c697c410dc0c38d8c9fa0b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac5ff6f0d21c15bc8d23aacecd15431" id="r_a3ac5ff6f0d21c15bc8d23aacecd15431"><td class="memTemplParams" colspan="2">template&lt;class ContainerType &gt; </td></tr>
<tr class="memitem:a3ac5ff6f0d21c15bc8d23aacecd15431"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ac5ff6f0d21c15bc8d23aacecd15431">global_gather_wait</a> (const ContainerType &amp;gatherFrom, Vector&lt; const <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type</a>&lt; ContainerType &gt; * &gt; &amp;buffer_ptrs) const</td></tr>
<tr class="memdesc:a3ac5ff6f0d21c15bc8d23aacecd15431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for asynchronous communication to finish and gather received data into buffer and return pointers to it.  <br /></td></tr>
<tr class="separator:a3ac5ff6f0d21c15bc8d23aacecd15431"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9d2579147db2d622138ab763a718ba36" id="r_a9d2579147db2d622138ab763a718ba36"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class OtherVector&gt; </td></tr>
<tr class="memitem:a9d2579147db2d622138ab763a718ba36"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d2579147db2d622138ab763a718ba36">MPIKroneckerGather</a></td></tr>
<tr class="memdesc:a9d2579147db2d622138ab763a718ba36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable copy from different Vector type.  <br /></td></tr>
<tr class="separator:a9d2579147db2d622138ab763a718ba36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;template&lt; typename &gt; typename Vector&gt;<br />
struct dg::MPIKroneckerGather&lt; Vector &gt;</div><p>Communicator for asynchronous communication of <code><a class="el" href="structdg_1_1_m_p_i_sparse_block_mat.html" title="Distributed memory Sparse block matrix class, asynchronous communication.">MPISparseBlockMat</a></code>. </p>
<p>This is a version of <code><a class="el" href="structdg_1_1_m_p_i_gather.html" title="Optimized MPI Gather operation.">MPIGather</a></code> that is optimised for the Kronecker type communication pattern ("Hyperblocks") present in our <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">EllSparseBlockMat</a></code> It avoids data movement to the greatest possible extent and exposes send and receive buffers via pointers.</p>
<p>Imagine a communicator with Cartesian topology and further imagine that the grid topology is also Cartesian (vectors form a box) in Nd dimensions. A Sparseblockmat typically requires to gather slices of given index from other processes in a 1d communicator. This class provides pointers to these other indices. The pointers either reference data in an internal communication buffer (since it involves communciation to get the layers from neighboring processes) another buffer (if mpi communication requires to reorder input data) or the input vector itself (if the communication goes along the last dimension there is no need to reorder, in fact, here is the main gain we get from the pointer approach, we save on unnecessary data copies, which might be significant in cases where the communication to computation ratio is high). The size of the data each pointer references is the halo size, <code><a class="el" href="#ab1387c22f96f13011188faf6f569726a" title="Number of pointers in receive buffer equals number of indices in recvIdx.">buffer_size()</a></code> </p>
<p>The communication is done asynchronously i.e. the user can initiate the communication and signal when the results are needed at a later stage.</p>
<dl class="section note"><dt>Note</dt><dd>If the number of neighboring processes in the given direction is 1, the buffer size is 0 and all members return immediately. </dd>
<dd>
the pointers may alias each other (if the input contains less than 4 layers)</dd>
<dd>
the corresponding gather map is of general type and the communication can also be modeled in <code><a class="el" href="structdg_1_1_m_p_i_gather.html" title="Optimized MPI Gather operation.">MPIGather</a></code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>a thrust Vector e.g. <code>thrust::host_vector</code> or <code>thrust::device_vector</code> Determines the internal buffer type of the \( G_2\) gather operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>dg::RowColDistMat </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9568f187e6ecfaf6e6c520558d6df750" name="a9568f187e6ecfaf6e6c520558d6df750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9568f187e6ecfaf6e6c520558d6df750">&#9670;&#160;</a></span>MPIKroneckerGather() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">dg::MPIKroneckerGather</a>&lt; Vector &gt;::MPIKroneckerGather </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">MPI_COMM_NULL</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>no communication    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>optional MPI communicator: the purpose is to be able to store MPI communicator even if no communication is involved in order to construct <a class="el" href="structdg_1_1_m_p_i___vector.html" title="A simple wrapper around a container object and an MPI_Comm.">MPI_Vector</a> with it    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ac7276bf852057b4a6777ed6c8886c7" name="a5ac7276bf852057b4a6777ed6c8886c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac7276bf852057b4a6777ed6c8886c7">&#9670;&#160;</a></span>MPIKroneckerGather() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">dg::MPIKroneckerGather</a>&lt; Vector &gt;::MPIKroneckerGather </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>left_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, thrust::host_vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>recvIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>num_cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>right_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm_1d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from communication pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_size</td><td>(local) left size in <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">EllSparseBlockMat</a></code> (determines chunk size) </td></tr>
    <tr><td class="paramname">recvIdx</td><td>1d block index in units of chunk size. <code>recvIdx[PID]</code> contains the block indices on rank PID (in <code>comm_1d</code>) that the calling rank receives. The <code>global_gather_wait</code> function returns one pointer for each element of <code>recvIdx</code> pointing to a block of memory of size <code>chunk_size=n*left_size*right_size</code>. </td></tr>
    <tr><td class="paramname">n</td><td>block size of <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">EllSparseBlockMat</a></code> (determines chunk size) </td></tr>
    <tr><td class="paramname">num_cols</td><td>local number of blocks columns in <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">EllSparseBlockMat</a></code> </td></tr>
    <tr><td class="paramname">right_size</td><td>(local) right size of <code><a class="el" href="structdg_1_1_ell_sparse_block_mat.html" title="Ell Sparse Block Matrix format.">EllSparseBlockMat</a></code> (determines chunk size) </td></tr>
    <tr><td class="paramname">comm_1d</td><td>the one dimensional Cartesian communicator along which to exchange the hyperblocks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>not all participating pids need to have the same number of hyperblocks or have the same shape even though left_size, n, num_cols, and right_size must be equal between any two communicating pids </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__mpi__matvec.html#ga5bae2f49640615237a95bc7e50d42231" title="Split given EllSparseBlockMat into computation and communication part.">dg::make_mpi_sparseblockmat</a></code> </dd></dl>

</div>
</div>
<a id="a6fd5d02140e15bcbc3669e6d8122864c" name="a6fd5d02140e15bcbc3669e6d8122864c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd5d02140e15bcbc3669e6d8122864c">&#9670;&#160;</a></span>MPIKroneckerGather() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Vector&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename OtherVector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">dg::MPIKroneckerGather</a>&lt; Vector &gt;::MPIKroneckerGather </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">MPIKroneckerGather</a>&lt; OtherVector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from other execution policy.    </p>
<p>This makes it possible to construct an object on the host and then copy everything on to a device </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherVector</td><td>other container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source object    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab1387c22f96f13011188faf6f569726a" name="ab1387c22f96f13011188faf6f569726a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1387c22f96f13011188faf6f569726a">&#9670;&#160;</a></span>buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">dg::MPIKroneckerGather</a>&lt; Vector &gt;::buffer_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of pointers in receive buffer equals number of indices in <code>recvIdx</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer size (may be different for each process) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>may return 0, which just means that the calling rank does not receive any data from any other rank including itself. The calling rank may still need to <b>send</b> data in <code>global_gather_init</code> </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>It is therfore not valid to check for zero buffer size if you want to find out whether a given rank needs to send MPI messages or not. The right way to do it is to call <code><a class="el" href="#a0d7deca2c95fbb4b11a3065316586044" title="True if the gather/scatter operation involves actual MPI communication.">isCommunicating()</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0d7deca2c95fbb4b11a3065316586044" title="True if the gather/scatter operation involves actual MPI communication.">isCommunicating()</a>    </dd></dl>

</div>
</div>
<a id="a812df286b978fc4c2de02c1cee14e7d5" name="a812df286b978fc4c2de02c1cee14e7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812df286b978fc4c2de02c1cee14e7d5">&#9670;&#160;</a></span>chunk_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">dg::MPIKroneckerGather</a>&lt; Vector &gt;::chunk_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>n*left_size*right_size</code> </p>

</div>
</div>
<a id="a329c8730aaffa68ac8df2871d6f2dfce" name="a329c8730aaffa68ac8df2871d6f2dfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329c8730aaffa68ac8df2871d6f2dfce">&#9670;&#160;</a></span>communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm <a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">dg::MPIKroneckerGather</a>&lt; Vector &gt;::communicator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal MPI communicator used.    </p>
<dl class="section return"><dt>Returns</dt><dd>MPI Communicator    </dd></dl>

</div>
</div>
<a id="a05a411a3c697c410dc0c38d8c9fa0b6d" name="a05a411a3c697c410dc0c38d8c9fa0b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a411a3c697c410dc0c38d8c9fa0b6d">&#9670;&#160;</a></span>global_gather_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Vector&gt; </div>
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">dg::MPIKroneckerGather</a>&lt; Vector &gt;::global_gather_init </td>
          <td>(</td>
          <td class="paramtype">const ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>gatherFrom</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( w&#39; = P_{G,MPI} G_2 v\). Globally (across processes) asynchronously gather data into a buffer </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Can be any shared vector container on host or device, e.g.<ul>
<li>thrust::host_vector&lt;double&gt;</li>
<li>thrust::device_vector&lt;double&gt;</li>
<li>thrust::device_vector&lt;thrust::complex&lt;double&gt;&gt;</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gatherFrom</td><td>source vector v; data is collected from this vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code> !isCommunicating() </code> then this call will not involve MPI communication but will still gather values according to the given index map </dd></dl>

</div>
</div>
<a id="a3ac5ff6f0d21c15bc8d23aacecd15431" name="a3ac5ff6f0d21c15bc8d23aacecd15431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac5ff6f0d21c15bc8d23aacecd15431">&#9670;&#160;</a></span>global_gather_wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Vector&gt; </div>
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">dg::MPIKroneckerGather</a>&lt; Vector &gt;::global_gather_wait </td>
          <td>(</td>
          <td class="paramtype">const ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>gatherFrom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; const <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type</a>&lt; ContainerType &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer_ptrs</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for asynchronous communication to finish and gather received data into buffer and return pointers to it. </p>
<p>Call <code>MPI_Waitall</code> on internal <code>MPI_Request</code> variables and manage host memory in case of cuda-unaware MPI. After this call returns it is safe to use the buffer and the <code>gatherFrom</code> variable from the corresponding <code>global_gather_init</code> call </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gatherFrom</td><td>source vector v; data is collected from this vector </td></tr>
    <tr><td class="paramname">buffer_ptrs</td><td>(write only) pointers coresponding to <code>recvIdx</code> from the constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d7deca2c95fbb4b11a3065316586044" name="a0d7deca2c95fbb4b11a3065316586044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7deca2c95fbb4b11a3065316586044">&#9670;&#160;</a></span>isCommunicating()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">dg::MPIKroneckerGather</a>&lt; Vector &gt;::isCommunicating </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the gather/scatter operation involves actual MPI communication.    </p>
<p>This is more than just a test for zero message size. This is because even if a process has zero message size indicating that it technically does not need to send any data at all it might still need to participate in an MPI communication (sending an empty message to indicate that a certain point in execution has been reached). Only if <b>none</b> of the processes in the process group has anything to send will this function return false. This test can be used to avoid the gather operation alltogether in e.g. the construction of a MPI distributed matrix. </p><dl class="section note"><dt>Note</dt><dd>this check involves MPI communication itself, because a process needs to check if itself or any other process in its group is communicating.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>False, if the global gather can be done without MPI communication (i.e. the indices are all local to each calling process), or if the communicator is <code>MPI_COMM_NULL</code>. True else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab1387c22f96f13011188faf6f569726a" title="Number of pointers in receive buffer equals number of indices in recvIdx.">buffer_size()</a>    </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a9d2579147db2d622138ab763a718ba36" name="a9d2579147db2d622138ab763a718ba36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2579147db2d622138ab763a718ba36">&#9670;&#160;</a></span>MPIKroneckerGather</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename Vector&gt; </div>
<div class="memtemplate">
template&lt;template&lt; class &gt; class OtherVector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">MPIKroneckerGather</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable copy from different Vector type. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>backend/<a class="el" href="mpi__gather__kron_8h_source.html">mpi_gather_kron.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_m_p_i_kronecker_gather.html">MPIKroneckerGather</a></li>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:30 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
