<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: dg::SparseMatrix&lt; Index, Value, Vector &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structdg_1_1_sparse_matrix.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structdg_1_1_sparse_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::SparseMatrix&lt; Index, Value, Vector &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__level1.html">Level 1: Vectors, Matrices and basic operations</a> &raquo; <a class="el" href="group__utility.html">Utility</a> &raquo; <a class="el" href="group__sparsematrix.html">Sparse matrix formats</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A CSR formatted sparse matrix.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a59eee29cdfee7a957b2ba1ba826f1557" id="r_a59eee29cdfee7a957b2ba1ba826f1557"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59eee29cdfee7a957b2ba1ba826f1557">policy</a> = <a class="el" href="group__dispatch.html#gac20006d24fe8a0049cc50a94f53aa26c">dg::get_execution_policy</a>&lt;Vector&lt;Value&gt;&gt;</td></tr>
<tr class="memdesc:a59eee29cdfee7a957b2ba1ba826f1557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution policy of the matrix.  <br /></td></tr>
<tr class="separator:a59eee29cdfee7a957b2ba1ba826f1557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549d1327798f5dab79a3e109001bcfb1" id="r_a549d1327798f5dab79a3e109001bcfb1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a549d1327798f5dab79a3e109001bcfb1">index_type</a> = Index</td></tr>
<tr class="memdesc:a549d1327798f5dab79a3e109001bcfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type (on GPU must be either <code>int</code> or <code>long</code>)  <br /></td></tr>
<tr class="separator:a549d1327798f5dab79a3e109001bcfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac1a38822f90200316c633cfdbcd063" id="r_abac1a38822f90200316c633cfdbcd063"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abac1a38822f90200316c633cfdbcd063">value_type</a> = Value</td></tr>
<tr class="memdesc:abac1a38822f90200316c633cfdbcd063"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type (on GPU must be either <code>float</code> or <code>double</code>)  <br /></td></tr>
<tr class="separator:abac1a38822f90200316c633cfdbcd063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd533abdb16d21402c2b6c7df83cf631" id="r_acd533abdb16d21402c2b6c7df83cf631"><td class="memTemplParams" colspan="2">template&lt;class OtherMatrix &gt; </td></tr>
<tr class="memitem:acd533abdb16d21402c2b6c7df83cf631"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a> = std::enable_if_t&lt;std::is_same_v&lt;typename OtherMatrix::policy, <a class="el" href="structdg_1_1_serial_tag.html">SerialTag</a>&gt;, OtherMatrix&gt;</td></tr>
<tr class="memdesc:acd533abdb16d21402c2b6c7df83cf631"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static guard to allow certain members only on host (for serial execution)  <br /></td></tr>
<tr class="separator:acd533abdb16d21402c2b6c7df83cf631"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab4f5f5e59c75ebe1833f43539da95613" id="r_ab4f5f5e59c75ebe1833f43539da95613"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4f5f5e59c75ebe1833f43539da95613">SparseMatrix</a> ()=default</td></tr>
<tr class="memdesc:ab4f5f5e59c75ebe1833f43539da95613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty matrix.  <br /></td></tr>
<tr class="separator:ab4f5f5e59c75ebe1833f43539da95613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9451a2dfe43e3ca00d669f0f226ef15e" id="r_a9451a2dfe43e3ca00d669f0f226ef15e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9451a2dfe43e3ca00d669f0f226ef15e">SparseMatrix</a> (size_t <a class="el" href="#af9d71fd13d9a115799a115fc4897acbf">num_rows</a>, size_t <a class="el" href="#a08532625de0b1fb454bdcec9d2589ed1">num_cols</a>, const Vector&lt; Index &gt; &amp;<a class="el" href="#a64422ce3275d6f285b0814c5515d2edb">row_offsets</a>, const Vector&lt; Index &gt; &amp;<a class="el" href="#ac2e193ab4269eb83b367ae0f3d9ed867">column_indices</a>, const Vector&lt; Value &gt; &amp;<a class="el" href="#adcc706f14d189a87d479629b8da17bf0">values</a>)</td></tr>
<tr class="memdesc:a9451a2dfe43e3ca00d669f0f226ef15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly construct from given vectors.  <br /></td></tr>
<tr class="separator:a9451a2dfe43e3ca00d669f0f226ef15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3098002f94e4f28160de36a031976e01" id="r_a3098002f94e4f28160de36a031976e01"><td class="memTemplParams" colspan="2">template&lt;class I , class V , template&lt; class &gt; class Vec&gt; </td></tr>
<tr class="memitem:a3098002f94e4f28160de36a031976e01"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3098002f94e4f28160de36a031976e01">SparseMatrix</a> (const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; I, V, Vec &gt; &amp;src)</td></tr>
<tr class="memdesc:a3098002f94e4f28160de36a031976e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct from differen type.  <br /></td></tr>
<tr class="separator:a3098002f94e4f28160de36a031976e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa5dc2ab510e7b14dd35f462c73ef37" id="r_a6aa5dc2ab510e7b14dd35f462c73ef37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aa5dc2ab510e7b14dd35f462c73ef37">setFromCoo</a> (size_t <a class="el" href="#af9d71fd13d9a115799a115fc4897acbf">num_rows</a>, size_t <a class="el" href="#a08532625de0b1fb454bdcec9d2589ed1">num_cols</a>, const Vector&lt; Index &gt; &amp;row_indices, const Vector&lt; Index &gt; &amp;<a class="el" href="#ac2e193ab4269eb83b367ae0f3d9ed867">column_indices</a>, const Vector&lt; Value &gt; &amp;<a class="el" href="#adcc706f14d189a87d479629b8da17bf0">values</a>, bool sort=false)</td></tr>
<tr class="memdesc:a6aa5dc2ab510e7b14dd35f462c73ef37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set csr values from coo formatted sparse matrix.  <br /></td></tr>
<tr class="separator:a6aa5dc2ab510e7b14dd35f462c73ef37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c36d09a0c29746fa2917f3f45a1b00f" id="r_a1c36d09a0c29746fa2917f3f45a1b00f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c36d09a0c29746fa2917f3f45a1b00f">set</a> (size_t <a class="el" href="#af9d71fd13d9a115799a115fc4897acbf">num_rows</a>, size_t <a class="el" href="#a08532625de0b1fb454bdcec9d2589ed1">num_cols</a>, const Vector&lt; Index &gt; &amp;<a class="el" href="#a64422ce3275d6f285b0814c5515d2edb">row_offsets</a>, const Vector&lt; Index &gt; <a class="el" href="#ac2e193ab4269eb83b367ae0f3d9ed867">column_indices</a>, const Vector&lt; Value &gt; &amp;<a class="el" href="#adcc706f14d189a87d479629b8da17bf0">values</a>, bool sort=false)</td></tr>
<tr class="memdesc:a1c36d09a0c29746fa2917f3f45a1b00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set csr values directly.  <br /></td></tr>
<tr class="separator:a1c36d09a0c29746fa2917f3f45a1b00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf3e50d3bc680a82649a6a131e081c9" id="r_abbf3e50d3bc680a82649a6a131e081c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbf3e50d3bc680a82649a6a131e081c9">sort_indices</a> ()</td></tr>
<tr class="memdesc:abbf3e50d3bc680a82649a6a131e081c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort by row and column.  <br /></td></tr>
<tr class="separator:abbf3e50d3bc680a82649a6a131e081c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f192f252b0727b86cf1c16de6b54653" id="r_a5f192f252b0727b86cf1c16de6b54653"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f192f252b0727b86cf1c16de6b54653">total_num_rows</a> () const</td></tr>
<tr class="memdesc:a5f192f252b0727b86cf1c16de6b54653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>num_rows</code>.  <br /></td></tr>
<tr class="separator:a5f192f252b0727b86cf1c16de6b54653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815eddea5446897a555ff9c0fa6c865e" id="r_a815eddea5446897a555ff9c0fa6c865e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a815eddea5446897a555ff9c0fa6c865e">total_num_cols</a> () const</td></tr>
<tr class="memdesc:a815eddea5446897a555ff9c0fa6c865e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>num_cols</code>.  <br /></td></tr>
<tr class="separator:a815eddea5446897a555ff9c0fa6c865e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d71fd13d9a115799a115fc4897acbf" id="r_af9d71fd13d9a115799a115fc4897acbf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9d71fd13d9a115799a115fc4897acbf">num_rows</a> () const</td></tr>
<tr class="memdesc:af9d71fd13d9a115799a115fc4897acbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows in matrix.  <br /></td></tr>
<tr class="separator:af9d71fd13d9a115799a115fc4897acbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08532625de0b1fb454bdcec9d2589ed1" id="r_a08532625de0b1fb454bdcec9d2589ed1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08532625de0b1fb454bdcec9d2589ed1">num_cols</a> () const</td></tr>
<tr class="memdesc:a08532625de0b1fb454bdcec9d2589ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns in matrix.  <br /></td></tr>
<tr class="separator:a08532625de0b1fb454bdcec9d2589ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0819434e94cc2c5ba01c332f412b2e2" id="r_ac0819434e94cc2c5ba01c332f412b2e2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0819434e94cc2c5ba01c332f412b2e2">num_vals</a> () const</td></tr>
<tr class="memdesc:ac0819434e94cc2c5ba01c332f412b2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>num_nnz</code>.  <br /></td></tr>
<tr class="separator:ac0819434e94cc2c5ba01c332f412b2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f85cce7cca1aef71c122bcce596566" id="r_aa5f85cce7cca1aef71c122bcce596566"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5f85cce7cca1aef71c122bcce596566">num_nnz</a> () const</td></tr>
<tr class="memdesc:aa5f85cce7cca1aef71c122bcce596566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nonzero elements in matrix.  <br /></td></tr>
<tr class="separator:aa5f85cce7cca1aef71c122bcce596566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f89f44383baed52383cd1ca4a85e005" id="r_a6f89f44383baed52383cd1ca4a85e005"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f89f44383baed52383cd1ca4a85e005">num_entries</a> () const</td></tr>
<tr class="memdesc:a6f89f44383baed52383cd1ca4a85e005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>num_nnz</code>.  <br /></td></tr>
<tr class="separator:a6f89f44383baed52383cd1ca4a85e005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64422ce3275d6f285b0814c5515d2edb" id="r_a64422ce3275d6f285b0814c5515d2edb"><td class="memItemLeft" align="right" valign="top">const Vector&lt; Index &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64422ce3275d6f285b0814c5515d2edb">row_offsets</a> () const</td></tr>
<tr class="memdesc:a64422ce3275d6f285b0814c5515d2edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read row_offsets vector.  <br /></td></tr>
<tr class="separator:a64422ce3275d6f285b0814c5515d2edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e193ab4269eb83b367ae0f3d9ed867" id="r_ac2e193ab4269eb83b367ae0f3d9ed867"><td class="memItemLeft" align="right" valign="top">const Vector&lt; Index &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2e193ab4269eb83b367ae0f3d9ed867">column_indices</a> () const</td></tr>
<tr class="memdesc:ac2e193ab4269eb83b367ae0f3d9ed867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read column indices vector.  <br /></td></tr>
<tr class="separator:ac2e193ab4269eb83b367ae0f3d9ed867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc706f14d189a87d479629b8da17bf0" id="r_adcc706f14d189a87d479629b8da17bf0"><td class="memItemLeft" align="right" valign="top">const Vector&lt; Value &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcc706f14d189a87d479629b8da17bf0">values</a> () const</td></tr>
<tr class="memdesc:adcc706f14d189a87d479629b8da17bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read values vector.  <br /></td></tr>
<tr class="separator:adcc706f14d189a87d479629b8da17bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2258e60b54404f62298fa9ab198c980c" id="r_a2258e60b54404f62298fa9ab198c980c"><td class="memItemLeft" align="right" valign="top">Vector&lt; Value &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2258e60b54404f62298fa9ab198c980c">values</a> ()</td></tr>
<tr class="memdesc:a2258e60b54404f62298fa9ab198c980c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change values vector.  <br /></td></tr>
<tr class="separator:a2258e60b54404f62298fa9ab198c980c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404fbea29d1bc73e4bbb3658ea9af917" id="r_a404fbea29d1bc73e4bbb3658ea9af917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a404fbea29d1bc73e4bbb3658ea9af917">transpose</a> () const</td></tr>
<tr class="memdesc:a404fbea29d1bc73e4bbb3658ea9af917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposition.  <br /></td></tr>
<tr class="separator:a404fbea29d1bc73e4bbb3658ea9af917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03b0c5486cb9ca4753fbb785dde577d" id="r_af03b0c5486cb9ca4753fbb785dde577d"><td class="memTemplParams" colspan="2">template&lt;class OtherMatrix  = SparseMatrix&gt; </td></tr>
<tr class="memitem:af03b0c5486cb9ca4753fbb785dde577d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__dispatch.html#gaf2710dfc91ed3a6008d0b2df4dcd7f91">dg::has_policy_v</a>&lt; OtherMatrix, <a class="el" href="structdg_1_1_serial_tag.html">SerialTag</a> &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af03b0c5486cb9ca4753fbb785dde577d">operator!=</a> (const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;<a class="elRef" href="../../matrix/html/exp__runge__kutta__t_8cpp.html#acfa192a028001deacc8e9fd97695d1e0">rhs</a>) const</td></tr>
<tr class="memdesc:af03b0c5486cb9ca4753fbb785dde577d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two Matrices are considered equal if elements and sparsity pattern are equal.  <br /></td></tr>
<tr class="separator:af03b0c5486cb9ca4753fbb785dde577d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13cc80b96d53505645285e2d3144ebd" id="r_ab13cc80b96d53505645285e2d3144ebd"><td class="memTemplParams" colspan="2">template&lt;class OtherMatrix  = SparseMatrix&gt; </td></tr>
<tr class="memitem:ab13cc80b96d53505645285e2d3144ebd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__dispatch.html#gaf2710dfc91ed3a6008d0b2df4dcd7f91">dg::has_policy_v</a>&lt; OtherMatrix, <a class="el" href="structdg_1_1_serial_tag.html">SerialTag</a> &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab13cc80b96d53505645285e2d3144ebd">operator==</a> (const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;<a class="elRef" href="../../matrix/html/exp__runge__kutta__t_8cpp.html#acfa192a028001deacc8e9fd97695d1e0">rhs</a>) const</td></tr>
<tr class="memdesc:ab13cc80b96d53505645285e2d3144ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two Matrices are considered equal if elements and sparsity pattern are equal.  <br /></td></tr>
<tr class="separator:ab13cc80b96d53505645285e2d3144ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d499fc2f524eff3264ade1219bdb4d1" id="r_a0d499fc2f524eff3264ade1219bdb4d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d499fc2f524eff3264ade1219bdb4d1">operator-</a> () const</td></tr>
<tr class="memdesc:a0d499fc2f524eff3264ade1219bdb4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate.  <br /></td></tr>
<tr class="separator:a0d499fc2f524eff3264ade1219bdb4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dbbf6f3b6ee2aa0ec676ce54f29867" id="r_af6dbbf6f3b6ee2aa0ec676ce54f29867"><td class="memTemplParams" colspan="2">template&lt;class OtherMatrix  = SparseMatrix&gt; </td></tr>
<tr class="memitem:af6dbbf6f3b6ee2aa0ec676ce54f29867"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af6dbbf6f3b6ee2aa0ec676ce54f29867">operator+=</a> (const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;op)</td></tr>
<tr class="memdesc:af6dbbf6f3b6ee2aa0ec676ce54f29867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add.  <br /></td></tr>
<tr class="separator:af6dbbf6f3b6ee2aa0ec676ce54f29867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad29158d345a2d731014e49c79da5e4a" id="r_aad29158d345a2d731014e49c79da5e4a"><td class="memTemplParams" colspan="2">template&lt;class OtherMatrix  = SparseMatrix&gt; </td></tr>
<tr class="memitem:aad29158d345a2d731014e49c79da5e4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad29158d345a2d731014e49c79da5e4a">operator-=</a> (const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;op)</td></tr>
<tr class="memdesc:aad29158d345a2d731014e49c79da5e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract  <br /></td></tr>
<tr class="separator:aad29158d345a2d731014e49c79da5e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad48c2beb555ad1ddf98381210d495" id="r_ab1ad48c2beb555ad1ddf98381210d495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1ad48c2beb555ad1ddf98381210d495">operator*=</a> (const Value &amp;value)</td></tr>
<tr class="memdesc:ab1ad48c2beb555ad1ddf98381210d495"><td class="mdescLeft">&#160;</td><td class="mdescRight">scalar multiply  <br /></td></tr>
<tr class="separator:ab1ad48c2beb555ad1ddf98381210d495"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9bb3ff4cf3a29282d65c18d0be9990eb" id="r_a9bb3ff4cf3a29282d65c18d0be9990eb"><td class="memTemplParams" colspan="2">template&lt;class I , class V , template&lt; class &gt; class Vec&gt; </td></tr>
<tr class="memitem:a9bb3ff4cf3a29282d65c18d0be9990eb"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9bb3ff4cf3a29282d65c18d0be9990eb">SparseMatrix</a></td></tr>
<tr class="memdesc:a9bb3ff4cf3a29282d65c18d0be9990eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable copy constructor from foreign types.  <br /></td></tr>
<tr class="separator:a9bb3ff4cf3a29282d65c18d0be9990eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217e1010aa62def80a067c165f602f31" id="r_a217e1010aa62def80a067c165f602f31"><td class="memTemplParams" colspan="2">template&lt;class OtherMatrix  = SparseMatrix&gt; </td></tr>
<tr class="memitem:a217e1010aa62def80a067c165f602f31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a217e1010aa62def80a067c165f602f31">operator+</a> (const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;<a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a74d3e489d871726c04af786a72ca0fdc">lhs</a>, const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;<a class="elRef" href="../../matrix/html/exp__runge__kutta__t_8cpp.html#acfa192a028001deacc8e9fd97695d1e0">rhs</a>)</td></tr>
<tr class="memdesc:a217e1010aa62def80a067c165f602f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">add  <br /></td></tr>
<tr class="separator:a217e1010aa62def80a067c165f602f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d579539002944760303178727e8038" id="r_aa5d579539002944760303178727e8038"><td class="memTemplParams" colspan="2">template&lt;class OtherMatrix  = SparseMatrix&gt; </td></tr>
<tr class="memitem:aa5d579539002944760303178727e8038"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5d579539002944760303178727e8038">operator-</a> (const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;<a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a74d3e489d871726c04af786a72ca0fdc">lhs</a>, const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;<a class="elRef" href="../../matrix/html/exp__runge__kutta__t_8cpp.html#acfa192a028001deacc8e9fd97695d1e0">rhs</a>)</td></tr>
<tr class="memdesc:aa5d579539002944760303178727e8038"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract  <br /></td></tr>
<tr class="separator:aa5d579539002944760303178727e8038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74d345e0691088345e6a4d76f8930e0" id="r_ad74d345e0691088345e6a4d76f8930e0"><td class="memTemplParams" colspan="2">template&lt;class OtherMatrix  = SparseMatrix&gt; </td></tr>
<tr class="memitem:ad74d345e0691088345e6a4d76f8930e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad74d345e0691088345e6a4d76f8930e0">operator*</a> (const Value &amp;value, const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;<a class="elRef" href="../../matrix/html/exp__runge__kutta__t_8cpp.html#acfa192a028001deacc8e9fd97695d1e0">rhs</a>)</td></tr>
<tr class="memdesc:ad74d345e0691088345e6a4d76f8930e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">scalar multiplication  <br /></td></tr>
<tr class="separator:ad74d345e0691088345e6a4d76f8930e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4d248edfe666e11fa8aa63343cf0a8" id="r_a8e4d248edfe666e11fa8aa63343cf0a8"><td class="memTemplParams" colspan="2">template&lt;class OtherMatrix  = SparseMatrix&gt; </td></tr>
<tr class="memitem:a8e4d248edfe666e11fa8aa63343cf0a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e4d248edfe666e11fa8aa63343cf0a8">operator*</a> (const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;<a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a74d3e489d871726c04af786a72ca0fdc">lhs</a>, const Value &amp;value)</td></tr>
<tr class="memdesc:a8e4d248edfe666e11fa8aa63343cf0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">scalar multiplication  <br /></td></tr>
<tr class="separator:a8e4d248edfe666e11fa8aa63343cf0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23183f850ca02f9e6f4ac4d05f76734e" id="r_a23183f850ca02f9e6f4ac4d05f76734e"><td class="memTemplParams" colspan="2">template&lt;class OtherMatrix  = SparseMatrix&gt; </td></tr>
<tr class="memitem:a23183f850ca02f9e6f4ac4d05f76734e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23183f850ca02f9e6f4ac4d05f76734e">operator*</a> (const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;<a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a74d3e489d871726c04af786a72ca0fdc">lhs</a>, const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;<a class="elRef" href="../../matrix/html/exp__runge__kutta__t_8cpp.html#acfa192a028001deacc8e9fd97695d1e0">rhs</a>)</td></tr>
<tr class="memdesc:a23183f850ca02f9e6f4ac4d05f76734e"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix-matrix multiplication \( C = A*B\)  <br /></td></tr>
<tr class="separator:a23183f850ca02f9e6f4ac4d05f76734e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad939c0b5f1627a8196a7d782c510c9d5" id="r_ad939c0b5f1627a8196a7d782c510c9d5"><td class="memTemplParams" colspan="2">template&lt;class ContainerType , class  = std::enable_if_t &lt; dg::has_policy_v&lt;ContainerType, policy&gt; and dg::is_vector_v&lt;ContainerType&gt; &gt;&gt; </td></tr>
<tr class="memitem:ad939c0b5f1627a8196a7d782c510c9d5"><td class="memTemplItemLeft" align="right" valign="top">ContainerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad939c0b5f1627a8196a7d782c510c9d5">operator*</a> (const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;S, const ContainerType &amp;x)</td></tr>
<tr class="memdesc:ad939c0b5f1627a8196a7d782c510c9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix-vector multiplication \(  y = S x\)  <br /></td></tr>
<tr class="separator:ad939c0b5f1627a8196a7d782c510c9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadd7d67e8c862c5c8e58f1349b30e6b" id="r_abadd7d67e8c862c5c8e58f1349b30e6b"><td class="memTemplParams" colspan="2">template&lt;class Ostream , class OtherMatrix  = SparseMatrix&gt; </td></tr>
<tr class="memitem:abadd7d67e8c862c5c8e58f1349b30e6b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__dispatch.html#gaf2710dfc91ed3a6008d0b2df4dcd7f91">dg::has_policy_v</a>&lt; OtherMatrix, <a class="el" href="structdg_1_1_serial_tag.html">SerialTag</a> &gt;, Ostream &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abadd7d67e8c862c5c8e58f1349b30e6b">operator&lt;&lt;</a> (Ostream &amp;os, const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp;mat)</td></tr>
<tr class="memdesc:abadd7d67e8c862c5c8e58f1349b30e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">puts a matrix linewise in output stream  <br /></td></tr>
<tr class="separator:abadd7d67e8c862c5c8e58f1349b30e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Index = int, class Value = double, template&lt; class &gt; class Vector = thrust::host_vector&gt;<br />
struct dg::SparseMatrix&lt; Index, Value, Vector &gt;</div><p>A CSR formatted sparse matrix. </p>
<p>This class was designed to replace our dependency on <code>cusp::csr_matrix</code>. On the host arithmetic operators like + and * are overloaded allowing for expressive code to concisely assemble the matrix: </p><div class="fragment"><div class="line"><span class="comment">// 1 0 0 2</span></div>
<div class="line"><span class="comment">// 2 0 5 0</span></div>
<div class="line"><span class="comment">// 0 4 0 0</span></div>
<div class="line"><span class="comment">// 0 1 1 0</span></div>
<div class="line"><span class="keywordtype">unsigned</span> num_rows = 4, num_cols = 4;</div>
<div class="line">std::vector&lt;int&gt; rows = {0,2,4,5,7}, cols = {0,3,0,2,1,1,2};</div>
<div class="line">std::vector&lt;double&gt; vals = {1,2,2,5,4,1,1};</div>
<div class="line"><a class="code hl_struct" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix&lt;int,double,std::vector&gt;</a> A ( num_rows, num_cols, rows, cols, vals);</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 2 0 0 0</span></div>
<div class="line"><span class="comment">// 0 3 3 5</span></div>
<div class="line"><span class="comment">// 0 0 4 0</span></div>
<div class="line"><span class="comment">// 0 0 0 5</span></div>
<div class="line"><span class="comment">// 1 0 0 2</span></div>
<div class="line">num_rows = 5, num_cols = 4;</div>
<div class="line">rows = {0,1,4,5,6,8};</div>
<div class="line">cols = {0,1,2,3,2,3,0,3};</div>
<div class="line">vals = {2,3,3,5,4,5,1,2};</div>
<div class="line"><a class="code hl_struct" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix&lt;int,double,std::vector&gt;</a> B ( num_rows, num_cols, rows, cols, vals);</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// 3 4 0 0</span></div>
<div class="line"><span class="comment">// 10 16.5 13.5 8.5</span></div>
<div class="line"><span class="comment">// 0 20 2 4</span></div>
<div class="line"><span class="comment">// 10 0 0 2.5</span></div>
<div class="line"><span class="comment">// 5.5 2 0 1</span></div>
<div class="line"><span class="keyword">auto</span> C = B*A.transpose()+0.5*B;</div>
<div class="line"><span class="comment">//</span></div>
<div class="line">CHECK( C.num_rows() == 5);</div>
<div class="line">CHECK( C.num_cols() == 4);</div>
<div class="line">CHECK( C.row_offsets() == std::vector&lt;int&gt;{ 0,2,6,9,11,14});</div>
<div class="line">CHECK( C.column_indices() == std::vector&lt;int&gt;{ 0,1,0,1,2,3,1,2,3,0,3,0,1,3});</div>
<div class="line">CHECK( C.values() == std::vector&lt;double&gt;{ 3, 4, 10, 16.5, 13.5, 8.5, 20, 2, 4, 10, 2.5, 5.5, 2, 1});</div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Matrix-vector multiplication can be done on device</span></div>
<div class="line"><a class="code hl_struct" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix&lt;int,double,thrust::device_vector&gt;</a> dC = C;</div>
<div class="line">std::vector&lt;double&gt;  v = { 2,4,6,8}, w = {1,2,3,4,5};</div>
<div class="line">thrust::device_vector&lt;double&gt; dv( v.begin(), v.end()), dw( w.begin(), w.end());</div>
<div class="line"><span class="comment">// dw = dC * dv + 0.5 dw</span></div>
<div class="line"><a class="code hl_function" href="group__blas2.html#ga1b7e3b58697b6e93169eebbda63f3ed3">dg::blas2::gemv</a>( 1., dC, dv, 0.5, dw);</div>
<div class="line"><span class="comment">//</span></div>
<div class="line">thrust::copy( dw.begin(), dw.end(), w.begin());</div>
<div class="line">CHECK( w == std::vector{22.5,236.,125.5,42.,29.5});</div>
</div><!-- fragment --><p>On the device like OpenMP or GPU the only currently allowed operations are <code>transpose</code> and the matrix-vector multiplications through <code><a class="el" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a></code> (and its aliases <code><a class="el" href="group__blas2.html#ga1b7e3b58697b6e93169eebbda63f3ed3" title="Alias for blas2::symv ;.">dg::blas2::gemv</a></code> and <code><a class="el" href="group__blas2.html#gab8d14b7a823d92037add5899d611d7d9" title="Alias for dg::blas2::symv ;.">dg::apply</a></code>). We use the <code>cusparse</code> library to dispatch matrix-vector multiplication on the GPU. </p><dl class="section see"><dt>See also</dt><dd>The CSR format is nicely explained at the <a href="https://docs.nvidia.com/cuda/cusparse/#compressed-sparse-row-csr">cusparse documentation</a> We use the zero-base index</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The index type (on GPU must be either <code>int</code> or <code>long</code>) </td></tr>
    <tr><td class="paramname">Value</td><td>The value type (on GPU must be either <code>float</code> or <code>double</code>) </td></tr>
    <tr><td class="paramname">Vector</td><td>The vector class to store indices and values (typically <code>thrust::host_vector</code> or <code>thrust::device_vector</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__typedefs.html#ga0574e9a1653d69754216f030cd8d4e18">IHMatrix</a></code>, <code><a class="el" href="group__typedefs.html#ga813f1498b206af847ea78d2f674643c0">IDMatrix</a></code> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acd533abdb16d21402c2b6c7df83cf631" name="acd533abdb16d21402c2b6c7df83cf631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd533abdb16d21402c2b6c7df83cf631">&#9670;&#160;</a></span>enable_if_serial</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class OtherMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::enable_if_serial = std::enable_if_t&lt;std::is_same_v&lt;typename OtherMatrix::policy, <a class="el" href="structdg_1_1_serial_tag.html">SerialTag</a>&gt;, OtherMatrix&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A static guard to allow certain members only on host (for serial execution) </p>

</div>
</div>
<a id="a549d1327798f5dab79a3e109001bcfb1" name="a549d1327798f5dab79a3e109001bcfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549d1327798f5dab79a3e109001bcfb1">&#9670;&#160;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::index_type = Index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index type (on GPU must be either <code>int</code> or <code>long</code>) </p>

</div>
</div>
<a id="a59eee29cdfee7a957b2ba1ba826f1557" name="a59eee29cdfee7a957b2ba1ba826f1557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59eee29cdfee7a957b2ba1ba826f1557">&#9670;&#160;</a></span>policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::policy = <a class="el" href="group__dispatch.html#gac20006d24fe8a0049cc50a94f53aa26c">dg::get_execution_policy</a>&lt;Vector&lt;Value&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execution policy of the matrix. </p>

</div>
</div>
<a id="abac1a38822f90200316c633cfdbcd063" name="abac1a38822f90200316c633cfdbcd063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac1a38822f90200316c633cfdbcd063">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">::value_type</a> = Value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value type (on GPU must be either <code>float</code> or <code>double</code>) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab4f5f5e59c75ebe1833f43539da95613" name="ab4f5f5e59c75ebe1833f43539da95613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f5f5e59c75ebe1833f43539da95613">&#9670;&#160;</a></span>SparseMatrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::SparseMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty matrix. </p>
<p>Set values using either <code>setFromCoo</code> or <code>set</code> members </p>

</div>
</div>
<a id="a9451a2dfe43e3ca00d669f0f226ef15e" name="a9451a2dfe43e3ca00d669f0f226ef15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9451a2dfe43e3ca00d669f0f226ef15e">&#9670;&#160;</a></span>SparseMatrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Index &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>row_offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Index &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>column_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Value &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly construct from given vectors. </p>
<div class="fragment"><div class="line"><span class="comment">// 1 0 0 2 3</span></div>
<div class="line"><span class="comment">// 2 0 5 0 0</span></div>
<div class="line"><span class="comment">// 0 4 0 0 1</span></div>
<div class="line"><span class="keywordtype">unsigned</span> num_rows = 3, num_cols = 5;</div>
<div class="line">std::vector&lt;int&gt; rows = {0,3,5,7}, cols = {0,3,4,0,2,1,4};</div>
<div class="line">std::vector&lt;double&gt; vals = {1,2,3,2,5,4,1};</div>
<div class="line"><a class="code hl_struct" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix&lt;int,double,std::vector&gt;</a> A ( num_rows, num_cols, rows, cols, vals);</div>
<div class="line"><span class="comment">//</span></div>
<div class="line">CHECK( A.num_rows() == num_rows);</div>
<div class="line">CHECK( A.num_cols() == num_cols);</div>
<div class="line">CHECK( A.num_vals() == vals.size());</div>
<div class="line">CHECK( A.row_offsets()    == rows);</div>
<div class="line">CHECK( A.column_indices() == cols);</div>
<div class="line">CHECK( A.values()         == vals);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rows</td><td>Number of rows in the matrix </td></tr>
    <tr><td class="paramname">num_cols</td><td>Number of columns in the matrix </td></tr>
    <tr><td class="paramname">row_offsets</td><td>Vector of size <code>num_rows+1</code> representing the starting position of each row in the column_indices and values arrays. <code>row_offsets.back()</code> equals the number of non-zero elements in the matrix </td></tr>
    <tr><td class="paramname">column_indices</td><td>Vector of size <code>row_offsets.back()</code> containing column indices. The column indices may be unsorted within each row and should be unique. If duplicates exist symv may not be correct (from cusparse). </td></tr>
    <tr><td class="paramname">values</td><td>Vector of size <code>row_offsets.back()</code> containing nonzero values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3098002f94e4f28160de36a031976e01" name="a3098002f94e4f28160de36a031976e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3098002f94e4f28160de36a031976e01">&#9670;&#160;</a></span>SparseMatrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class I , class V , template&lt; class &gt; class Vec&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; I, V, Vec &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy construct from differen type. </p>
<p>Typically used to transfer a matrix from host to device </p><div class="fragment"><div class="line"><span class="comment">// 1 0 0 2 3</span></div>
<div class="line"><span class="comment">// 2 0 5 0 0</span></div>
<div class="line"><span class="comment">// 0 4 0 0 1</span></div>
<div class="line"><span class="keywordtype">unsigned</span> num_rows = 3, num_cols = 5;</div>
<div class="line"><span class="comment">// unsorted!!</span></div>
<div class="line">std::vector&lt;int&gt; rows = {0,3,5,7}, cols = {0,4,3,0,2,1,4};</div>
<div class="line">std::vector&lt;double&gt; vals = {1,3,2,2,5,4,1};</div>
<div class="line"><a class="code hl_struct" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix&lt;int,double,thrust::host_vector&gt;</a> A ( num_rows, num_cols, rows, cols, vals);</div>
<div class="line"><a class="code hl_struct" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix&lt;int,double, thrust::device_vector&gt;</a> dA( A);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Copy the matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2e193ab4269eb83b367ae0f3d9ed867" name="ac2e193ab4269eb83b367ae0f3d9ed867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e193ab4269eb83b367ae0f3d9ed867">&#9670;&#160;</a></span>column_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Vector&lt; Index &gt; &amp; <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::column_indices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read column indices vector. </p>
<dl class="section return"><dt>Returns</dt><dd>column indices </dd></dl>

</div>
</div>
<a id="a08532625de0b1fb454bdcec9d2589ed1" name="a08532625de0b1fb454bdcec9d2589ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08532625de0b1fb454bdcec9d2589ed1">&#9670;&#160;</a></span>num_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::num_cols </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of columns in matrix. </p>

</div>
</div>
<a id="a6f89f44383baed52383cd1ca4a85e005" name="a6f89f44383baed52383cd1ca4a85e005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f89f44383baed52383cd1ca4a85e005">&#9670;&#160;</a></span>num_entries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::num_entries </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>num_nnz</code>. </p>

</div>
</div>
<a id="aa5f85cce7cca1aef71c122bcce596566" name="aa5f85cce7cca1aef71c122bcce596566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f85cce7cca1aef71c122bcce596566">&#9670;&#160;</a></span>num_nnz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::num_nnz </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of nonzero elements in matrix. </p>

</div>
</div>
<a id="af9d71fd13d9a115799a115fc4897acbf" name="af9d71fd13d9a115799a115fc4897acbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d71fd13d9a115799a115fc4897acbf">&#9670;&#160;</a></span>num_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::num_rows </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of rows in matrix. </p>

</div>
</div>
<a id="ac0819434e94cc2c5ba01c332f412b2e2" name="ac0819434e94cc2c5ba01c332f412b2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0819434e94cc2c5ba01c332f412b2e2">&#9670;&#160;</a></span>num_vals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::num_vals </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>num_nnz</code>. </p>

</div>
</div>
<a id="af03b0c5486cb9ca4753fbb785dde577d" name="af03b0c5486cb9ca4753fbb785dde577d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03b0c5486cb9ca4753fbb785dde577d">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class OtherMatrix  = SparseMatrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="group__dispatch.html#gaf2710dfc91ed3a6008d0b2df4dcd7f91">dg::has_policy_v</a>&lt; OtherMatrix, <a class="el" href="structdg_1_1_serial_tag.html">SerialTag</a> &gt;, bool &gt; <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Two Matrices are considered equal if elements and sparsity pattern are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Matrix to be compared to this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rhs does not equal this </dd></dl>

</div>
</div>
<a id="ab1ad48c2beb555ad1ddf98381210d495" name="ab1ad48c2beb555ad1ddf98381210d495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ad48c2beb555ad1ddf98381210d495">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> &amp; <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scalar multiply </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af6dbbf6f3b6ee2aa0ec676ce54f29867" name="af6dbbf6f3b6ee2aa0ec676ce54f29867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6dbbf6f3b6ee2aa0ec676ce54f29867">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class OtherMatrix  = SparseMatrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt; &amp; <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a0d499fc2f524eff3264ade1219bdb4d1" name="a0d499fc2f524eff3264ade1219bdb4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d499fc2f524eff3264ade1219bdb4d1">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aad29158d345a2d731014e49c79da5e4a" name="aad29158d345a2d731014e49c79da5e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad29158d345a2d731014e49c79da5e4a">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class OtherMatrix  = SparseMatrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt; &amp; <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>subtract </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab13cc80b96d53505645285e2d3144ebd" name="ab13cc80b96d53505645285e2d3144ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13cc80b96d53505645285e2d3144ebd">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class OtherMatrix  = SparseMatrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="group__dispatch.html#gaf2710dfc91ed3a6008d0b2df4dcd7f91">dg::has_policy_v</a>&lt; OtherMatrix, <a class="el" href="structdg_1_1_serial_tag.html">SerialTag</a> &gt;, bool &gt; <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Two Matrices are considered equal if elements and sparsity pattern are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Matrix to be compared to this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rhs equals this </dd></dl>

</div>
</div>
<a id="a64422ce3275d6f285b0814c5515d2edb" name="a64422ce3275d6f285b0814c5515d2edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64422ce3275d6f285b0814c5515d2edb">&#9670;&#160;</a></span>row_offsets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Vector&lt; Index &gt; &amp; <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::row_offsets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read row_offsets vector. </p>
<dl class="section return"><dt>Returns</dt><dd>row_offsets </dd></dl>

</div>
</div>
<a id="a1c36d09a0c29746fa2917f3f45a1b00f" name="a1c36d09a0c29746fa2917f3f45a1b00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c36d09a0c29746fa2917f3f45a1b00f">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::set </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Index &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>row_offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Index &gt;</td>          <td class="paramname"><span class="paramname"><em>column_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Value &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>sort</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set csr values directly. </p>
<div class="fragment"><div class="line"><span class="comment">// 0 2 0 0 4</span></div>
<div class="line"><span class="comment">// 0 1 2 0 0</span></div>
<div class="line"><span class="comment">// 0 0 0 0 0</span></div>
<div class="line">num_rows = 3, num_cols = 5;</div>
<div class="line">rows = {0,2,4,4}, cols = {1,4,1,2};</div>
<div class="line">vals = {2,4,1,2};</div>
<div class="line"><a class="code hl_struct" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix&lt;int,double,std::vector&gt;</a> D;</div>
<div class="line">D.<a class="code hl_function" href="#a1c36d09a0c29746fa2917f3f45a1b00f">set</a>( num_rows, num_cols, rows, cols, vals);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rows</td><td>Number of rows in the matrix </td></tr>
    <tr><td class="paramname">num_cols</td><td>Number of columns in the matrix </td></tr>
    <tr><td class="paramname">row_offsets</td><td>Vector of size <code>num_rows+1</code> representing the starting position of each row in the column_indices and values arrays. <code>row_offsets.back()</code> equals the number of non-zero elements in the matrix </td></tr>
    <tr><td class="paramname">column_indices</td><td>Vector of size <code>row_offsets.back()</code> containing column indices. The column indices may be unsorted within each row and should be unique. If duplicates exist symv may not be correct (from cusparse). </td></tr>
    <tr><td class="paramname">values</td><td>Vector of size <code>row_offsets.back()</code> containing nonzero values </td></tr>
    <tr><td class="paramname">sort</td><td>If <code>true</code> the given vectors are sorted by column_indices in each row. It is allowed to have unsorted column indices in each row so sorting is not strictly necessary. It may (or may not) have an effect on performance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6aa5dc2ab510e7b14dd35f462c73ef37" name="a6aa5dc2ab510e7b14dd35f462c73ef37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa5dc2ab510e7b14dd35f462c73ef37">&#9670;&#160;</a></span>setFromCoo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::setFromCoo </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Index &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>row_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Index &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>column_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Value &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>sort</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set csr values from coo formatted sparse matrix. </p>
<div class="fragment"><div class="line"><span class="comment">// 1 0 0 2 3</span></div>
<div class="line"><span class="comment">// 2 0 5 0 0</span></div>
<div class="line"><span class="comment">// 0 4 0 0 1</span></div>
<div class="line"><span class="keywordtype">unsigned</span> num_rows = 3, num_cols = 5;</div>
<div class="line">std::vector&lt;int&gt; rows = {2,2,0,0,0,1,1}, cols = {4,1,4,3,0,2,0};</div>
<div class="line">std::vector&lt;double&gt; vals = {1,4, 3,2,1,5,2};</div>
<div class="line"><a class="code hl_struct" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix&lt;int,double,std::vector&gt;</a> A;</div>
<div class="line">A.<a class="code hl_function" href="#a6aa5dc2ab510e7b14dd35f462c73ef37">setFromCoo</a>( num_rows, num_cols, rows, cols, vals, <span class="keyword">true</span>);</div>
<div class="line">CHECK( A.<a class="code hl_function" href="#a64422ce3275d6f285b0814c5515d2edb">row_offsets</a>() == std::vector{0,3,5,7});</div>
<div class="line">CHECK( A.<a class="code hl_function" href="#ac2e193ab4269eb83b367ae0f3d9ed867">column_indices</a>() == std::vector{0,3,4,0,2,1,4});</div>
<div class="line">CHECK( A.<a class="code hl_function" href="#adcc706f14d189a87d479629b8da17bf0">values</a>() == std::vector&lt;double&gt;{1,2,3,2,5,4,1});</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>May be unsorted, in which case the <code>sort</code> parameter should be set to <code>true</code>; if duplicates exist symv may not be correct (from cusparse)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rows</td><td>Number of rows in the matrix </td></tr>
    <tr><td class="paramname">num_cols</td><td>Number of columns in the matrix </td></tr>
    <tr><td class="paramname">row_indices</td><td>Contains row indices of the corresponding elements in the values vector </td></tr>
    <tr><td class="paramname">column_indices</td><td>Vector of size <code>row_indices.size()()</code> containing column indices. </td></tr>
    <tr><td class="paramname">values</td><td>Vector of size <code>row_indices.size()</code> containing nonzero values </td></tr>
    <tr><td class="paramname">sort</td><td>If <code>true</code> the given vectors are sorted by row and column before converted to the csr format. Per default we assume that the values are sorted by row (not necessarily by column). In this case there is no need to sort the indices, which may be somewhat expensive. If the row indices are unsorted however, <code>sort</code> must be set to <code>true</code> otherwise the coo2csr conversion will fail. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbf3e50d3bc680a82649a6a131e081c9" name="abbf3e50d3bc680a82649a6a131e081c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf3e50d3bc680a82649a6a131e081c9">&#9670;&#160;</a></span>sort_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::sort_indices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort by row and column. </p>
<p>Sort is somewhat expensive and it is allowed to have unsorted column indices (at least in cusparse). Sorting may or may not have an influence on performance. Never sort a stencil for <code><a class="el" href="group__blas2.html#gadb834f2824e513f17fe6a1b9035e9fb8">dg::blas2::stencil</a></code>. </p>

</div>
</div>
<a id="a815eddea5446897a555ff9c0fa6c865e" name="a815eddea5446897a555ff9c0fa6c865e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815eddea5446897a555ff9c0fa6c865e">&#9670;&#160;</a></span>total_num_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::total_num_cols </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>num_cols</code>. </p>

</div>
</div>
<a id="a5f192f252b0727b86cf1c16de6b54653" name="a5f192f252b0727b86cf1c16de6b54653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f192f252b0727b86cf1c16de6b54653">&#9670;&#160;</a></span>total_num_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::total_num_rows </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code>num_rows</code>. </p>

</div>
</div>
<a id="a404fbea29d1bc73e4bbb3658ea9af917" name="a404fbea29d1bc73e4bbb3658ea9af917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404fbea29d1bc73e4bbb3658ea9af917">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a> <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposition. </p>
<p>The transpose is sorted even if the original is not </p><dl class="section return"><dt>Returns</dt><dd>A newly generated <a class="el" href="structdg_1_1_sparse_matrix.html" title="A CSR formatted sparse matrix.">SparseMatrix</a> containing the transpose. </dd></dl>

</div>
</div>
<a id="a2258e60b54404f62298fa9ab198c980c" name="a2258e60b54404f62298fa9ab198c980c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2258e60b54404f62298fa9ab198c980c">&#9670;&#160;</a></span>values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt; Value &gt; &amp; <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::values </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change values vector. </p>
<dl class="section note"><dt>Note</dt><dd>The reason why <code>values</code> can be changed directly while <code>row_offsets</code> and <code>column_indices</code> cannot, is that changing the values does not influence the performance cache, while changing the sparsity pattern through <code>row_offsets</code> and <code>column_indices</code> does </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Values array reference </dd></dl>

</div>
</div>
<a id="adcc706f14d189a87d479629b8da17bf0" name="adcc706f14d189a87d479629b8da17bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc706f14d189a87d479629b8da17bf0">&#9670;&#160;</a></span>values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Vector&lt; Value &gt; &amp; <a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; Index, Value, Vector &gt;::values </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read values vector. </p>
<dl class="section return"><dt>Returns</dt><dd>values </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a23183f850ca02f9e6f4ac4d05f76734e" name="a23183f850ca02f9e6f4ac4d05f76734e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23183f850ca02f9e6f4ac4d05f76734e">&#9670;&#160;</a></span>operator* <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class OtherMatrix  = SparseMatrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>matrix-matrix multiplication \( C = A*B\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>multiplication (sorted even if lhs and rhs are not) </dd></dl>

</div>
</div>
<a id="a8e4d248edfe666e11fa8aa63343cf0a8" name="a8e4d248edfe666e11fa8aa63343cf0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4d248edfe666e11fa8aa63343cf0a8">&#9670;&#160;</a></span>operator* <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class OtherMatrix  = SparseMatrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scalar multiplication </p>
<p>Simply multiply values array by given value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad939c0b5f1627a8196a7d782c510c9d5" name="ad939c0b5f1627a8196a7d782c510c9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad939c0b5f1627a8196a7d782c510c9d5">&#9670;&#160;</a></span>operator* <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class ContainerType , class  = std::enable_if_t &lt; dg::has_policy_v&lt;ContainerType, policy&gt; and dg::is_vector_v&lt;ContainerType&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ContainerType operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>matrix-vector multiplication \(  y = S x\) </p>
<p>Works if ContainerType has the same execution policy as the <a class="el" href="structdg_1_1_sparse_matrix.html" title="A CSR formatted sparse matrix.">SparseMatrix</a> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> mat = <a class="code hl_class" href="classdg_1_1_square_matrix.html">dg::SquareMatrix&lt;double&gt;</a>({0,1,2, 3,4,5, 6,7,8});</div>
<div class="line">std::vector&lt;double&gt; vec = {1,2,3};</div>
<div class="line">std::vector&lt;double&gt; res = mat*vec;</div>
<div class="line">CHECK( res == std::vector&lt;double&gt;{8, 26, 44});</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>Matrix </td></tr>
    <tr><td class="paramname">x</td><td>Vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector </dd></dl>

</div>
</div>
<a id="ad74d345e0691088345e6a4d76f8930e0" name="ad74d345e0691088345e6a4d76f8930e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74d345e0691088345e6a4d76f8930e0">&#9670;&#160;</a></span>operator* <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class OtherMatrix  = SparseMatrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scalar multiplication </p>
<p>Simply multiply values array by given value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a217e1010aa62def80a067c165f602f31" name="a217e1010aa62def80a067c165f602f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217e1010aa62def80a067c165f602f31">&#9670;&#160;</a></span>operator+</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class OtherMatrix  = SparseMatrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>addition (sorted even if lhs and rhs are not) </dd></dl>

</div>
</div>
<a id="aa5d579539002944760303178727e8038" name="aa5d579539002944760303178727e8038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d579539002944760303178727e8038">&#9670;&#160;</a></span>operator-</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class OtherMatrix  = SparseMatrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acd533abdb16d21402c2b6c7df83cf631">enable_if_serial</a>&lt; OtherMatrix &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>subtract </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>subtraction (sorted even if lhs and rhs are not) </dd></dl>

</div>
</div>
<a id="abadd7d67e8c862c5c8e58f1349b30e6b" name="abadd7d67e8c862c5c8e58f1349b30e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadd7d67e8c862c5c8e58f1349b30e6b">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class Ostream , class OtherMatrix  = SparseMatrix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="group__dispatch.html#gaf2710dfc91ed3a6008d0b2df4dcd7f91">dg::has_policy_v</a>&lt; OtherMatrix, <a class="el" href="structdg_1_1_serial_tag.html">SerialTag</a> &gt;, Ostream &gt; &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Index, Value, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>puts a matrix linewise in output stream </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ostream</td><td>The stream e.g. std::cout </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the outstream </td></tr>
    <tr><td class="paramname">mat</td><td>the matrix to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the outstream </dd></dl>

</div>
</div>
<a id="a9bb3ff4cf3a29282d65c18d0be9990eb" name="a9bb3ff4cf3a29282d65c18d0be9990eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb3ff4cf3a29282d65c18d0be9990eb">&#9670;&#160;</a></span>SparseMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index  = int, class Value  = double, template&lt; class &gt; class Vector = thrust::host_vector&gt; </div>
<div class="memtemplate">
template&lt;class I , class V , template&lt; class &gt; class Vec&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable copy constructor from foreign types. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>backend/<a class="el" href="sparsematrix_8h_source.html">sparsematrix.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_sparse_matrix.html">SparseMatrix</a></li>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:30 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
