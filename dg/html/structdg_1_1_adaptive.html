<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: dg::Adaptive&lt; Stepper &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structdg_1_1_adaptive.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1_adaptive-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::Adaptive&lt; Stepper &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__lvevl2.html">Level 2: Basic numerical algorithms</a> &raquo; <a class="el" href="group__time.html">ODE integration</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Driver class for adaptive timestep ODE integration.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6c48d0d136681f6c6810e41538fb8771" id="r_a6c48d0d136681f6c6810e41538fb8771"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c48d0d136681f6c6810e41538fb8771">stepper_type</a> = Stepper</td></tr>
<tr class="separator:a6c48d0d136681f6c6810e41538fb8771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0066793e3a3e9d5159da5c12dfb4b3" id="r_a9b0066793e3a3e9d5159da5c12dfb4b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> = typename Stepper::container_type</td></tr>
<tr class="memdesc:a9b0066793e3a3e9d5159da5c12dfb4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of the vector class in use by <code>Stepper</code>  <br /></td></tr>
<tr class="separator:a9b0066793e3a3e9d5159da5c12dfb4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f64c811c0abb1a6aa871d4bf7b868a0" id="r_a9f64c811c0abb1a6aa871d4bf7b868a0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> = typename Stepper::value_type</td></tr>
<tr class="memdesc:a9f64c811c0abb1a6aa871d4bf7b868a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">the value type of the time variable defined by <code>Stepper</code> (float or double)  <br /></td></tr>
<tr class="separator:a9f64c811c0abb1a6aa871d4bf7b868a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6fc84649c7e2f28a2bdbc4a21387a0e7" id="r_a6fc84649c7e2f28a2bdbc4a21387a0e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fc84649c7e2f28a2bdbc4a21387a0e7">Adaptive</a> ()=default</td></tr>
<tr class="separator:a6fc84649c7e2f28a2bdbc4a21387a0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cb5e4317ad65086f4272a6a48b69e2" id="r_ae5cb5e4317ad65086f4272a6a48b69e2"><td class="memTemplParams" colspan="2">template&lt;class ... StepperParams&gt; </td></tr>
<tr class="memitem:ae5cb5e4317ad65086f4272a6a48b69e2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5cb5e4317ad65086f4272a6a48b69e2">Adaptive</a> (StepperParams &amp;&amp;...ps)</td></tr>
<tr class="memdesc:ae5cb5e4317ad65086f4272a6a48b69e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate workspace and construct stepper.  <br /></td></tr>
<tr class="separator:ae5cb5e4317ad65086f4272a6a48b69e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a2a4775e4b28140da5b61d348c7f6e" id="r_a94a2a4775e4b28140da5b61d348c7f6e"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:a94a2a4775e4b28140da5b61d348c7f6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a94a2a4775e4b28140da5b61d348c7f6e">construct</a> (Params &amp;&amp;...ps)</td></tr>
<tr class="memdesc:a94a2a4775e4b28140da5b61d348c7f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect forward parameters to one of the constructors.     <br /></td></tr>
<tr class="separator:a94a2a4775e4b28140da5b61d348c7f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1cb29ae32e9bc382f22790ca684645" id="r_a2e1cb29ae32e9bc382f22790ca684645"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6c48d0d136681f6c6810e41538fb8771">stepper_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e1cb29ae32e9bc382f22790ca684645">stepper</a> ()</td></tr>
<tr class="memdesc:a2e1cb29ae32e9bc382f22790ca684645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow write access to internal stepper.  <br /></td></tr>
<tr class="separator:a2e1cb29ae32e9bc382f22790ca684645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ab3bfa1165e9570018208c69405e6d" id="r_a19ab3bfa1165e9570018208c69405e6d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a6c48d0d136681f6c6810e41538fb8771">stepper_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19ab3bfa1165e9570018208c69405e6d">stepper</a> () const</td></tr>
<tr class="memdesc:a19ab3bfa1165e9570018208c69405e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read access to internal stepper.  <br /></td></tr>
<tr class="separator:a19ab3bfa1165e9570018208c69405e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2358b99c6a02db92304b1b6b568e3112" id="r_a2358b99c6a02db92304b1b6b568e3112"><td class="memTemplParams" colspan="2">template&lt;class ODE , class ControlFunction  = value_type (std::array&lt;value_type,3&gt;,                      std::array&lt; value_type,3&gt;, unsigned , unsigned), class ErrorNorm  = value_type( const container_type&amp;)&gt; </td></tr>
<tr class="memitem:a2358b99c6a02db92304b1b6b568e3112"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2358b99c6a02db92304b1b6b568e3112">step</a> (ODE &amp;&amp;ode, <a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> t0, const <a class="el" href="#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;u0, <a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;t1, <a class="el" href="#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;u1, <a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;dt, ControlFunction control, ErrorNorm norm, <a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> rtol, <a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> atol, <a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> reject_limit=2)</td></tr>
<tr class="memdesc:a2358b99c6a02db92304b1b6b568e3112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semi-implicit adaptive step.  <br /></td></tr>
<tr class="separator:a2358b99c6a02db92304b1b6b568e3112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11328919ed0d30e7e8719cd2f7629a2" id="r_ad11328919ed0d30e7e8719cd2f7629a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad11328919ed0d30e7e8719cd2f7629a2">failed</a> () const</td></tr>
<tr class="memdesc:ad11328919ed0d30e7e8719cd2f7629a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the last stepsize in step was rejected.  <br /></td></tr>
<tr class="separator:ad11328919ed0d30e7e8719cd2f7629a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f07a5345c2628c9f1dbe8d8cee8ef45" id="r_a4f07a5345c2628c9f1dbe8d8cee8ef45"><td class="memItemLeft" align="right" valign="top">const unsigned &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f07a5345c2628c9f1dbe8d8cee8ef45">nfailed</a> () const</td></tr>
<tr class="memdesc:a4f07a5345c2628c9f1dbe8d8cee8ef45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total number of failed steps.  <br /></td></tr>
<tr class="separator:a4f07a5345c2628c9f1dbe8d8cee8ef45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b665e65a06eb67811c5ec9c4cd7251f" id="r_a1b665e65a06eb67811c5ec9c4cd7251f"><td class="memItemLeft" align="right" valign="top">unsigned &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b665e65a06eb67811c5ec9c4cd7251f">nfailed</a> ()</td></tr>
<tr class="memdesc:a1b665e65a06eb67811c5ec9c4cd7251f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set total number of failed steps.  <br /></td></tr>
<tr class="separator:a1b665e65a06eb67811c5ec9c4cd7251f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3bed7fbe0a9615c8f281701430a5b0" id="r_aaa3bed7fbe0a9615c8f281701430a5b0"><td class="memItemLeft" align="right" valign="top">const unsigned &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa3bed7fbe0a9615c8f281701430a5b0">nsteps</a> () const</td></tr>
<tr class="memdesc:aaa3bed7fbe0a9615c8f281701430a5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total number of step calls.  <br /></td></tr>
<tr class="separator:aaa3bed7fbe0a9615c8f281701430a5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab0e8a440ba6b0894d6b281445df0a5" id="r_a7ab0e8a440ba6b0894d6b281445df0a5"><td class="memItemLeft" align="right" valign="top">unsigned &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ab0e8a440ba6b0894d6b281445df0a5">nsteps</a> ()</td></tr>
<tr class="memdesc:a7ab0e8a440ba6b0894d6b281445df0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-set total number of step calls.  <br /></td></tr>
<tr class="separator:a7ab0e8a440ba6b0894d6b281445df0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe13e0ad61e76d061720af0c47e2b48" id="r_aabe13e0ad61e76d061720af0c47e2b48"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabe13e0ad61e76d061720af0c47e2b48">get_error</a> () const</td></tr>
<tr class="memdesc:aabe13e0ad61e76d061720af0c47e2b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the latest error norm relative to solution vector.  <br /></td></tr>
<tr class="separator:aabe13e0ad61e76d061720af0c47e2b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Stepper&gt;<br />
struct dg::Adaptive&lt; Stepper &gt;</div><p>Driver class for adaptive timestep ODE integration. </p>
<p>In order to build an adaptive ODE integrator you basically need three ingredients: a <code>Stepper</code>, a <code>ControlFunction</code> and an <code>ErrorNorm</code>. The <code>Stepper</code> does the actual computation and advances the solution one step further with a given timestep <code>dt</code>. Furthermore, it has to come up with an estimate of the error of the solution \(\delta_{n+1}\) and indicate the order of that error. With the <code>ErrorNorm</code> the error estimate can be converted to a scalar that can be compared to given relative and absolute error tolerances <code>rtol</code> and <code>atol</code>. </p><p class="formulaDsp">
\[ \epsilon_{n+1} = || \frac{\delta_{n+1}}{(\epsilon_{rtol} |u_{n}| + \epsilon_{atol})\sqrt{N}}|| \]
</p>
<p> where N is the array size, <code>n</code> is the solution at the previous timestep and the fraction is to be understood as a pointwise division of the vector elements. The <code>ControlFunction</code> will try to keep \( \epsilon_{n+1}\) close to 1 and comes up with an adapted suggestion for the timestep in the next step.</p>
<p>This form of error control entails that on average every point in the solution vector on its own fulfills \( |\delta_{n+1,i}| \approx \epsilon_{rtol}|u_{n,i} + \epsilon_{atol}\), (which places emphasize on <code>atol</code> in regions where the solution is close to zero).</p>
<p>However, if \(\epsilon_{n+1} &gt; r\) where <code>r=2</code> by default is the user-adaptable reject-limit, the step is rejected and the step will be recomputed and the controller restarted. For more information on these concepts we recommend <a href="https://sundials.readthedocs.io/en/latest/arkode/Mathematics_link.html#https://sundials.readthedocs.io/en/latest/arkode/Mathematics_link.html#">the mathematical primer</a> in the ARKode library.</p>
<p>For an example on how to use this class in a practical example consider the following code snippet: </p><div class="fragment"><div class="line">        time = 0., y0 = init;</div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_adaptive.html">dg::Adaptive&lt;dg::ARKStep&lt;std::array&lt;double,2&gt;</a>&gt;&gt; adapt( name, y0);</div>
<div class="line">        <span class="keywordtype">double</span> time = 0;</div>
<div class="line">        <span class="keywordtype">double</span> dt = 1e-6;</div>
<div class="line">        <span class="keywordtype">int</span> counter=0;</div>
<div class="line">        <span class="keywordflow">while</span>( time &lt; T )</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span>( time + dt &gt; T)</div>
<div class="line">                dt = T-time;</div>
<div class="line">            adapt.step( std::tie(ex, im, im), time, y0, time, y0, dt,</div>
<div class="line">                    <a class="code hl_variable" href="group__time__utils.html#ga3d078141617f2e4fe33df24f289ac6af">dg::imex_control</a>, <a class="code hl_variable" href="group__time__utils.html#ga40758fa443b6728e1499c7ee16820c17">dg::l2norm</a>, rtol, atol);</div>
<div class="line">            counter ++;</div>
<div class="line">        }</div>
</div><!-- fragment -->  <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stepper</td><td>A timestepper class that computes the actual timestep and an error estimate, for example an embedded Runge Kutta method <code><a class="el" href="structdg_1_1_e_r_k_step.html" title="Embedded Runge Kutta explicit time-step with error estimate        .">dg::ERKStep</a></code> or the additive method <code><a class="el" href="structdg_1_1_a_r_k_step.html" title="Additive Runge Kutta (semi-implicit) time-step with error estimate following The ARKode library">dg::ARKStep</a></code>. But really, you can also choose to use your own timestepper class. The requirement is that there is a <code>step</code> member function that is called as <b>stepper.step( ode, t0, u0, t1, u1, dt, delta)</b> Here, t0, t1 and dt are of type <b>Stepper::value_type</b>, u0,u1 and delta are vector types of type <b>Stepper::container_type&amp;</b> and ode, ex and im are functors implementing the equations that are forwarded from the caller. The parameters t1, u1 and delta are output parameters and must be updated by the stepper. The <code>Stepper</code> must have the <code>order()</code> and <code>embedded_order()</code> member functions that return the (global) order of the method and its error estimate. The <code> const ContainerType&amp; copyable()const; </code> member must return a container of the size that is later used in <code>step</code> (it does not matter what values <code>copyable</code> contains, but its size is important; the <code>step</code> method can only be called with vectors of this size)    </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On step rejection, choosing timesteps and introducing restrictions on the controller: here is a quote from professor G. Söderlind (the master of control functions) from a private e-mail conversation:</dd>
<dd>
"The issue is that most controllers are best left to do their work
without interference. Each time one interferes with the control loop, one
creates a transient that has to be dealt with by the controller.

@note It is indeed necessary to reject steps every once in a while, but I
usually try to avoid it to the greatest possible extent. In my opinion, the
fear of having a too large error on some steps is vastly exaggerated. You see,
in some steps the error is too large, and in others it is too small, and all
controllers I constructed are designed to be “expectation value correct” in the
sense that if the errors are random, the too large and too small errors
basically cancel in the long run.

@note Even so, there are times when the error is way out of proportion. But I
usually accept an error that is up to, say 2*TOL, which typically won’t cause
any problems. Of course, if one hits a sharp change in the solution, the error
may be much larger, and the step recomputed. But then one must “reset" the controller, i.e., the controller keeps back information, and it is better to restart the controller to avoid back information to affect the next step." </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Should you use this class instead of a fixed stepsize Multistep say? The thing to consider especially when solving partial differential equations, is that the right hand side might be very costly to evaluate. An adaptive stepper (especially one-step methods) usually calls this right hand side more often than a multistep (only one call per step). The additional computation of the error norm in the <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep ODE integration.">Adaptive</a> step might also be important since the norm requires global communication in a parallel program (bad for scaling to many nodes). So does the <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep ODE integration.">Adaptive</a> timestepper make up for its increased cost throught the adaption of the stepsize? In some cases the answer might be a sound Yes. Especially when there are velocity peaks in the solution the multistep timestep might be restricted too much. In other cases when the timestep does not need to be adapted much, a multistep method can be faster. In any case the big advantage of <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep ODE integration.">Adaptive</a> is that it usually just works (even though it is not fool-proof) and you do not have to spend time finding a suitable timestep like in the multistep method. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9b0066793e3a3e9d5159da5c12dfb4b3" name="a9b0066793e3a3e9d5159da5c12dfb4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0066793e3a3e9d5159da5c12dfb4b3">&#9670;&#160;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::container_type = typename Stepper::container_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of the vector class in use by <code>Stepper</code> </p>

</div>
</div>
<a id="a6c48d0d136681f6c6810e41538fb8771" name="a6c48d0d136681f6c6810e41538fb8771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c48d0d136681f6c6810e41538fb8771">&#9670;&#160;</a></span>stepper_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::stepper_type = Stepper</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f64c811c0abb1a6aa871d4bf7b868a0" name="a9f64c811c0abb1a6aa871d4bf7b868a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f64c811c0abb1a6aa871d4bf7b868a0">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">::value_type</a> = typename Stepper::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the value type of the time variable defined by <code>Stepper</code> (float or double) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6fc84649c7e2f28a2bdbc4a21387a0e7" name="a6fc84649c7e2f28a2bdbc4a21387a0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc84649c7e2f28a2bdbc4a21387a0e7">&#9670;&#160;</a></span>Adaptive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::Adaptive </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5cb5e4317ad65086f4272a6a48b69e2" name="ae5cb5e4317ad65086f4272a6a48b69e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cb5e4317ad65086f4272a6a48b69e2">&#9670;&#160;</a></span>Adaptive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<div class="memtemplate">
template&lt;class ... StepperParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::Adaptive </td>
          <td>(</td>
          <td class="paramtype">StepperParams &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate workspace and construct stepper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>All parameters are forwarded to the constructor of <code>Stepper</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StepperParams</td><td>Type of parameters (deduced by the compiler) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The workspace for <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep ODE integration.">Adaptive</a> is constructed from the <code>copyable</code> member of Stepper </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a94a2a4775e4b28140da5b61d348c7f6e" name="a94a2a4775e4b28140da5b61d348c7f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a2a4775e4b28140da5b61d348c7f6e">&#9670;&#160;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect forward parameters to one of the constructors.    </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>parameters forwarded to constructors    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad11328919ed0d30e7e8719cd2f7629a2" name="ad11328919ed0d30e7e8719cd2f7629a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11328919ed0d30e7e8719cd2f7629a2">&#9670;&#160;</a></span>failed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::failed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the last stepsize in step was rejected. </p>

</div>
</div>
<a id="aabe13e0ad61e76d061720af0c47e2b48" name="aabe13e0ad61e76d061720af0c47e2b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe13e0ad61e76d061720af0c47e2b48">&#9670;&#160;</a></span>get_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp; <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::get_error </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the latest error norm relative to solution vector. </p>
<p>The error of the latest call to <code>step</code> </p><dl class="section return"><dt>Returns</dt><dd>eps_{n+1} </dd></dl>

</div>
</div>
<a id="a1b665e65a06eb67811c5ec9c4cd7251f" name="a1b665e65a06eb67811c5ec9c4cd7251f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b665e65a06eb67811c5ec9c4cd7251f">&#9670;&#160;</a></span>nfailed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned &amp; <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::nfailed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set total number of failed steps. </p>

</div>
</div>
<a id="a4f07a5345c2628c9f1dbe8d8cee8ef45" name="a4f07a5345c2628c9f1dbe8d8cee8ef45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f07a5345c2628c9f1dbe8d8cee8ef45">&#9670;&#160;</a></span>nfailed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned &amp; <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::nfailed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get total number of failed steps. </p>

</div>
</div>
<a id="a7ab0e8a440ba6b0894d6b281445df0a5" name="a7ab0e8a440ba6b0894d6b281445df0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab0e8a440ba6b0894d6b281445df0a5">&#9670;&#160;</a></span>nsteps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned &amp; <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::nsteps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-set total number of step calls. </p>

</div>
</div>
<a id="aaa3bed7fbe0a9615c8f281701430a5b0" name="aaa3bed7fbe0a9615c8f281701430a5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3bed7fbe0a9615c8f281701430a5b0">&#9670;&#160;</a></span>nsteps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned &amp; <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::nsteps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get total number of step calls. </p>

</div>
</div>
<a id="a2358b99c6a02db92304b1b6b568e3112" name="a2358b99c6a02db92304b1b6b568e3112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2358b99c6a02db92304b1b6b568e3112">&#9670;&#160;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<div class="memtemplate">
template&lt;class ODE , class ControlFunction  = value_type (std::array&lt;value_type,3&gt;,                      std::array&lt; value_type,3&gt;, unsigned , unsigned), class ErrorNorm  = value_type( const container_type&amp;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::step </td>
          <td>(</td>
          <td class="paramtype">ODE &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>ode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a></td>          <td class="paramname"><span class="paramname"><em>t0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9b0066793e3a3e9d5159da5c12dfb4b3">container_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFunction</td>          <td class="paramname"><span class="paramname"><em>control</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorNorm</td>          <td class="paramname"><span class="paramname"><em>norm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a></td>          <td class="paramname"><span class="paramname"><em>rtol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a></td>          <td class="paramname"><span class="paramname"><em>atol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0">value_type</a></td>          <td class="paramname"><span class="paramname"><em>reject_limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Semi-implicit adaptive step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>initial time </td></tr>
    <tr><td class="paramname">u0</td><td>initial value at <code>t0</code> </td></tr>
    <tr><td class="paramname">t1</td><td>(write only) end time ( equals <code>t0+dt</code> on output if the step was accepted, otherwise equals <code>t0</code>, may alias <code>t0</code>) </td></tr>
    <tr><td class="paramname">u1</td><td>(write only) contains the updated result on output if the step was accepted, otherwise a copy of <code>u0</code> (may alias <code>u0</code>) </td></tr>
    <tr><td class="paramname">dt</td><td>on input: timestep On output: stepsize proposed by the controller that can be used to continue the integration in the next step.     </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ODE</td><td>The ExplicitRHS or tuple type that corresponds to what is inserted into the step member of the Stepper </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ode</td><td>rhs or tuple     </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ControlFunction</td><td>function or Functor called as dt' = <code>control</code>( {dt0, dt1, dt2}, {eps0, eps1, eps2}, embedded_order, order), where all parameters are of type value_type except the last two, which are unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>The control function. For explicit and imex methods, <code><a class="el" href="group__time__utils.html#ga3da5b4b68cceaf18e4c0dd80629d9bba">dg::pid_control</a></code> is a good choice with <code><a class="el" href="group__time__utils.html#ga32b696f59effe7da0f61b68275f6b180">dg::ex_control</a></code> or <code><a class="el" href="group__time__utils.html#ga3d078141617f2e4fe33df24f289ac6af" title="h_{n+1} = |ex_control| &lt; |im_control| ? ex_control : im_control">dg::imex_control</a></code> as an alternative if too many steps fail. For implicit methods use the <code><a class="el" href="group__time__utils.html#gacb1d6582ef865f0a098994190f13be15">dg::im_control</a></code>. The task of the control function is to compute a new timestep size based on the old timestep size, the order of the method and the past error(s). The behaviour of the controller is also changed by the <code>set_reject_limit</code> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ErrorNorm</td><td>function or Functor of type <a class="el" href="#a9f64c811c0abb1a6aa871d4bf7b868a0" title="the value type of the time variable defined by Stepper (float or double)">value_type( const
   ContainerType&amp;)</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>The error norm. Usually <code><a class="el" href="group__time__utils.html#ga40758fa443b6728e1499c7ee16820c17" title="Compute  using dg::blas1::dot.">dg::l2norm</a></code> is a good choice, but for very small vector sizes the time for the binary reproducible dot product might become a performance bottleneck. Then <code><a class="el" href="group__time__utils.html#gac821e1bd12a9e5c2917effafc86b16ad" title="Compute  using naive summation.">dg::fast_l2norm</a></code> is a better choice. </td></tr>
    <tr><td class="paramname">rtol</td><td>the desired relative accuracy. Usually 1e-5 is a good choice. </td></tr>
    <tr><td class="paramname">atol</td><td>the desired absolute accuracy. Usually 1e-7 is a good choice. </td></tr>
    <tr><td class="paramname">reject_limit</td><td>the default value is 2. Sometimes even 2 is not enough, for example when the stepsize fluctuates very much and the stepper fails often then it may help to increase the reject_limit further (to 10 say). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The error tolerance is computed such that on average every point in the solution vector fulfills \( |\delta_i| \approx r|u_i| + a\) </dd>
<dd>
Try not to mess with dt. The controller is best left alone and it does a very good job choosing timesteps. But how do I output my solution at certain (equidistant) timesteps? First, think about if you really, really need that. Why is it so bad to have output at non-equidistant timesteps? If you are still firm, then consider using an interpolation scheme (cf. <code><a class="el" href="structdg_1_1_extrapolation.html" title="Extrapolate a polynomial passing through up to three points.">dg::Extrapolation</a></code>). Let choosing the timestep yourself be the very last option if the others are not viable </dd>
<dd>
From Kennedy and Carpenter, Appl. num. Math., (2003): "Step-size control is a means by which accuracy, iteration, and to a lesser extent stability are controlled.
The choice of (t) may be chosen from many criteria, among those are the (t) from the accuracy
based step controller, the (t)_inviscid and (t)_viscous associated with the inviscid and viscous stability
limits of the ERK, and the (t)_iter associated with iteration convergence."</dd></dl>
<p>Our control method is an error based control method. However, due to the CFL (or other stability) condition there might be a sharp barrier in the range of possible stepsizes, i.e the stability limited timestep where the error sharply increses leading to a large number of rejected steps. The pid-controller usually does a good job keeping the timestep "just right" but in future work we may want to consider stability based control methods as well. Furthermore, for implicit or semi-implicit methods the chosen timestep influences how fast the iterative solver converges. If the timestep is too large the solver might take too long to converge and a smaller timestep might be preferable. Even for explicit methods where in each timestep an elliptic equation has to be solved the timestep may influence the convergence rate. Currently, there is no communication implemented between these solvers and the controller, but we may consider it in future releases. </p><dl class="section attention"><dt>Attention</dt><dd>When you use the <a class="el" href="structdg_1_1_a_r_k_step.html" title="Additive Runge Kutta (semi-implicit) time-step with error estimate following The ARKode library">ARKStep</a> in combination with the <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep ODE integration.">Adaptive</a> time step algorithm pay attention to solve the implicit part with sufficient accuracy. Else, the error propagates into the time controller, which will then choose the timestep as if the implicit part was explicit i.e. far too small. This might have to do with stiffness-leakage [Kennedy and Carpenter, Appl. num. Math., (2003)]: "An essential requirement for the viability of stiff/nonstiff IMEX schemes is that the stiffness remains
truely separable. If this were not the case then stiffness would leak out of the stiff terms and stiffen the
nonstiff terms. It would manifest itself as a loss in stability or a forced reduction in stepsize of the nonstiff
terms. A more expensive fully implicit approach might then be required, and hence, methods that leak
substantial stiffness might best be avoided". </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The exact values of <code>rtol</code> and <code>atol</code> might not be too important. However, don't make <code>rtol</code> too large, <code>1e-1</code> say, since then the controller might get too close to the CFL barrier. The timestepper is still able to crash, mind, even though the chances of that happening are somewhat lower than in a fixed stepsize method.    </dd></dl>

</div>
</div>
<a id="a2e1cb29ae32e9bc382f22790ca684645" name="a2e1cb29ae32e9bc382f22790ca684645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1cb29ae32e9bc382f22790ca684645">&#9670;&#160;</a></span>stepper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6c48d0d136681f6c6810e41538fb8771">stepper_type</a> &amp; <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::stepper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow write access to internal stepper. </p>
<p>Useful to set options in the stepper </p>

</div>
</div>
<a id="a19ab3bfa1165e9570018208c69405e6d" name="a19ab3bfa1165e9570018208c69405e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ab3bfa1165e9570018208c69405e6d">&#9670;&#160;</a></span>stepper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stepper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a6c48d0d136681f6c6810e41538fb8771">stepper_type</a> &amp; <a class="el" href="structdg_1_1_adaptive.html">dg::Adaptive</a>&lt; Stepper &gt;::stepper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read access to internal stepper. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="adaptive_8h_source.html">adaptive.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_adaptive.html">Adaptive</a></li>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:30 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
