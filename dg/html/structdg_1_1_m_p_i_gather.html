<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: dg::MPIGather&lt; Vector &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structdg_1_1_m_p_i_gather.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structdg_1_1_m_p_i_gather-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::MPIGather&lt; Vector &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__level1.html">Level 1: Vectors, Matrices and basic operations</a> &raquo; <a class="el" href="group__mpi__structures.html">MPI backend</a> &raquo; <a class="el" href="group__mpi__comm.html">MPI Distributed Gather and Scatter</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Optimized MPI Gather operation.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02d0b88f66cba478f2716e979a9043ed" id="r_a02d0b88f66cba478f2716e979a9043ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02d0b88f66cba478f2716e979a9043ed">MPIGather</a> (MPI_Comm comm=MPI_COMM_NULL)</td></tr>
<tr class="memdesc:a02d0b88f66cba478f2716e979a9043ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">no communication  <br /></td></tr>
<tr class="separator:a02d0b88f66cba478f2716e979a9043ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f01056cd134b425e1776f8c3305d236" id="r_a0f01056cd134b425e1776f8c3305d236"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f01056cd134b425e1776f8c3305d236">MPIGather</a> (const std::map&lt; int, thrust::host_vector&lt; int &gt; &gt; &amp;recvIdx, MPI_Comm comm)</td></tr>
<tr class="memdesc:a0f01056cd134b425e1776f8c3305d236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short for <code>MPIGather( recvIdx, 1, comm)</code>  <br /></td></tr>
<tr class="separator:a0f01056cd134b425e1776f8c3305d236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82af589ab59594b8f5c8453d35d193d" id="r_ab82af589ab59594b8f5c8453d35d193d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab82af589ab59594b8f5c8453d35d193d">MPIGather</a> (const std::map&lt; int, thrust::host_vector&lt; int &gt; &gt; &amp;recvIdx, unsigned chunk_size, MPI_Comm comm)</td></tr>
<tr class="memdesc:ab82af589ab59594b8f5c8453d35d193d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from global index map.  <br /></td></tr>
<tr class="separator:ab82af589ab59594b8f5c8453d35d193d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a79e61b73969024fde05d67e0d01053" id="r_a6a79e61b73969024fde05d67e0d01053"><td class="memTemplParams" colspan="2">template&lt;class ArrayVec  = thrust::host_vector&lt;std::array&lt;int,2&gt;&gt;, class IntVec  = thrust::host_vector&lt;int&gt;&gt; </td></tr>
<tr class="memitem:a6a79e61b73969024fde05d67e0d01053"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a79e61b73969024fde05d67e0d01053">MPIGather</a> (const ArrayVec &amp;gather_map, IntVec &amp;bufferIdx, MPI_Comm comm)</td></tr>
<tr class="memdesc:a6a79e61b73969024fde05d67e0d01053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsorted and possible duplicate global index list to unique stable_sorted by pid and duplicates map.  <br /></td></tr>
<tr class="separator:a6a79e61b73969024fde05d67e0d01053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a75b2c011a87e4847087545dbb7263" id="r_af5a75b2c011a87e4847087545dbb7263"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; typename OtherVector&gt; </td></tr>
<tr class="memitem:af5a75b2c011a87e4847087545dbb7263"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5a75b2c011a87e4847087545dbb7263">MPIGather</a> (const <a class="el" href="structdg_1_1_m_p_i_gather.html">MPIGather</a>&lt; OtherVector &gt; &amp;src)</td></tr>
<tr class="memdesc:af5a75b2c011a87e4847087545dbb7263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from other execution policy.  <br /></td></tr>
<tr class="separator:af5a75b2c011a87e4847087545dbb7263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad816041b91d4a1ab95a952e4c85fdab5" id="r_ad816041b91d4a1ab95a952e4c85fdab5"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad816041b91d4a1ab95a952e4c85fdab5">communicator</a> () const</td></tr>
<tr class="memdesc:ad816041b91d4a1ab95a952e4c85fdab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal MPI communicator used.  <br /></td></tr>
<tr class="separator:ad816041b91d4a1ab95a952e4c85fdab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adab0e74aa769dc22212aee72b7ad7e" id="r_a9adab0e74aa769dc22212aee72b7ad7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9adab0e74aa769dc22212aee72b7ad7e">isContiguous</a> () const</td></tr>
<tr class="memdesc:a9adab0e74aa769dc22212aee72b7ad7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the message from the constructor is contiguous in memory.  <br /></td></tr>
<tr class="separator:a9adab0e74aa769dc22212aee72b7ad7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3d1870248db75615a396d051cd4715" id="r_a1f3d1870248db75615a396d051cd4715"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f3d1870248db75615a396d051cd4715">buffer_size</a> () const</td></tr>
<tr class="memdesc:a1f3d1870248db75615a396d051cd4715"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local size of the buffer vector w = local map size.  <br /></td></tr>
<tr class="separator:a1f3d1870248db75615a396d051cd4715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf42bff3781f7c043af2963e5e8c7f40" id="r_adf42bff3781f7c043af2963e5e8c7f40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf42bff3781f7c043af2963e5e8c7f40">isCommunicating</a> () const</td></tr>
<tr class="memdesc:adf42bff3781f7c043af2963e5e8c7f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the gather/scatter operation involves actual MPI communication.  <br /></td></tr>
<tr class="separator:adf42bff3781f7c043af2963e5e8c7f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e23c6348d94ba49c33a9563bde549f" id="r_a10e23c6348d94ba49c33a9563bde549f"><td class="memTemplParams" colspan="2">template&lt;class ContainerType0 , class ContainerType1 &gt; </td></tr>
<tr class="memitem:a10e23c6348d94ba49c33a9563bde549f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a10e23c6348d94ba49c33a9563bde549f">global_gather_init</a> (const ContainerType0 &amp;gatherFrom, ContainerType1 &amp;buffer) const</td></tr>
<tr class="memdesc:a10e23c6348d94ba49c33a9563bde549f"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( w&#39; = P_{G,MPI} G_2 v\). Globally (across processes) asynchronously gather data into a buffer  <br /></td></tr>
<tr class="separator:a10e23c6348d94ba49c33a9563bde549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac654e7507db89a32a96ba4bff068cafb" id="r_ac654e7507db89a32a96ba4bff068cafb"><td class="memTemplParams" colspan="2">template&lt;class ContainerType &gt; </td></tr>
<tr class="memitem:ac654e7507db89a32a96ba4bff068cafb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac654e7507db89a32a96ba4bff068cafb">global_gather_wait</a> (ContainerType &amp;buffer) const</td></tr>
<tr class="memdesc:ac654e7507db89a32a96ba4bff068cafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for asynchronous communication to finish and gather received data into buffer.  <br /></td></tr>
<tr class="separator:ac654e7507db89a32a96ba4bff068cafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac17681ac5deceaa1655cf7aaa551efe7" id="r_ac17681ac5deceaa1655cf7aaa551efe7"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class OtherVector&gt; </td></tr>
<tr class="memitem:ac17681ac5deceaa1655cf7aaa551efe7"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac17681ac5deceaa1655cf7aaa551efe7">MPIGather</a></td></tr>
<tr class="memdesc:ac17681ac5deceaa1655cf7aaa551efe7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://stackoverflow.com/questions/26147061/how-to-share-protected-members-between-c-template-classes">https://stackoverflow.com/questions/26147061/how-to-share-protected-members-between-c-template-classes</a>  <br /></td></tr>
<tr class="separator:ac17681ac5deceaa1655cf7aaa551efe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;template&lt; class &gt; class Vector&gt;<br />
struct dg::MPIGather&lt; Vector &gt;</div><p>Optimized MPI Gather operation. </p>
<p>This class stores the communication pattern given in its constructor and derives an optimized MPI communication to implement it.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>a thrust Vector e.g. <code>thrust::host_vector</code> or <code>thrust::device_vector</code> Determines the internal buffer type of the \( G_2\) gather operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mpi__comm.html#mpigather">MPI distributed gather and scatter operations</a> A un-optimized version is available in <code><a class="el" href="group__mpi__comm.html#ga05dfb8393768dc9fe68f8ae1baca2b68" title="Un-optimized distributed gather operation.">dg::mpi_gather</a></code> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a02d0b88f66cba478f2716e979a9043ed" name="a02d0b88f66cba478f2716e979a9043ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d0b88f66cba478f2716e979a9043ed">&#9670;&#160;</a></span>MPIGather() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_m_p_i_gather.html">dg::MPIGather</a>&lt; Vector &gt;::MPIGather </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">MPI_COMM_NULL</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>no communication </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>optional MPI communicator: the purpose is to be able to store MPI communicator even if no communication is involved in order to construct <a class="el" href="structdg_1_1_m_p_i___vector.html" title="A simple wrapper around a container object and an MPI_Comm.">MPI_Vector</a> with it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f01056cd134b425e1776f8c3305d236" name="a0f01056cd134b425e1776f8c3305d236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f01056cd134b425e1776f8c3305d236">&#9670;&#160;</a></span>MPIGather() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_m_p_i_gather.html">dg::MPIGather</a>&lt; Vector &gt;::MPIGather </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, thrust::host_vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>recvIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short for <code>MPIGather( recvIdx, 1, comm)</code> </p>

</div>
</div>
<a id="ab82af589ab59594b8f5c8453d35d193d" name="ab82af589ab59594b8f5c8453d35d193d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82af589ab59594b8f5c8453d35d193d">&#9670;&#160;</a></span>MPIGather() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_m_p_i_gather.html">dg::MPIGather</a>&lt; Vector &gt;::MPIGather </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, thrust::host_vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>recvIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>chunk_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from global index map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recvIdx</td><td>recvIdx[PID] consists of the local indices on PID that the calling process receives from that PID ( = gather map) </td></tr>
    <tr><td class="paramname">chunk_size</td><td>If the communication pattern consists of equally sized chunks one can specify in <code>recvIdx</code> only the starting indices of each chunk and use <code>chunk_size</code> to specify how many indices should be sent </td></tr>
    <tr><td class="paramname">comm</td><td>The MPI communicator participating in the gather operations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Messages will be received in <code>buffer</code> in the order that <code>for(
auto&amp; msg : recvIdx)</code> is unrolled </dd></dl>

</div>
</div>
<a id="a6a79e61b73969024fde05d67e0d01053" name="a6a79e61b73969024fde05d67e0d01053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a79e61b73969024fde05d67e0d01053">&#9670;&#160;</a></span>MPIGather() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<div class="memtemplate">
template&lt;class ArrayVec  = thrust::host_vector&lt;std::array&lt;int,2&gt;&gt;, class IntVec  = thrust::host_vector&lt;int&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_m_p_i_gather.html">dg::MPIGather</a>&lt; Vector &gt;::MPIGather </td>
          <td>(</td>
          <td class="paramtype">const ArrayVec &amp;</td>          <td class="paramname"><span class="paramname"><em>gather_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntVec &amp;</td>          <td class="paramname"><span class="paramname"><em>bufferIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an unsorted and possible duplicate global index list to unique stable_sorted by pid and duplicates map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gather_map</td><td>Each element consists of <code>{rank, local index on that rank}</code> pairs, which is equivalent to the global address of a vector element in <code>gatherFrom</code>. <code>gather_map</code> can be unsorted and contain duplicate entries. The implementation will only send the unique indices through the network. </td></tr>
    <tr><td class="paramname">bufferIdx</td><td>(Write only) On output resized to <code>gather_map.size()</code>. On output contains index into the resulting buffer vector in <code>global_gather_init</code> and <code>global_gather_wait</code> that corresponds to the requested <code>gather_map</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>bufferIdx</code> is the index map for \( G_1\) in <a class="el" href="group__mpi__comm.html#mpi_dist_gather">MPI distributed gather and scatter</a> If <code>gather_map</code> stems from the column indices of a row distributed matrix then <code>bufferIdx</code> becomes the new column index of that matrix acting on the local <code>buffer</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The MPI communicator participating in the gather operations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5a75b2c011a87e4847087545dbb7263" name="af5a75b2c011a87e4847087545dbb7263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a75b2c011a87e4847087545dbb7263">&#9670;&#160;</a></span>MPIGather() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename OtherVector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_m_p_i_gather.html">dg::MPIGather</a>&lt; Vector &gt;::MPIGather </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_m_p_i_gather.html">MPIGather</a>&lt; OtherVector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from other execution policy. </p>
<p>This makes it possible to construct an object on the host and then copy everything on to a device </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherVector</td><td>other container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1f3d1870248db75615a396d051cd4715" name="a1f3d1870248db75615a396d051cd4715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3d1870248db75615a396d051cd4715">&#9670;&#160;</a></span>buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_m_p_i_gather.html">dg::MPIGather</a>&lt; Vector &gt;::buffer_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The local size of the buffer vector w = local map size. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer size (may be different for each process) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>may return 0, which just means that the calling rank does not receive any data from any other rank including itself. The calling rank may still need to <b>send</b> data in <code>global_gather_init</code> </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>It is therfore not valid to check for zero buffer size if you want to find out whether a given rank needs to send MPI messages or not. The right way to do it is to call <code><a class="el" href="#adf42bff3781f7c043af2963e5e8c7f40" title="True if the gather/scatter operation involves actual MPI communication.">isCommunicating()</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#adf42bff3781f7c043af2963e5e8c7f40" title="True if the gather/scatter operation involves actual MPI communication.">isCommunicating()</a> </dd></dl>

</div>
</div>
<a id="ad816041b91d4a1ab95a952e4c85fdab5" name="ad816041b91d4a1ab95a952e4c85fdab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad816041b91d4a1ab95a952e4c85fdab5">&#9670;&#160;</a></span>communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm <a class="el" href="structdg_1_1_m_p_i_gather.html">dg::MPIGather</a>&lt; Vector &gt;::communicator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal MPI communicator used. </p>
<dl class="section return"><dt>Returns</dt><dd>MPI Communicator </dd></dl>

</div>
</div>
<a id="a10e23c6348d94ba49c33a9563bde549f" name="a10e23c6348d94ba49c33a9563bde549f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e23c6348d94ba49c33a9563bde549f">&#9670;&#160;</a></span>global_gather_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<div class="memtemplate">
template&lt;class ContainerType0 , class ContainerType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_m_p_i_gather.html">dg::MPIGather</a>&lt; Vector &gt;::global_gather_init </td>
          <td>(</td>
          <td class="paramtype">const ContainerType0 &amp;</td>          <td class="paramname"><span class="paramname"><em>gatherFrom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( w&#39; = P_{G,MPI} G_2 v\). Globally (across processes) asynchronously gather data into a buffer </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Can be any shared vector container on host or device, e.g.<ul>
<li>thrust::host_vector&lt;double&gt;</li>
<li>thrust::device_vector&lt;double&gt;</li>
<li>thrust::device_vector&lt;thrust::complex&lt;double&gt;&gt;</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gatherFrom</td><td>source vector v; data is collected from this vector </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer vector w, must have <code><a class="el" href="#a1f3d1870248db75615a396d051cd4715" title="The local size of the buffer vector w = local map size.">buffer_size()</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>It is <b>unsafe</b> to write values to <code>gatherFrom</code> or to read values in <code>buffer</code> until <code>global_gather_wait</code> has been called </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code> !isCommunicating() </code> then this call will not involve MPI communication but will still gather values according to the given index map </dd></dl>

</div>
</div>
<a id="ac654e7507db89a32a96ba4bff068cafb" name="ac654e7507db89a32a96ba4bff068cafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac654e7507db89a32a96ba4bff068cafb">&#9670;&#160;</a></span>global_gather_wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_m_p_i_gather.html">dg::MPIGather</a>&lt; Vector &gt;::global_gather_wait </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for asynchronous communication to finish and gather received data into buffer. </p>
<p>Call <code>MPI_Waitall</code> on internal <code>MPI_Request</code> variables and manage host memory in case of cuda-unaware MPI. After this call returns it is safe to use the buffer and the <code>gatherFrom</code> variable from the corresponding <code>global_gather_init</code> call </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>(write only) where received data resides on return; must be identical to the one given in a previous call to <code><a class="el" href="#a10e23c6348d94ba49c33a9563bde549f" title=". Globally (across processes) asynchronously gather data into a buffer">global_gather_init()</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf42bff3781f7c043af2963e5e8c7f40" name="adf42bff3781f7c043af2963e5e8c7f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf42bff3781f7c043af2963e5e8c7f40">&#9670;&#160;</a></span>isCommunicating()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structdg_1_1_m_p_i_gather.html">dg::MPIGather</a>&lt; Vector &gt;::isCommunicating </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the gather/scatter operation involves actual MPI communication. </p>
<p>This is more than just a test for zero message size. This is because even if a process has zero message size indicating that it technically does not need to send any data at all it might still need to participate in an MPI communication (sending an empty message to indicate that a certain point in execution has been reached). Only if <b>none</b> of the processes in the process group has anything to send will this function return false. This test can be used to avoid the gather operation alltogether in e.g. the construction of a MPI distributed matrix. </p><dl class="section note"><dt>Note</dt><dd>this check involves MPI communication itself, because a process needs to check if itself or any other process in its group is communicating.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>False, if the global gather can be done without MPI communication (i.e. the indices are all local to each calling process), or if the communicator is <code>MPI_COMM_NULL</code>. True else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1f3d1870248db75615a396d051cd4715" title="The local size of the buffer vector w = local map size.">buffer_size()</a> </dd></dl>

</div>
</div>
<a id="a9adab0e74aa769dc22212aee72b7ad7e" name="a9adab0e74aa769dc22212aee72b7ad7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adab0e74aa769dc22212aee72b7ad7e">&#9670;&#160;</a></span>isContiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structdg_1_1_m_p_i_gather.html">dg::MPIGather</a>&lt; Vector &gt;::isContiguous </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the message from the constructor is contiguous in memory. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="ac17681ac5deceaa1655cf7aaa551efe7" name="ac17681ac5deceaa1655cf7aaa551efe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17681ac5deceaa1655cf7aaa551efe7">&#9670;&#160;</a></span>MPIGather</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Vector&gt; </div>
<div class="memtemplate">
template&lt;template&lt; class &gt; class OtherVector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="structdg_1_1_m_p_i_gather.html">MPIGather</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a href="https://stackoverflow.com/questions/26147061/how-to-share-protected-members-between-c-template-classes">https://stackoverflow.com/questions/26147061/how-to-share-protected-members-between-c-template-classes</a> </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>backend/<a class="el" href="mpi__gather_8h_source.html">mpi_gather.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_m_p_i_gather.html">MPIGather</a></li>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:30 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
