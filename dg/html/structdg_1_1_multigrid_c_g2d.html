<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: dg::MultigridCG2d&lt; Geometry, Matrix, Container &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structdg_1_1_multigrid_c_g2d.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1_multigrid_c_g2d-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::MultigridCG2d&lt; Geometry, Matrix, Container &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__lvel4.html">Level 4: Advanced numerical schemes</a> &raquo; <a class="el" href="group__multigrid.html">Multigrid matrix inversion</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Solve.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9f15aac16dcdb67f310e0af621b538c7" id="r_a9f15aac16dcdb67f310e0af621b538c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f15aac16dcdb67f310e0af621b538c7">geometry_type</a> = Geometry</td></tr>
<tr class="separator:a9f15aac16dcdb67f310e0af621b538c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb757d36ec9ffe31587b3d93796e6b94" id="r_aeb757d36ec9ffe31587b3d93796e6b94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb757d36ec9ffe31587b3d93796e6b94">matrix_type</a> = <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a></td></tr>
<tr class="separator:aeb757d36ec9ffe31587b3d93796e6b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4241083bbf815e345cbbe751e4e6d44" id="r_ae4241083bbf815e345cbbe751e4e6d44"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4241083bbf815e345cbbe751e4e6d44">container_type</a> = <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a></td></tr>
<tr class="separator:ae4241083bbf815e345cbbe751e4e6d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cc3f8e39468ef4b723d00e11b48601" id="r_a31cc3f8e39468ef4b723d00e11b48601"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> = <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt;<a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a>&gt;</td></tr>
<tr class="separator:a31cc3f8e39468ef4b723d00e11b48601"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3c3d40a6ad39eb0e86660f2a741b28b" id="r_ab3c3d40a6ad39eb0e86660f2a741b28b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3c3d40a6ad39eb0e86660f2a741b28b">MultigridCG2d</a> ()=default</td></tr>
<tr class="memdesc:ab3c3d40a6ad39eb0e86660f2a741b28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate nothing, Call <code>construct</code> method before usage.  <br /></td></tr>
<tr class="separator:ab3c3d40a6ad39eb0e86660f2a741b28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b81ed041ab30de75fdef268a070aaf" id="r_a93b81ed041ab30de75fdef268a070aaf"><td class="memTemplParams" colspan="2">template&lt;class ... ContainerParams&gt; </td></tr>
<tr class="memitem:a93b81ed041ab30de75fdef268a070aaf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a93b81ed041ab30de75fdef268a070aaf">MultigridCG2d</a> (const Geometry &amp;<a class="el" href="#a9ec06f651ee1bbbe873ee5828e508d42">grid</a>, const unsigned <a class="el" href="#a7659e4d18315604a75b8f92f4266aba1">stages</a>, ContainerParams &amp;&amp;... ps)</td></tr>
<tr class="memdesc:a93b81ed041ab30de75fdef268a070aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the grids and the interpolation/projection operators.  <br /></td></tr>
<tr class="separator:a93b81ed041ab30de75fdef268a070aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c55c73ccca5ff891a977000da9612e8" id="r_a8c55c73ccca5ff891a977000da9612e8"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:a8c55c73ccca5ff891a977000da9612e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c55c73ccca5ff891a977000da9612e8">construct</a> (Params &amp;&amp;...ps)</td></tr>
<tr class="memdesc:a8c55c73ccca5ff891a977000da9612e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect forward parameters to one of the constructors.  <br /></td></tr>
<tr class="separator:a8c55c73ccca5ff891a977000da9612e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84635b2d0487a62a6a8d3b2d79ee2775" id="r_a84635b2d0487a62a6a8d3b2d79ee2775"><td class="memTemplParams" colspan="2">template&lt;class ContainerType0 &gt; </td></tr>
<tr class="memitem:a84635b2d0487a62a6a8d3b2d79ee2775"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a84635b2d0487a62a6a8d3b2d79ee2775">project</a> (const ContainerType0 &amp;src, std::vector&lt; ContainerType0 &gt; &amp;out) const</td></tr>
<tr class="memdesc:a84635b2d0487a62a6a8d3b2d79ee2775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project vector to all involved grids.     <br /></td></tr>
<tr class="separator:a84635b2d0487a62a6a8d3b2d79ee2775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6664fcdea24d532ccbdd91577b3789a" id="r_ad6664fcdea24d532ccbdd91577b3789a"><td class="memTemplParams" colspan="2">template&lt;class ContainerType0 &gt; </td></tr>
<tr class="memitem:ad6664fcdea24d532ccbdd91577b3789a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ContainerType0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6664fcdea24d532ccbdd91577b3789a">project</a> (const ContainerType0 &amp;src) const</td></tr>
<tr class="memdesc:ad6664fcdea24d532ccbdd91577b3789a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project vector to all involved grids (allocate memory version)     <br /></td></tr>
<tr class="separator:ad6664fcdea24d532ccbdd91577b3789a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7659e4d18315604a75b8f92f4266aba1" id="r_a7659e4d18315604a75b8f92f4266aba1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7659e4d18315604a75b8f92f4266aba1">stages</a> () const</td></tr>
<tr class="separator:a7659e4d18315604a75b8f92f4266aba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec75fbb948aa597f8d7c227a395028f" id="r_adec75fbb948aa597f8d7c227a395028f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adec75fbb948aa597f8d7c227a395028f">num_stages</a> () const</td></tr>
<tr class="separator:adec75fbb948aa597f8d7c227a395028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec06f651ee1bbbe873ee5828e508d42" id="r_a9ec06f651ee1bbbe873ee5828e508d42"><td class="memItemLeft" align="right" valign="top">const Geometry &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ec06f651ee1bbbe873ee5828e508d42">grid</a> (unsigned stage) const</td></tr>
<tr class="memdesc:a9ec06f651ee1bbbe873ee5828e508d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the grid at given stage  <br /></td></tr>
<tr class="separator:a9ec06f651ee1bbbe873ee5828e508d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94f4c33e61798f03fc0241e76c54efa" id="r_ab94f4c33e61798f03fc0241e76c54efa"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab94f4c33e61798f03fc0241e76c54efa">max_iter</a> () const</td></tr>
<tr class="separator:ab94f4c33e61798f03fc0241e76c54efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a9e3acbd2d7aa1373f48d9e69daaa4" id="r_aa7a9e3acbd2d7aa1373f48d9e69daaa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7a9e3acbd2d7aa1373f48d9e69daaa4">set_max_iter</a> (unsigned new_max)</td></tr>
<tr class="memdesc:aa7a9e3acbd2d7aa1373f48d9e69daaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of iterations allowed at stage 0.  <br /></td></tr>
<tr class="separator:aa7a9e3acbd2d7aa1373f48d9e69daaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf980680f992d4ce0436797137dfe5f7" id="r_abf980680f992d4ce0436797137dfe5f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf980680f992d4ce0436797137dfe5f7">set_benchmark</a> (bool benchmark, std::string message=&quot;Nested Iterations&quot;)</td></tr>
<tr class="memdesc:abf980680f992d4ce0436797137dfe5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or unset performance timings during iterations.  <br /></td></tr>
<tr class="separator:abf980680f992d4ce0436797137dfe5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772e344e89b5ba41aaef812b420358a2" id="r_a772e344e89b5ba41aaef812b420358a2"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a772e344e89b5ba41aaef812b420358a2">copyable</a> () const</td></tr>
<tr class="memdesc:a772e344e89b5ba41aaef812b420358a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an object of same size as the object used for construction on the finest grid.  <br /></td></tr>
<tr class="separator:a772e344e89b5ba41aaef812b420358a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380edecea9ec4c9afbd93f8454298535" id="r_a380edecea9ec4c9afbd93f8454298535"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType0 , class ContainerType1 &gt; </td></tr>
<tr class="memitem:a380edecea9ec4c9afbd93f8454298535"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a380edecea9ec4c9afbd93f8454298535">solve</a> (std::vector&lt; MatrixType &gt; &amp;ops, ContainerType0 &amp;x, const ContainerType1 &amp;b, <a class="el" href="#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> eps)</td></tr>
<tr class="memdesc:a380edecea9ec4c9afbd93f8454298535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested iterations.  <br /></td></tr>
<tr class="separator:a380edecea9ec4c9afbd93f8454298535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109d894a8e283f68594e2b1d02bed6fc" id="r_a109d894a8e283f68594e2b1d02bed6fc"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType0 , class ContainerType1 &gt; </td></tr>
<tr class="memitem:a109d894a8e283f68594e2b1d02bed6fc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a109d894a8e283f68594e2b1d02bed6fc">solve</a> (std::vector&lt; MatrixType &gt; &amp;ops, ContainerType0 &amp;x, const ContainerType1 &amp;b, std::vector&lt; <a class="el" href="#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> &gt; eps)</td></tr>
<tr class="memdesc:a109d894a8e283f68594e2b1d02bed6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested iterations.     <br /></td></tr>
<tr class="separator:a109d894a8e283f68594e2b1d02bed6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Geometry, class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a>&gt;<br />
struct dg::MultigridCG2d&lt; Geometry, Matrix, Container &gt;</div><p>Solve. </p>
<p class="formulaDsp">
\[ \hat O \phi = \rho \]
</p>
<p> for self-adjoint \(\hat O\)</p>
<p>using <code><a class="el" href="group__multigrid.html#gaa72ab35001decd5c7c6bf39a68df46a8" title="Full approximation nested iterations.">dg::nested_iterations</a></code> with <code><a class="el" href="classdg_1_1_p_c_g.html" title="Preconditioned conjugate gradient method to solve .">dg::PCG</a></code> solvers for any operator \(\hat O\) that is self-adjoint in appropriate weights \(W\) We refine the grids in the first two dimensions (2d / x and y) </p><dl class="section note"><dt>Note</dt><dd>The <code><a class="el" href="group__matrixoperators.html#gaab490c246f9f3c1ec07cfbb103a5fd51" title="A 2d negative elliptic differential operator .">dg::Elliptic</a></code> and <code><a class="el" href="group__matrixoperators.html#ga6d1fefb3e2aa6cda372f560763e5d19b" title="a 2d Helmholtz opereator  with">dg::Helmholtz</a></code> classes are self-adjoint so these are the intended target operators. </dd>
<dd>
The preconditioner and weights for the <code><a class="el" href="classdg_1_1_p_c_g.html" title="Preconditioned conjugate gradient method to solve .">dg::PCG</a></code> solver are taken from the <code>precond()</code> and <code>weights()</code> method in the <code>MatrixType</code> class</dd></dl>
<div class="fragment"><div class="line">    <a class="code hl_struct" href="structdg_1_1_timer.html">dg::Timer</a> t;</div>
<div class="line">    t.<a class="code hl_function" href="structdg_1_1_timer.html#ad158907d0e4a975b832fed780d7b4655">tic</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structdg_1_1_real_cartesian_m_p_i_grid2d.html">dg::x::CartesianGrid2d</a> grid( 0, lx, 0, ly, n, Nx, Ny, bcx, bcy</div>
<div class="line">#ifdef WITH_MPI</div>
<div class="line">            , comm2d</div>
<div class="line">#endif</div>
<div class="line">            );</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> stages = 3;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d&lt;dg::x::aGeometry2d, dg::x::DMatrix, dg::x::DVec &gt;</a></div>
<div class="line">        multigrid( grid, stages);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structdg_1_1_m_p_i___vector.html">dg::x::DVec</a> chi =  <a class="code hl_function" href="group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">dg::evaluate</a>( pol, grid);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;dg::x::DVec&gt; multi_chi = multigrid.project( chi);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;dg::Elliptic&lt;dg::x::aGeometry2d, dg::x::DMatrix, dg::x::DVec&gt; &gt;</div>
<div class="line">        multi_pol( stages);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> u=0; u&lt;stages; u++)</div>
<div class="line">    {</div>
<div class="line">        multi_pol[u].construct( multigrid.grid(u), <a class="code hl_enumvalue" href="group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">dg::centered</a>, jfactor);</div>
<div class="line">        <span class="comment">//this tests if elliptic can recover from NaN in the preconditioner</span></div>
<div class="line">        multi_pol[u].set_chi(0.);</div>
<div class="line">        <span class="comment">// here we test if we can set the tensor part in elliptic</span></div>
<div class="line">        multi_pol[u].set_chi( multigrid.grid(u).metric());</div>
<div class="line">        <span class="comment">// now set the actual scalar part in chi</span></div>
<div class="line">        multi_pol[u].set_chi( multi_chi[u]);</div>
<div class="line">        multi_pol[u].set_jump_weighting(jump_weight);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    t.<a class="code hl_function" href="structdg_1_1_timer.html#a3c1a18f62626dcfaf728c2b490a64a43">toc</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="typedefs_8h.html#a9bd65eeee6a3f95f56935d1a3f7b2d76">DG_RANK0</a> std::cout &lt;&lt; <span class="stringliteral">&quot;Creation of multigrid took: &quot;</span>&lt;&lt;t.<a class="code hl_function" href="structdg_1_1_timer.html#a27a84dc8acb525e9617cd34d64aad4ed">diff</a>()&lt;&lt;<span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structdg_1_1_m_p_i___vector.html">dg::x::DVec</a> b =    <a class="code hl_function" href="group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">dg::evaluate</a>( rhs,     grid);</div>
<div class="line">    <a class="code hl_struct" href="structdg_1_1_m_p_i___vector.html">dg::x::DVec</a> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>       =    <a class="code hl_function" href="group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">dg::evaluate</a>( initial, grid);</div>
<div class="line">    t.<a class="code hl_function" href="structdg_1_1_timer.html#ad158907d0e4a975b832fed780d7b4655">tic</a>();</div>
<div class="line">    std::vector&lt;unsigned&gt; number = multigrid.solve(multi_pol, x, b, {eps, 1.5*eps, 1.5*eps});</div>
<div class="line">    t.<a class="code hl_function" href="structdg_1_1_timer.html#a3c1a18f62626dcfaf728c2b490a64a43">toc</a>();</div>
<div class="line">    <a class="code hl_define" href="typedefs_8h.html#a9bd65eeee6a3f95f56935d1a3f7b2d76">DG_RANK0</a> std::cout &lt;&lt; <span class="stringliteral">&quot;Solution took &quot;</span>&lt;&lt; t.<a class="code hl_function" href="structdg_1_1_timer.html#a27a84dc8acb525e9617cd34d64aad4ed">diff</a>() &lt;&lt;<span class="stringliteral">&quot;s\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> u=0; u&lt;number.size(); u++)</div>
<div class="line">        <a class="code hl_define" href="typedefs_8h.html#a9bd65eeee6a3f95f56935d1a3f7b2d76">DG_RANK0</a> std::cout &lt;&lt; <span class="stringliteral">&quot; # iterations stage &quot;</span>&lt;&lt; number.size()-1-u &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; number[number.size()-1-u] &lt;&lt; <span class="stringliteral">&quot; \n&quot;</span>;</div>
</div><!-- fragment -->  <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>A type that is or derives from one of the abstract geometry base classes ( <code>aGeometry2d</code>, <code>aGeometry3d</code>, <code>aMPIGeometry2d</code>, ...). <code>Geometry</code> determines which <code>Matrix</code> and <code>Container</code> types can be used: </td></tr>
    <tr><td class="paramname">Matrix</td><td>A class for which the <code><a class="el" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a></code> functions are callable in connection with the <code>Container</code> class and to which the return type of <code><a class="el" href="group__creation.html#ga1899853dcfaa261709bded73dd40b1df">dg::create::dx()</a></code> can be converted using <code><a class="el" href="group__blas2.html#ga53701ba3118a2256a93a4d92a7a8a597" title="; Generic way to copy and/or convert a Matrix type to a different Matrix type">dg::blas2::transfer</a></code>. The <code>Matrix</code> type can be one of:<ul>
<li><code><a class="el" href="group__typedefs.html#gae8a29dbadfe53ca55ab6a5b0b417ac2a" title="Host Matrix for derivatives.">dg::HMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#ga70cec5715da312a590711436b8b125ff" title="Device Matrix for derivatives.">dg::DMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> and one of the shared memory geometries</li>
<li><code><a class="el" href="group__typedefs.html#ga5511f10a68d58cbd28067c9dbae45977" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> and one of the MPI geometries</li>
<li><code><a class="el" href="group__typedefs.html#gaa86748811132d3c72c739710777d2b39" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> and one of the MPI geometries </li>
</ul>
</td></tr>
    <tr><td class="paramname">Container</td><td>A data container class for which the <code><a class="el" href="namespacedg_1_1blas1.html" title="BLAS Level 1 routines.">blas1</a></code> functionality is overloaded and to which the return type of <code><a class="el" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5" title="; Customizable and generic blas1 function">blas1::subroutine()</a></code> can be converted using <code><a class="el" href="group__blas1.html#gab0ca1b8d3f70004e25ddc2010f7e9e0d" title="Generic way to assign the contents of a from_ContainerType object to a ContainerType object optionall...">dg::assign</a></code>. We assume that <code>Container</code> is copyable/assignable and has a swap member function. In connection with <code>Geometry</code> this is one of<ul>
<li><code><a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a></code>, <code><a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> when <code>Geometry</code> is a shared memory geometry</li>
<li><code><a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code><a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> when <code>Geometry</code> is one of the MPI geometries    </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structdg_1_1_extrapolation.html" title="Extrapolate a polynomial passing through up to three points.">Extrapolation</a></code> <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> generate an <a class="elRef" href="../../matrix/html/tensorelliptic2d__b_8cpp.html#a8476723b52f7482a3dd190cead682425">initial</a> guess </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae4241083bbf815e345cbbe751e4e6d44" name="ae4241083bbf815e345cbbe751e4e6d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4241083bbf815e345cbbe751e4e6d44">&#9670;&#160;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::container_type = <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f15aac16dcdb67f310e0af621b538c7" name="a9f15aac16dcdb67f310e0af621b538c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f15aac16dcdb67f310e0af621b538c7">&#9670;&#160;</a></span>geometry_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::geometry_type = Geometry</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb757d36ec9ffe31587b3d93796e6b94" name="aeb757d36ec9ffe31587b3d93796e6b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb757d36ec9ffe31587b3d93796e6b94">&#9670;&#160;</a></span>matrix_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::matrix_type = <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31cc3f8e39468ef4b723d00e11b48601" name="a31cc3f8e39468ef4b723d00e11b48601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cc3f8e39468ef4b723d00e11b48601">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">::value_type</a> = <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt;<a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3c3d40a6ad39eb0e86660f2a741b28b" name="ab3c3d40a6ad39eb0e86660f2a741b28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c3d40a6ad39eb0e86660f2a741b28b">&#9670;&#160;</a></span>MultigridCG2d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::MultigridCG2d </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate nothing, Call <code>construct</code> method before usage. </p>

</div>
</div>
<a id="a93b81ed041ab30de75fdef268a070aaf" name="a93b81ed041ab30de75fdef268a070aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b81ed041ab30de75fdef268a070aaf">&#9670;&#160;</a></span>MultigridCG2d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<div class="memtemplate">
template&lt;class ... ContainerParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::MultigridCG2d </td>
          <td>(</td>
          <td class="paramtype">const Geometry &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned</td>          <td class="paramname"><span class="paramname"><em>stages</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerParams &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the grids and the interpolation/projection operators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the original grid (Nx() and Ny() must be evenly divisable by pow(2, stages-1) </td></tr>
    <tr><td class="paramname">stages</td><td>number of grids in total (The second grid contains half the points of the original grids, The third grid contains half of the second grid ...). Must be &gt;= 1. A good number to start is 3. </td></tr>
    <tr><td class="paramname">ps</td><td>parameters necessary for <code><a class="el" href="group__blas1.html#ga5dbfc632d4d66d2d926dd525ed7fcea8" title="Generic way to construct an object of ContainerType given a from_ContainerType object and optional ad...">dg::construct</a></code> to construct a <code>Container</code> from a <code><a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8c55c73ccca5ff891a977000da9612e8" name="a8c55c73ccca5ff891a977000da9612e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c55c73ccca5ff891a977000da9612e8">&#9670;&#160;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect forward parameters to one of the constructors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>parameters forwarded to constructors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a772e344e89b5ba41aaef812b420358a2" name="a772e344e89b5ba41aaef812b420358a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772e344e89b5ba41aaef812b420358a2">&#9670;&#160;</a></span>copyable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &amp; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::copyable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an object of same size as the object used for construction on the finest grid. </p>
<dl class="section return"><dt>Returns</dt><dd>A copyable object; what it contains is undefined, its size is important </dd></dl>

</div>
</div>
<a id="a9ec06f651ee1bbbe873ee5828e508d42" name="a9ec06f651ee1bbbe873ee5828e508d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec06f651ee1bbbe873ee5828e508d42">&#9670;&#160;</a></span>grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Geometry &amp; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::grid </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>stage</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the grid at given stage </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>must fulfill <code>0</code> &lt;= stage &lt; <a class="el" href="#a7659e4d18315604a75b8f92f4266aba1">stages()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab94f4c33e61798f03fc0241e76c54efa" name="ab94f4c33e61798f03fc0241e76c54efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94f4c33e61798f03fc0241e76c54efa">&#9670;&#160;</a></span>max_iter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::max_iter </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum number of iterations allowed at stage 0 (if the solution method returns this number, failure is indicated) </p>

</div>
</div>
<a id="adec75fbb948aa597f8d7c227a395028f" name="adec75fbb948aa597f8d7c227a395028f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec75fbb948aa597f8d7c227a395028f">&#9670;&#160;</a></span>num_stages()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::num_stages </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of stages (same as <code>stages</code>) </dd></dl>

</div>
</div>
<a id="ad6664fcdea24d532ccbdd91577b3789a" name="ad6664fcdea24d532ccbdd91577b3789a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6664fcdea24d532ccbdd91577b3789a">&#9670;&#160;</a></span>project() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<div class="memtemplate">
template&lt;class ContainerType0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ContainerType0 &gt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::project </td>
          <td>(</td>
          <td class="paramtype">const ContainerType0 &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project vector to all involved grids (allocate memory version)    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input vector projected to all grids ( index 0 contains a copy of src, 1 is the projetion to the first coarse grid, 2 is the next coarser grid, ...)    </dd></dl>

</div>
</div>
<a id="a84635b2d0487a62a6a8d3b2d79ee2775" name="a84635b2d0487a62a6a8d3b2d79ee2775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84635b2d0487a62a6a8d3b2d79ee2775">&#9670;&#160;</a></span>project() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<div class="memtemplate">
template&lt;class ContainerType0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::project </td>
          <td>(</td>
          <td class="paramtype">const ContainerType0 &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; ContainerType0 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project vector to all involved grids.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the input vector (may alias first element of out) </td></tr>
    <tr><td class="paramname">out</td><td>the input vector projected to all grids ( index 0 contains a copy of src, 1 is the projetion to the first coarse grid, 2 is the next coarser grid, ...) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>out</code> is not resized    </dd></dl>

</div>
</div>
<a id="abf980680f992d4ce0436797137dfe5f7" name="abf980680f992d4ce0436797137dfe5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf980680f992d4ce0436797137dfe5f7">&#9670;&#160;</a></span>set_benchmark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::set_benchmark </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>benchmark</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>message</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;Nested&#160;Iterations&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set or unset performance timings during iterations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">benchmark</td><td>If true, additional output will be written to <code>std::cout</code> during solution </td></tr>
    <tr><td class="paramname">message</td><td>An optional identifier that is printed together with the benchmark (intended use is to distinguish different messages in the output) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7a9e3acbd2d7aa1373f48d9e69daaa4" name="aa7a9e3acbd2d7aa1373f48d9e69daaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a9e3acbd2d7aa1373f48d9e69daaa4">&#9670;&#160;</a></span>set_max_iter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::set_max_iter </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>new_max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of iterations allowed at stage 0. </p>
<p>By default this number is the grid size. However, for large simulations you may want to prevent the solver from iterating to that number in case of failure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_max</td><td>new maximum number of iterations allowed at stage 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a109d894a8e283f68594e2b1d02bed6fc" name="a109d894a8e283f68594e2b1d02bed6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109d894a8e283f68594e2b1d02bed6fc">&#9670;&#160;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType0 , class ContainerType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned &gt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; MatrixType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType0 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="#a31cc3f8e39468ef4b723d00e11b48601">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>eps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nested iterations.    </p>
<p>Equivalent to the following</p><ol type="1">
<li>Compute residual with given initial guess.</li>
<li>Project residual down to the coarsest grid.</li>
<li>Solve equation on the coarse grid.</li>
<li>interpolate solution up to next finer grid and repeat 3 and 4 until the original grid is reached. <dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__multigrid.html#gaa72ab35001decd5c7c6bf39a68df46a8" title="Full approximation nested iterations.">dg::nested_iterations</a></code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The weights and preconditioner for the <code><a class="el" href="classdg_1_1_p_c_g.html" title="Preconditioned conjugate gradient method to solve .">dg::PCG</a></code> solver is taken from the <code>weights()</code> and <code>precond()</code> method in the <code>MatrixType</code> class </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>Index 0 is the <code>MatrixType</code> on the original grid, 1 on the half grid, 2 on the quarter grid, ... <code>ops</code>[u].precond() and <code>ops</code>[u].weights() need to be callable! </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) contains initial guess on input and the solution on output (if the initial guess is good enough the solve may return immediately) </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side </td></tr>
    <tr><td class="paramname">eps</td><td>the accuracy: iteration stops if  \( ||b - Ax|| &lt; \epsilon(
||b|| + 1) \). If needed (and it is recommended to tune these values) the accuracy can be set for each stage separately. Per default the same accuracy is used at all stages but \( \epsilon_i = 0.5\epsilon_0\) for i &gt; 0 may be a good value as well. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of iterations in each of the stages beginning with the finest grid </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the convergence test on the coarse grids is only evaluated every 10th iteration. This effectively saves one dot product per iteration. The dot product is the main performance bottleneck on the coarse grids.  </dd></dl>
</li>
</ol>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and defines a tensor_category derived from <code><a class="el" href="structdg_1_1_any_matrix_tag.html" title="tensor_category base class">AnyMatrixTag</a></code>. Furthermore, any functor/lambda type with signature <code> void operator()( const ContainerType0&amp;, ContainerType1&amp;) </code>. For example<ul>
<li><code>scalar</code> or <code>Container:</code> Scalars and containers act as diagonal matrices.</li>
<li><code> std::function&lt;void( const ContainerType0&amp;, ContainerType1&amp;)&gt; </code></li>
<li><code><a class="el" href="group__typedefs.html#gae8a29dbadfe53ca55ab6a5b0b417ac2a" title="Host Matrix for derivatives.">dg::HMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga0574e9a1653d69754216f030cd8d4e18">dg::IHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a></code> or <code>std::vector&lt;dg::HVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#ga70cec5715da312a590711436b8b125ff" title="Device Matrix for derivatives.">dg::DMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga813f1498b206af847ea78d2f674643c0">dg::IDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> or <code>std::vector&lt;dg::DVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#ga5511f10a68d58cbd28067c9dbae45977" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code>std::vector&lt;dg::MHVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaa86748811132d3c72c739710777d2b39" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> or <code>std::vector&lt;dg::MDVec&gt;</code> </li>
</ul>
In case of <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> only those <code><a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a></code> functions that have a corresponding member function in the Matrix class (e.g. <code> symv( const ContainerType0&amp;, ContainerType1&amp;); </code> ) can be called. If a <code>Container</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, then the matrix is applied to each of the elements unless the type has the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> or is a Functor type.     </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system       </dd></dl>

</div>
</div>
<a id="a380edecea9ec4c9afbd93f8454298535" name="a380edecea9ec4c9afbd93f8454298535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380edecea9ec4c9afbd93f8454298535">&#9670;&#160;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType0 , class ContainerType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned &gt; <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; MatrixType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType0 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a31cc3f8e39468ef4b723d00e11b48601">value_type</a></td>          <td class="paramname"><span class="paramname"><em>eps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nested iterations. </p>
<p>Equivalent to the following</p><ol type="1">
<li>Compute residual with given initial guess.</li>
<li>Project residual down to the coarsest grid.</li>
<li>Solve equation on the coarse grid.</li>
<li>interpolate solution up to next finer grid and repeat 3 and 4 until the original grid is reached. <dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__multigrid.html#gaa72ab35001decd5c7c6bf39a68df46a8" title="Full approximation nested iterations.">dg::nested_iterations</a></code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The weights and preconditioner for the <code><a class="el" href="classdg_1_1_p_c_g.html" title="Preconditioned conjugate gradient method to solve .">dg::PCG</a></code> solver is taken from the <code>weights()</code> and <code>precond()</code> method in the <code>MatrixType</code> class </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>Index 0 is the <code>MatrixType</code> on the original grid, 1 on the half grid, 2 on the quarter grid, ... <code>ops</code>[u].precond() and <code>ops</code>[u].weights() need to be callable! </td></tr>
    <tr><td class="paramname">x</td><td>(read/write) contains initial guess on input and the solution on output (if the initial guess is good enough the solve may return immediately) </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side </td></tr>
    <tr><td class="paramname">eps</td><td>the accuracy: iteration stops if  \( ||b - Ax|| &lt; \epsilon(
||b|| + 1) \). If needed (and it is recommended to tune these values) the accuracy can be set for each stage separately. Per default the same accuracy is used at all stages but \( \epsilon_i = 0.5\epsilon_0\) for i &gt; 0 may be a good value as well. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of iterations in each of the stages beginning with the finest grid </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the convergence test on the coarse grids is only evaluated every 10th iteration. This effectively saves one dot product per iteration. The dot product is the main performance bottleneck on the coarse grids.  </dd></dl>
</li>
</ol>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and defines a tensor_category derived from <code><a class="el" href="structdg_1_1_any_matrix_tag.html" title="tensor_category base class">AnyMatrixTag</a></code>. Furthermore, any functor/lambda type with signature <code> void operator()( const ContainerType0&amp;, ContainerType1&amp;) </code>. For example<ul>
<li><code>scalar</code> or <code>Container:</code> Scalars and containers act as diagonal matrices.</li>
<li><code> std::function&lt;void( const ContainerType0&amp;, ContainerType1&amp;)&gt; </code></li>
<li><code><a class="el" href="group__typedefs.html#gae8a29dbadfe53ca55ab6a5b0b417ac2a" title="Host Matrix for derivatives.">dg::HMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga0574e9a1653d69754216f030cd8d4e18">dg::IHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a></code> or <code>std::vector&lt;dg::HVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#ga70cec5715da312a590711436b8b125ff" title="Device Matrix for derivatives.">dg::DMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga813f1498b206af847ea78d2f674643c0">dg::IDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> or <code>std::vector&lt;dg::DVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#ga5511f10a68d58cbd28067c9dbae45977" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code>std::vector&lt;dg::MHVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaa86748811132d3c72c739710777d2b39" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> or <code>std::vector&lt;dg::MDVec&gt;</code> </li>
</ul>
In case of <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> only those <code><a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a></code> functions that have a corresponding member function in the Matrix class (e.g. <code> symv( const ContainerType0&amp;, ContainerType1&amp;); </code> ) can be called. If a <code>Container</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, then the matrix is applied to each of the elements unless the type has the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> or is a Functor type.     </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="a7659e4d18315604a75b8f92f4266aba1" name="a7659e4d18315604a75b8f92f4266aba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7659e4d18315604a75b8f92f4266aba1">&#9670;&#160;</a></span>stages()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Geometry , class <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a> , class <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structdg_1_1_multigrid_c_g2d.html">dg::MultigridCG2d</a>&lt; Geometry, <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a319e07af874aea3f863c69aee943e8e4">Matrix</a>, <a class="elRef" href="../../matrix/html/invtridiag__t_8cpp.html#a6cfea605b3acf549ab5b0948819f83ae">Container</a> &gt;::stages </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of stages (same as <code>num_stages</code>) </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="multigrid_8h_source.html">multigrid.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_multigrid_c_g2d.html">MultigridCG2d</a></li>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:30 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
