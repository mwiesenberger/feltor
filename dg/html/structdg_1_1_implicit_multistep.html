<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: dg::ImplicitMultistep&lt; ContainerType &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structdg_1_1_implicit_multistep.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1_implicit_multistep-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::ImplicitMultistep&lt; ContainerType &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__lvevl2.html">Level 2: Basic numerical algorithms</a> &raquo; <a class="el" href="group__time.html">ODE integration</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Implicit multistep ODE integrator     \(
  \begin{align}
    v^{n+1} &amp;= \sum_{i=0}^{s-1} a_i v^{n-i} + \Delta t \sum_{i=1}^{s} c_i\hat I(t^{n+1-i}, v^{n+1-i}) + \Delta t c_{0} \hat I (t + \Delta t, v^{n+1}) \\
    \end{align}
    \).  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6f27b7d296b4c999640f5fa89ff2dd55" id="r_a6f27b7d296b4c999640f5fa89ff2dd55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f27b7d296b4c999640f5fa89ff2dd55">value_type</a> = <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt;ContainerType&gt;</td></tr>
<tr class="memdesc:a6f27b7d296b4c999640f5fa89ff2dd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">the value type of the time variable (float or double)  <br /></td></tr>
<tr class="separator:a6f27b7d296b4c999640f5fa89ff2dd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f7d7c8af418e5c0da2aa07310a8636" id="r_ae4f7d7c8af418e5c0da2aa07310a8636"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4f7d7c8af418e5c0da2aa07310a8636">container_type</a> = ContainerType</td></tr>
<tr class="separator:ae4f7d7c8af418e5c0da2aa07310a8636"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a901b4676d9bf01ff6e2ce3fe97c8ba72" id="r_a901b4676d9bf01ff6e2ce3fe97c8ba72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a901b4676d9bf01ff6e2ce3fe97c8ba72">ImplicitMultistep</a> ()=default</td></tr>
<tr class="memdesc:a901b4676d9bf01ff6e2ce3fe97c8ba72"><td class="mdescLeft">&#160;</td><td class="mdescRight">No memory allocation.     <br /></td></tr>
<tr class="separator:a901b4676d9bf01ff6e2ce3fe97c8ba72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523a8593ea431bb99e3288a28fea654b" id="r_a523a8593ea431bb99e3288a28fea654b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a523a8593ea431bb99e3288a28fea654b">ImplicitMultistep</a> (<a class="el" href="structdg_1_1_converts_to_multistep_tableau.html">ConvertsToMultistepTableau</a>&lt; <a class="el" href="#a6f27b7d296b4c999640f5fa89ff2dd55">value_type</a> &gt; tableau, const ContainerType &amp;<a class="el" href="#a2645c0b93bf546b1692af79453d5e54e">copyable</a>)</td></tr>
<tr class="memdesc:a523a8593ea431bb99e3288a28fea654b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for integration.  <br /></td></tr>
<tr class="separator:a523a8593ea431bb99e3288a28fea654b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023fb9b0f4bd991980ec335e064ba736" id="r_a023fb9b0f4bd991980ec335e064ba736"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:a023fb9b0f4bd991980ec335e064ba736"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a023fb9b0f4bd991980ec335e064ba736">construct</a> (Params &amp;&amp;...ps)</td></tr>
<tr class="memdesc:a023fb9b0f4bd991980ec335e064ba736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect forward parameters to one of the constructors.     <br /></td></tr>
<tr class="separator:a023fb9b0f4bd991980ec335e064ba736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2645c0b93bf546b1692af79453d5e54e" id="r_a2645c0b93bf546b1692af79453d5e54e"><td class="memItemLeft" align="right" valign="top">const ContainerType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2645c0b93bf546b1692af79453d5e54e">copyable</a> () const</td></tr>
<tr class="memdesc:a2645c0b93bf546b1692af79453d5e54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an object of same size as the object used for construction.     <br /></td></tr>
<tr class="separator:a2645c0b93bf546b1692af79453d5e54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faf833b8f7719093e7470b5e4268b00" id="r_a8faf833b8f7719093e7470b5e4268b00"><td class="memTemplParams" colspan="2">template&lt;class ImplicitRHS , class Solver &gt; </td></tr>
<tr class="memitem:a8faf833b8f7719093e7470b5e4268b00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8faf833b8f7719093e7470b5e4268b00">init</a> (const std::tuple&lt; ImplicitRHS, Solver &gt; &amp;ode, <a class="el" href="#a6f27b7d296b4c999640f5fa89ff2dd55">value_type</a> t0, const ContainerType &amp;u0, <a class="el" href="#a6f27b7d296b4c999640f5fa89ff2dd55">value_type</a> dt)</td></tr>
<tr class="memdesc:a8faf833b8f7719093e7470b5e4268b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize timestepper. Call before using the step function.  <br /></td></tr>
<tr class="separator:a8faf833b8f7719093e7470b5e4268b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4088bc69cd81f87a90a4921a1eef6142" id="r_a4088bc69cd81f87a90a4921a1eef6142"><td class="memTemplParams" colspan="2">template&lt;class ImplicitRHS , class Solver &gt; </td></tr>
<tr class="memitem:a4088bc69cd81f87a90a4921a1eef6142"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4088bc69cd81f87a90a4921a1eef6142">step</a> (const std::tuple&lt; ImplicitRHS, Solver &gt; &amp;ode, <a class="el" href="#a6f27b7d296b4c999640f5fa89ff2dd55">value_type</a> &amp;t, <a class="el" href="#ae4f7d7c8af418e5c0da2aa07310a8636">container_type</a> &amp;u)</td></tr>
<tr class="memdesc:a4088bc69cd81f87a90a4921a1eef6142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance one timestep.  <br /></td></tr>
<tr class="separator:a4088bc69cd81f87a90a4921a1eef6142"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ContainerType&gt;<br />
struct dg::ImplicitMultistep&lt; ContainerType &gt;</div><p>Implicit multistep ODE integrator     \(
  \begin{align}
    v^{n+1} &amp;= \sum_{i=0}^{s-1} a_i v^{n-i} + \Delta t \sum_{i=1}^{s} c_i\hat I(t^{n+1-i}, v^{n+1-i}) + \Delta t c_{0} \hat I (t + \Delta t, v^{n+1}) \\
    \end{align}
    \). </p>
<p>which discretizes   </p><p class="formulaDsp">
\[
    \frac{\partial v}{\partial t} = \hat I(t,v)
    \]
</p>
<p> where \( \hat I \) represents the right hand side of the equations. You can use your own coefficients defined as a <code><a class="el" href="structdg_1_1_multistep_tableau.html" title="Manage coefficients of Multistep methods.">dg::MultistepTableau</a></code> or use one of the predefined coefficients in  </p>
<p>We follow the naming convention as <b>NAME-S-Q</b></p><ul>
<li>NAME is the author or name of the method</li>
<li>S is the number of steps in the method</li>
<li>Q is the global order of the method</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Identifier   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BDF-X-X   </td><td class="markdownTableBodyNone">dg::BDF_X_X   </td><td class="markdownTableBodyNone">The coefficients for backward differences can be found at <a href="https://en.wikipedia.org/wiki/Backward_differentiation_formula">https://en.wikipedia.org/wiki/Backward_differentiation_formula</a> <br  />
 <dl class="section note"><dt>Note</dt><dd><b>Possible values for X: 1, 2, 3, 4, 5, 6</b> </dd>
<dd>
A BDF scheme is simply constructed by discretizing the time derivative with a n-th order backward difference formula and evaluating the right hand side at the new timestep. </dd>
<dd>
Methods with s&gt;6 are not zero-stable so they cannot be used   </dd></dl>
</td></tr>
</table>
<p>and (any imex tableau can be used in an implicit scheme, disregarding the explicit coefficients)  </p>
<p>We follow the naming convention as <b>NAME-S-Q</b></p><ul>
<li>NAME is the author or name of the method</li>
<li>S is the number of steps in the method</li>
<li>Q is the global order of the method</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Identifier   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ImEx-Euler-1-1   </td><td class="markdownTableBodyNone"><a class="el" href="group__time__utils.html#ggaac3c0875ffdfb49fd06757312d1a599aaa269d9523f1c0f2858ee7b2da2ddc005">dg::IMEX_EULER_1_1</a>   </td><td class="markdownTableBodyNone">Explicit Euler combined with Implicit Euler    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Euler   </td><td class="markdownTableBodyNone"><a class="el" href="group__time__utils.html#ggaac3c0875ffdfb49fd06757312d1a599aaa269d9523f1c0f2858ee7b2da2ddc005">dg::IMEX_EULER_1_1</a>   </td><td class="markdownTableBodyNone">For convenience    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ImEx-Koto-2-2   </td><td class="markdownTableBodyNone"><a class="el" href="group__time__utils.html#ggaac3c0875ffdfb49fd06757312d1a599aa34804fa61f76b9679a882c928f3462d6">dg::IMEX_KOTO_2_2</a>   </td><td class="markdownTableBodyNone"><a href="https://dx.doi.org/10.1007/s11464-009-0005-9">Koto T. Front. Math. China 2009, 4(1): 113-129</a> A stabilized 2nd order scheme with a large region of stability    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ImEx-Adams-2-2   </td><td class="markdownTableBodyNone"><a class="el" href="group__time__utils.html#ggaac3c0875ffdfb49fd06757312d1a599aacc1309c56b3b0e0653994f4c6e014f33">dg::IMEX_ADAMS_2_2</a>   </td><td class="markdownTableBodyNone"><a href="https://dx.doi.org/10.1016/j.jcp.2007.03.003">Hundsdorfer and Ruuth, Journal of Computational Physics 225 (2007)</a> <dl class="section note"><dt>Note</dt><dd><b>(C=0.44)</b>    </dd></dl>
</td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ImEx-BDF-X-X   </td><td class="markdownTableBodyNone">dg::IMEX_BDF_X_X   </td><td class="markdownTableBodyNone">The family of schems described in <a href="https://dx.doi.org/10.1016/j.jcp.2007.03.003">Hundsdorfer and Ruuth, Journal of Computational Physics 225 (2007)</a> <br  />
The implicit part is a normal BDF scheme <a href="https://en.wikipedia.org/wiki/Backward_differentiation_formula">https://en.wikipedia.org/wiki/Backward_differentiation_formula</a> while the explicit part equals the Minimal Projecting method by <a href="https://www.ams.org/journals/mcom/1979-33-148/S0025-5718-1979-0537965-0/S0025-5718-1979-0537965-0.pdf">Alfeld, P., Math. Comput. 33.148 1195-1212 (1979)</a> or <b>extrapolated BDF</b> in <a href="https://doi.org/10.1137/S0036142902406326">Hundsdorfer, W., Ruuth, S. J., &amp; Spiteri, R. J. (2003). Monotonicity-preserving linear multistep methods. SIAM Journal on Numerical Analysis, 41(2), 605-623 </a> <br  />
 <dl class="section note"><dt>Note</dt><dd>Possible values for <b>X: 1 (C=1.00), 2 (C=0.63), 3 (C=0.39), 4 (C=0.22), 5 (C=0.09), 6</b> <br  />
 Note that X=3 is identical to the "Karniadakis" scheme    </dd></dl>
</td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Karniadakis   </td><td class="markdownTableBodyNone"><a class="el" href="group__time__utils.html#ggaac3c0875ffdfb49fd06757312d1a599aaf44dc27d112d9de8bd859ba62e38677c">dg::IMEX_BDF_3_3</a>   </td><td class="markdownTableBodyNone">The ImEx-BDF-3-3 scheme is identical to the widely used "Karniadakis" scheme <a href="https://dx.doi.org/10.1016/0021-9991(91)90007-8">Karniadakis, et al. J. Comput. Phys. 97 (1991)</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ImEx-TVB-X-X   </td><td class="markdownTableBodyNone">dg::IMEX_TVB_X_X   </td><td class="markdownTableBodyNone">The family of schems described in &lt; <a href="https://dx.doi.org/10.1016/j.jcp.2007.03.003">Hundsdorfer and Ruuth, Journal of Computational Physics 225 (2007)</a> <br  />
 The explicit part is a TVB scheme while the implicit part is optimized to maximize damping of high wavelength <br  />
 <dl class="section note"><dt>Note</dt><dd>Possible values for <b>X: 3 (C=0.54), 4 (C=0.46), 5 (C=0.38)</b>   </dd></dl>
</td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>the CFL coefficient C is given relative to the forward Euler method: \( \Delta t &lt; C \Delta t_{FE}\). </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The coefficient C is the one that ensures the TVD property of the scheme and is <b>not</b> directly related to the stability region of the scheme   </dd></dl>
<p>The necessary Inversion in the implicit part must be provided by the <code>Implicit</code> class.</p>
<dl class="section note"><dt>Note</dt><dd>In our experience the implicit treatment of diffusive or hyperdiffusive terms can significantly reduce the required number of time steps. This outweighs the increased computational cost of the additional inversions. However, each PDE is different and general statements like this one should be treated with care.  </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses only <code><a class="el" href="group__blas1.html#ga20db094207e2f58e77ca01ff034ce41f">blas1::axpby</a></code> routines to integrate one step. </dd>
<dd>
The difference between a multistep and a single step method like RungeKutta is that the multistep only takes one right-hand-side evaluation per step. This is advantageous if the right hand side is expensive to evaluate. Even though Runge Kutta methods can have a larger absolute timestep, if the effective timestep per rhs evaluation is compared, multistep methods generally win. </dd>
<dd>
a disadvantage of multistep is that timestep adaption is not easily done.    </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae4f7d7c8af418e5c0da2aa07310a8636" name="ae4f7d7c8af418e5c0da2aa07310a8636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f7d7c8af418e5c0da2aa07310a8636">&#9670;&#160;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_implicit_multistep.html">dg::ImplicitMultistep</a>&lt; ContainerType &gt;::container_type = ContainerType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the type of the vector class in use </p>

</div>
</div>
<a id="a6f27b7d296b4c999640f5fa89ff2dd55" name="a6f27b7d296b4c999640f5fa89ff2dd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f27b7d296b4c999640f5fa89ff2dd55">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_implicit_multistep.html">dg::ImplicitMultistep</a>&lt; ContainerType &gt;<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">::value_type</a> = <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt;ContainerType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the value type of the time variable (float or double) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a901b4676d9bf01ff6e2ce3fe97c8ba72" name="a901b4676d9bf01ff6e2ce3fe97c8ba72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901b4676d9bf01ff6e2ce3fe97c8ba72">&#9670;&#160;</a></span>ImplicitMultistep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_implicit_multistep.html">dg::ImplicitMultistep</a>&lt; ContainerType &gt;::ImplicitMultistep </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No memory allocation.    </p>

</div>
</div>
<a id="a523a8593ea431bb99e3288a28fea654b" name="a523a8593ea431bb99e3288a28fea654b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523a8593ea431bb99e3288a28fea654b">&#9670;&#160;</a></span>ImplicitMultistep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_implicit_multistep.html">dg::ImplicitMultistep</a>&lt; ContainerType &gt;::ImplicitMultistep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdg_1_1_converts_to_multistep_tableau.html">ConvertsToMultistepTableau</a>&lt; <a class="el" href="#a6f27b7d296b4c999640f5fa89ff2dd55">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tableau</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>copyable</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve memory for integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableau</td><td>Tableau, name or identifier that <code><a class="el" href="structdg_1_1_converts_to_multistep_tableau.html" title="Convert identifiers to their corresponding dg::MultistepTableau.">ConvertsToMultistepTableau</a></code> </td></tr>
    <tr><td class="paramname">copyable</td><td>vector of the size that is later used in <code>step</code> ( it does not matter what values <code>copyable</code> contains, but its size is important; the <code>step</code> method can only be called with vectors of the same size) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a023fb9b0f4bd991980ec335e064ba736" name="a023fb9b0f4bd991980ec335e064ba736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023fb9b0f4bd991980ec335e064ba736">&#9670;&#160;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_implicit_multistep.html">dg::ImplicitMultistep</a>&lt; ContainerType &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect forward parameters to one of the constructors.    </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>parameters forwarded to constructors    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2645c0b93bf546b1692af79453d5e54e" name="a2645c0b93bf546b1692af79453d5e54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2645c0b93bf546b1692af79453d5e54e">&#9670;&#160;</a></span>copyable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ContainerType &amp; <a class="el" href="structdg_1_1_implicit_multistep.html">dg::ImplicitMultistep</a>&lt; ContainerType &gt;::copyable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an object of same size as the object used for construction.    </p>
<dl class="section return"><dt>Returns</dt><dd>A copyable object; what it contains is undefined, its size is important    </dd></dl>

</div>
</div>
<a id="a8faf833b8f7719093e7470b5e4268b00" name="a8faf833b8f7719093e7470b5e4268b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8faf833b8f7719093e7470b5e4268b00">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<div class="memtemplate">
template&lt;class ImplicitRHS , class Solver &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_implicit_multistep.html">dg::ImplicitMultistep</a>&lt; ContainerType &gt;::init </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; ImplicitRHS, Solver &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6f27b7d296b4c999640f5fa89ff2dd55">value_type</a></td>          <td class="paramname"><span class="paramname"><em>t0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>u0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6f27b7d296b4c999640f5fa89ff2dd55">value_type</a></td>          <td class="paramname"><span class="paramname"><em>dt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize timestepper. Call before using the step function. </p>
<p>This routine has to be called before the first timestep is made.  </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExplicitRHS</td><td>The explicit (part of the) right hand side is a functor type with no return value (subroutine) of signature <code> void operator()(value_type, const ContainerType&amp;, ContainerType&amp;)</code> The first argument is the time, the second is the input vector, which the functor may <b>not</b> override, and the third is the output, i.e. y' = E(t, y) translates to E(t, y, y'). The two ContainerType arguments never alias each other in calls to the functor. The functor can throw to indicate failure. Exceptions should derive from <code>std::exception</code>.     </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Solver</td><td>A functor type for the implicit right hand side. Must solve the equation \( y - \alpha I(y,t) = y^*\) for <code>y</code> for given <code>alpha</code>, <code>t</code> and <code>ys</code>. Alpha is always positive and non-zero. Signature <code> void operator()( value_type alpha, value_type t, ContainerType&amp; y, const ContainerType&amp; ys); </code> The functor can throw. Any Exception should derive from <code>std::exception</code>.    </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ode</td><td>the &lt;right hand side, solver for the rhs&gt; functors. Typically <code>std::tie(implicit_rhs, solver)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><code>solver</code> is not actually called only <code>implicit_rhs</code> and only if the rhs actually needs to be stored (The <code>dg::BDF_X_X</code> tableaus in fact completely avoid calling <code>implicit_rhs</code>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>The intital time corresponding to u0 </td></tr>
    <tr><td class="paramname">u0</td><td>The initial value of the integration </td></tr>
    <tr><td class="paramname">dt</td><td>The timestep saved for later use This might be interesting if the call to <code>ex</code> changes its state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4088bc69cd81f87a90a4921a1eef6142" name="a4088bc69cd81f87a90a4921a1eef6142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4088bc69cd81f87a90a4921a1eef6142">&#9670;&#160;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<div class="memtemplate">
template&lt;class ImplicitRHS , class Solver &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_implicit_multistep.html">dg::ImplicitMultistep</a>&lt; ContainerType &gt;::step </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; ImplicitRHS, Solver &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6f27b7d296b4c999640f5fa89ff2dd55">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae4f7d7c8af418e5c0da2aa07310a8636">container_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance one timestep. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExplicitRHS</td><td>The explicit (part of the) right hand side is a functor type with no return value (subroutine) of signature <code> void operator()(value_type, const ContainerType&amp;, ContainerType&amp;)</code> The first argument is the time, the second is the input vector, which the functor may <b>not</b> override, and the third is the output, i.e. y' = E(t, y) translates to E(t, y, y'). The two ContainerType arguments never alias each other in calls to the functor. The functor can throw to indicate failure. Exceptions should derive from <code>std::exception</code>.     </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Solver</td><td>A functor type for the implicit right hand side. Must solve the equation \( y - \alpha I(y,t) = y^*\) for <code>y</code> for given <code>alpha</code>, <code>t</code> and <code>ys</code>. Alpha is always positive and non-zero. Signature <code> void operator()( value_type alpha, value_type t, ContainerType&amp; y, const ContainerType&amp; ys); </code> The functor can throw. Any Exception should derive from <code>std::exception</code>.    </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ode</td><td>the &lt;right hand side, solver for the rhs&gt; functors. Typically <code>std::tie(implicit_rhs, solver)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>the <code>implicit_rhs</code> functor is only called during the initialization phase (the first few steps after the call to the init function) but only if the rhs actually needs to be stored (The <code>dg::BDF_X_X</code> tableaus in fact completely avoid calling <code>implicit_rhs</code>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>(write-only), contains timestep corresponding to <code>u</code> on return </td></tr>
    <tr><td class="paramname">u</td><td>(write-only), contains next step of time-integration on return This might be interesting if the call to <code>ex</code> changes its state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The first few steps after the call to the init function are performed with a DIRK method (of the same order) to initialize the multistepper </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="multistep_8h_source.html">multistep.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_implicit_multistep.html">ImplicitMultistep</a></li>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:30 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
