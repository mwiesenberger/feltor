<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: BLAS level 2 routines: Matrix-Vector</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__blas2.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">BLAS level 2 routines: Matrix-Vector<div class="ingroups"><a class="el" href="group__level1.html">Level 1: Vectors, Matrices and basic operations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>\( \alpha M \cdot x + \beta y\) and \( x^T M y \)  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for BLAS level 2 routines: Matrix-Vector:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__blas2.svg" width="411" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1blas2.html">dg::blas2</a></td></tr>
<tr class="memdesc:namespacedg_1_1blas2"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level 2 routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga23bc199efd99fabd91bfb9f35e9127bc" id="r_ga23bc199efd99fabd91bfb9f35e9127bc"><td class="memTemplParams" colspan="2">template&lt;class ContainerType1 , class MatrixType , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga23bc199efd99fabd91bfb9f35e9127bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga23bc199efd99fabd91bfb9f35e9127bc">dg::blas2::dot</a> (const ContainerType1 &amp;x, const MatrixType &amp;<a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a9990e99e87d163c58817550b21d35a83">m</a>, const ContainerType2 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:ga23bc199efd99fabd91bfb9f35e9127bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x^T M y\); Binary reproducible general dot product  <br /></td></tr>
<tr class="separator:ga23bc199efd99fabd91bfb9f35e9127bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8360dc43dc76d7ff585f3a570998f942" id="r_ga8360dc43dc76d7ff585f3a570998f942"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType &gt; </td></tr>
<tr class="memitem:ga8360dc43dc76d7ff585f3a570998f942"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8360dc43dc76d7ff585f3a570998f942">dg::blas2::dot</a> (const MatrixType &amp;<a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a9990e99e87d163c58817550b21d35a83">m</a>, const ContainerType &amp;x)</td></tr>
<tr class="memdesc:ga8360dc43dc76d7ff585f3a570998f942"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( x^T M x\); Binary reproducible general dot product  <br /></td></tr>
<tr class="separator:ga8360dc43dc76d7ff585f3a570998f942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bd2015d31362b25d61110f91cf3b0b9" id="r_ga9bd2015d31362b25d61110f91cf3b0b9"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga9bd2015d31362b25d61110f91cf3b0b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9bd2015d31362b25d61110f91cf3b0b9">dg::blas2::symv</a> (<a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt; <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>, MatrixType &amp;&amp;M, const ContainerType1 &amp;x, <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt; <a class="elRef" href="../../matrix/html/polarization__b_8cpp.html#a4049344c4d6020a322197047b513967f">beta</a>, ContainerType2 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:ga9bd2015d31362b25d61110f91cf3b0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = \alpha M x + \beta y\)  <br /></td></tr>
<tr class="separator:ga9bd2015d31362b25d61110f91cf3b0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3840941bd2bb1d64c6ca3fef1f1b960" id="r_gac3840941bd2bb1d64c6ca3fef1f1b960"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:gac3840941bd2bb1d64c6ca3fef1f1b960"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a> (MatrixType &amp;&amp;M, const ContainerType1 &amp;x, ContainerType2 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:gac3840941bd2bb1d64c6ca3fef1f1b960"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = M x\)  <br /></td></tr>
<tr class="separator:gac3840941bd2bb1d64c6ca3fef1f1b960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7e3b58697b6e93169eebbda63f3ed3" id="r_ga1b7e3b58697b6e93169eebbda63f3ed3"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga1b7e3b58697b6e93169eebbda63f3ed3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1b7e3b58697b6e93169eebbda63f3ed3">dg::blas2::gemv</a> (<a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt; <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>, MatrixType &amp;&amp;M, const ContainerType1 &amp;x, <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt; <a class="elRef" href="../../matrix/html/polarization__b_8cpp.html#a4049344c4d6020a322197047b513967f">beta</a>, ContainerType2 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:ga1b7e3b58697b6e93169eebbda63f3ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">blas2::symv</a></code> \( y = \alpha M x + \beta y \);.  <br /></td></tr>
<tr class="separator:ga1b7e3b58697b6e93169eebbda63f3ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7f59acf79dc654da64ca7e8f212284" id="r_ga5f7f59acf79dc654da64ca7e8f212284"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:ga5f7f59acf79dc654da64ca7e8f212284"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5f7f59acf79dc654da64ca7e8f212284">dg::blas2::gemv</a> (MatrixType &amp;&amp;M, const ContainerType1 &amp;x, ContainerType2 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:ga5f7f59acf79dc654da64ca7e8f212284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">blas2::symv</a></code> \( y = M x\);.  <br /></td></tr>
<tr class="separator:ga5f7f59acf79dc654da64ca7e8f212284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32ba87da1fb9557331d42393db507b3a" id="r_ga32ba87da1fb9557331d42393db507b3a"><td class="memTemplParams" colspan="2">template&lt;class Stencil , class ContainerType , class ... ContainerTypes&gt; </td></tr>
<tr class="memitem:ga32ba87da1fb9557331d42393db507b3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga32ba87da1fb9557331d42393db507b3a">dg::blas2::parallel_for</a> (Stencil f, unsigned N, ContainerType &amp;&amp;x, ContainerTypes &amp;&amp;... xs)</td></tr>
<tr class="memdesc:ga32ba87da1fb9557331d42393db507b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( f(i, x_0, x_1, ...)\ \forall i\); Customizable and generic for loop  <br /></td></tr>
<tr class="separator:ga32ba87da1fb9557331d42393db507b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb834f2824e513f17fe6a1b9035e9fb8" id="r_gadb834f2824e513f17fe6a1b9035e9fb8"><td class="memTemplParams" colspan="2">template&lt;class FunctorType , class MatrixType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:gadb834f2824e513f17fe6a1b9035e9fb8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadb834f2824e513f17fe6a1b9035e9fb8">dg::blas2::stencil</a> (FunctorType f, MatrixType &amp;&amp;M, const ContainerType1 &amp;x, ContainerType2 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:gadb834f2824e513f17fe6a1b9035e9fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( F(M, x, y)\)  <br /></td></tr>
<tr class="separator:gadb834f2824e513f17fe6a1b9035e9fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53701ba3118a2256a93a4d92a7a8a597" id="r_ga53701ba3118a2256a93a4d92a7a8a597"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class AnotherMatrixType &gt; </td></tr>
<tr class="memitem:ga53701ba3118a2256a93a4d92a7a8a597"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga53701ba3118a2256a93a4d92a7a8a597">dg::blas2::transfer</a> (const MatrixType &amp;x, AnotherMatrixType &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:ga53701ba3118a2256a93a4d92a7a8a597"><td class="mdescLeft">&#160;</td><td class="mdescRight">\( y = x\); Generic way to copy and/or convert a Matrix type to a different Matrix type  <br /></td></tr>
<tr class="separator:ga53701ba3118a2256a93a4d92a7a8a597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d14b7a823d92037add5899d611d7d9" id="r_gab8d14b7a823d92037add5899d611d7d9"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:gab8d14b7a823d92037add5899d611d7d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab8d14b7a823d92037add5899d611d7d9">dg::apply</a> (<a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt; <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#adeedc97114c5a704906c8e26bdbd2451">alpha</a>, MatrixType &amp;&amp;M, const ContainerType1 &amp;x, <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt; <a class="elRef" href="../../matrix/html/polarization__b_8cpp.html#a4049344c4d6020a322197047b513967f">beta</a>, ContainerType2 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:gab8d14b7a823d92037add5899d611d7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a></code> \( y = \alpha M(x) + \beta y \);.  <br /></td></tr>
<tr class="separator:gab8d14b7a823d92037add5899d611d7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac419b379a849c48dc3a60ef1e4662166" id="r_gac419b379a849c48dc3a60ef1e4662166"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </td></tr>
<tr class="memitem:gac419b379a849c48dc3a60ef1e4662166"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac419b379a849c48dc3a60ef1e4662166">dg::apply</a> (MatrixType &amp;&amp;M, const ContainerType1 &amp;x, ContainerType2 &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>)</td></tr>
<tr class="memdesc:gac419b379a849c48dc3a60ef1e4662166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a></code> \( y = M( x)\);.  <br /></td></tr>
<tr class="separator:gac419b379a849c48dc3a60ef1e4662166"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>\( \alpha M \cdot x + \beta y\) and \( x^T M y \) </p>
<dl class="section note"><dt>Note</dt><dd>Successive calls to blas routines are executed sequentially </dd>
<dd>
A manual synchronization of threads or devices is never needed in an application using these functions. All functions returning a value block until the value is ready.</dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab8d14b7a823d92037add5899d611d7d9" name="gab8d14b7a823d92037add5899d611d7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8d14b7a823d92037add5899d611d7d9">&#9670;&#160;</a></span>apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt;</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt;</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a></code> \( y = \alpha M(x) + \beta y \);. </p>
<p>This Alias exists for code readability: if your matrix is not actually a matrix but a functor then it may seem unnatural to write <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">blas2::symv</a></code> in your code especially if <code>M</code> is non-linear. </p>

</div>
</div>
<a id="gac419b379a849c48dc3a60ef1e4662166" name="gac419b379a849c48dc3a60ef1e4662166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac419b379a849c48dc3a60ef1e4662166">&#9670;&#160;</a></span>apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::apply </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a></code> \( y = M( x)\);. </p>
<p>This Alias exists for code readability: if your matrix is not actually a matrix but a functor then it may seem unnatural to write <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">blas2::symv</a></code> in your code especially if <code>M</code> is non-linear. </p>

</div>
</div>
<a id="ga23bc199efd99fabd91bfb9f35e9127bc" name="ga23bc199efd99fabd91bfb9f35e9127bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23bc199efd99fabd91bfb9f35e9127bc">&#9670;&#160;</a></span>dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType1 , class MatrixType , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto dg::blas2::dot </td>
          <td>(</td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x^T M y\); Binary reproducible general dot product </p>
<p>This routine computes the scalar product defined by the symmetric positive definite matrix M </p><p class="formulaDsp">
\[ x^T M y = \sum_{i,j=0}^{N-1} x_i M_{ij} y_j \]
</p>
<p>For example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a> two( 100,2), three(100,3);</div>
<div class="line"><span class="keywordtype">int</span> result = <a class="code hl_function" href="#ga23bc199efd99fabd91bfb9f35e9127bc">dg::blas2::dot</a>(two, 42., three);</div>
<div class="line">CHECK( result == 25200); <span class="comment">//100*(2*42*3)</span></div>
</div><!-- fragment --><p> Or a more elaborate use case </p><div class="fragment"><div class="line">        <span class="comment">// This code snippet demonstrates how to discretize and compute the norm of a</span></div>
<div class="line">        <span class="comment">// function on both shared and distributed memory systems</span></div>
<div class="line"><span class="preprocessor">#ifdef WITH_MPI</span></div>
<div class="line">        <span class="comment">// In an MPI environment define a 2d Cartesian communicator</span></div>
<div class="line">        MPI_Comm comm2d = <a class="code hl_function" href="group__mpi__utility.html#ga492bf8ec7e709603a5cdd5569766fa2e">dg::mpi_cart_create</a>( MPI_COMM_WORLD, {0,0}, {1,1});</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        <span class="comment">// create a grid of the domain [0,2]x[0,2] with 20 cells in x and y and</span></div>
<div class="line">        <span class="comment">// 3 polynomial coefficients</span></div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_real_m_p_i_grid.html">dg::x::Grid2d</a> g2d( 0, 2, 0, 2, 3, 20, 20</div>
<div class="line">#ifdef WITH_MPI</div>
<div class="line">        , comm2d <span class="comment">// in MPI distribute among processes</span></div>
<div class="line">#endif</div>
<div class="line">        );</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// define the function to integrate</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_variableRef" href="../../matrix/html/polarization__b_8cpp.html#a18169e9f248b43386608618d6076ae24">amp</a> = 2.;</div>
<div class="line">        <span class="keyword">auto</span> function = [=] (<span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>, <span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>){</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code hl_variableRef" href="../../matrix/html/polarization__b_8cpp.html#a18169e9f248b43386608618d6076ae24">amp</a>*exp(x)*exp(y);</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// create the Gaussian weights (volume form) for the integration</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_struct" href="structdg_1_1_m_p_i___vector.html">dg::x::DVec</a> w2d = <a class="code hl_function" href="group__evaluation.html#gaa0ff8103cfd6ce63cec46fb31df5a4b9">dg::create::weights</a>( g2d);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// discretize the function on the grid</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_struct" href="structdg_1_1_m_p_i___vector.html">dg::x::DVec</a> vec = <a class="code hl_function" href="group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">dg::evaluate</a>( function, g2d);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// now compute the scalar product (the L2 norm)</span></div>
<div class="line">        <span class="keywordtype">double</span> square_norm = <a class="code hl_function" href="#ga23bc199efd99fabd91bfb9f35e9127bc">dg::blas2::dot</a>( vec, w2d, vec);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// norm is now (or at least converges to): (e^4-1)^2</span></div>
<div class="line">        CHECK( fabs( square_norm - (exp(4)-1)*(exp(4)-1)) &lt; 1e-6);</div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>if one of the input vectors contains <code>Inf</code> or <code>NaN</code> or the product of the input numbers reaches <code>Inf</code> or <code>Nan</code> then the behaviour is undefined and the function may throw. See <a class="el" href="structdg_1_1_i_s_n_f_i_n_i_t_e.html">dg::ISNFINITE</a> and <a class="el" href="structdg_1_1_i_s_n_s_a_n_e.html">dg::ISNSANE</a> in that case </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Our implementation guarantees <b>binary reproducible</b> results up to and excluding the last mantissa bit of the result. Furthermore, the sum is computed with <b>infinite precision</b> and the result is then rounded to the nearest double precision number. Although the products are not computed with infinite precision, the order of multiplication is guaranteed. This is possible with the help of an adapted version of the <code><a class="elRef" href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></code> library and works for single and double precision. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Binary Reproducible results are only guaranteed for <b>float</b> or <b>double</b> input. All other value types redirect to <code>dg::blas1::vdot(
dg::Product(), x, m, y);</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left input </td></tr>
    <tr><td class="paramname">m</td><td>The diagonal Matrix. </td></tr>
    <tr><td class="paramname">y</td><td>Right input (may alias <code>x</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generalized scalar product. If <code>x</code> and <code>y</code> are vectors of containers and <code>m</code> is not, then we sum the results of <code>dg::blas2::dot(
x[i], m, y[i])</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is always executed synchronously due to the implicit memcpy of the result. With mpi the result is broadcasted to all processes. Also note that the behaviour is undefined when one of the containers contains <code>nan</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td><code>MatrixType</code> has to have a category derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and must be compatible with the <code>ContainerTypes</code>  </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="ga8360dc43dc76d7ff585f3a570998f942" name="ga8360dc43dc76d7ff585f3a570998f942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8360dc43dc76d7ff585f3a570998f942">&#9670;&#160;</a></span>dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; MatrixType &gt; dg::blas2::dot </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( x^T M x\); Binary reproducible general dot product </p>
<p>Alias for <code>dg::blas2::dot( x,m,x)</code> </p><p class="formulaDsp">
\[ x^T M x = \sum_{i,j=0}^{N-1} x_i M_{ij} x_j \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The diagonal Matrix </td></tr>
    <tr><td class="paramname">x</td><td>Right input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generalized scalar product. If <code>x</code> is a vector of containers and <code>m</code> is not, then we sum the results of <code>dg::blas2::dot( m, x[i])</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is always executed synchronously due to the implicit memcpy of the result. </dd>
<dd>
This routine is equivalent to the call <code>dg::blas2::dot( x, m, x)</code>; which should be prefered because it looks more explicit </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td><code>MatrixType</code> has to have a category derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and must be compatible with the <code>ContainerTypes</code>  </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="ga1b7e3b58697b6e93169eebbda63f3ed3" name="ga1b7e3b58697b6e93169eebbda63f3ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b7e3b58697b6e93169eebbda63f3ed3">&#9670;&#160;</a></span>gemv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::gemv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt;</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt;</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">blas2::symv</a></code> \( y = \alpha M x + \beta y \);. </p>
<p>This Alias exists for code readability: if your "symmetric matrix" is not actually a symmetric matrix then it may seem unnatural to write <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">blas2::symv</a></code> in your code </p>

</div>
</div>
<a id="ga5f7f59acf79dc654da64ca7e8f212284" name="ga5f7f59acf79dc654da64ca7e8f212284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f7f59acf79dc654da64ca7e8f212284">&#9670;&#160;</a></span>gemv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::gemv </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">blas2::symv</a></code> \( y = M x\);. </p>
<p>This Alias exists for code readability: if your "symmetric matrix" is not actually a symmetric matrix then it may seem unnatural to write <code><a class="el" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">blas2::symv</a></code> in your code </p>

</div>
</div>
<a id="ga32ba87da1fb9557331d42393db507b3a" name="ga32ba87da1fb9557331d42393db507b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32ba87da1fb9557331d42393db507b3a">&#9670;&#160;</a></span>parallel_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stencil , class ContainerType , class ... ContainerTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::parallel_for </td>
          <td>(</td>
          <td class="paramtype">Stencil</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerTypes &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>xs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( f(i, x_0, x_1, ...)\ \forall i\); Customizable and generic for loop </p>
<dl class="section attention"><dt>Attention</dt><dd>Only works for shared memory vectors (or scalars): no MPI, no Recursive (find reasons below). </dd>
<dd>
For trivially parallel operations (no neighboring points involved) use <code><a class="el" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5" title="; Customizable and generic blas1 function">dg::blas1::subroutine</a></code> </dd></dl>
<p>This routine loops over an arbitrary user-defined "loop body" functor <code>f</code> with an arbitrary number of arguments \( x_s\) elementwise </p><p class="formulaDsp">
\[ f(i, x_{0}, x_{1}, ...)  \]
</p>
<p> where <code>i</code> iterates from <code>0</code> to a given size <code>N</code>. The order of iterations is undefined. It is equivalent to the following </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;N; i++)</div>
<div class="line">    f( i, &amp;x_0[0], &amp;x_1[0], ...);</div>
</div><!-- fragment --><p> With this function very general for-loops can be parallelized like for example </p><div class="fragment"><div class="line"><span class="comment">// Compute forward difference of vector</span></div>
<div class="line">std::vector&lt;double&gt; vec1 = {11,12,13}, vec2(3);</div>
<div class="line"><a class="code hl_function" href="#ga32ba87da1fb9557331d42393db507b3a">dg::blas2::parallel_for</a>(</div>
<div class="line">    []<a class="code hl_define" href="group__typedefs.html#gaa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>( <span class="keywordtype">unsigned</span> i, <span class="keyword">const</span> <span class="keywordtype">double</span>* x, <span class="keywordtype">double</span>* y, <span class="keywordtype">int</span> mod)</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[i] = <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[(i+1)%mod] - x[i];</div>
<div class="line">    }, 3, vec1, vec2, 3);</div>
<div class="line">CHECK( vec2 == std::vector{ 1.,1.,-2.});</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="comment">// Compute transpose of vector</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> nx = 3, ny = 3;</div>
<div class="line">std::vector&lt;double&gt; vec = {11,12,13, 21,22,23, 31,32,33}, vecT(9);</div>
<div class="line"><a class="code hl_function" href="#ga32ba87da1fb9557331d42393db507b3a">dg::blas2::parallel_for</a>( [nx,ny]<a class="code hl_define" href="group__typedefs.html#gaa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>( <span class="keywordtype">unsigned</span> k, <span class="keyword">const</span></div>
<div class="line">            <span class="keywordtype">double</span>* ii, <span class="keywordtype">double</span>* oo)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">unsigned</span> i = k/nx, j =  k%nx;</div>
<div class="line">        oo[j*ny+i] = ii[i*nx+j];</div>
<div class="line">    }, nx*ny, vec, vecT);</div>
<div class="line">CHECK( vecT == std::vector&lt;double&gt;{ 11,21,31, 12,22,32, 13,23,33});</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In a way this function is a generalization of <code><a class="el" href="group__blas1.html#ga7386b5cb0144d5364b8ea8c8ce1482a5" title="; Customizable and generic blas1 function">dg::blas1::subroutine</a></code> to non-trivial parallelization tasks. However, this comes at a price: this function only works for containers with the <code><a class="el" href="structdg_1_1_shared_vector_tag.html" title="Indicate a contiguous chunk of shared memory.">dg::SharedVectorTag</a></code> and sclar types. The reason it cannot work for MPI is that the stencil (and thus the communication pattern) is unkown. However, it can serve as an important building block for other parallel functions like <code><a class="el" href="#gadb834f2824e513f17fe6a1b9035e9fb8">dg::blas2::stencil</a></code>. </dd>
<dd>
This is the closest function we have to <code> kokkos::parallel_for</code> of the <a href="https://github.com/kokkos/kokkos">Kokkos library</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the loop body </td></tr>
    <tr><td class="paramname">N</td><td>the total number of iterations in the for loop </td></tr>
    <tr><td class="paramname">x</td><td>the first argument </td></tr>
    <tr><td class="paramname">xs</td><td>other arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>The user has to decide whether or not it is safe to alias input or output vectors. If in doubt, do not alias output vectors. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stencil</td><td>a function or functor with an arbitrary number of arguments and no return type; The first argument is an unsigned (the loop iteration), afterwards takes a <code>const_pointer_type</code> argument (const pointer to first element in vector) for each input argument in the call and a <code> pointer_type </code> argument (pointer to first element in vector) for each output argument. Scalars are forwarded "as is" <code> scalar_type </code>. <code>Stencil</code> must be callable on the device in use. In particular, with CUDA it must be a functor (<b>not</b> a function) and its signature must contain the __device__ specifier. (s.a. <a class="el" href="group__typedefs.html#gaa181978ebbc17b8ea6d6c072e06c2d05">DG_DEVICE</a>) </td></tr>
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the <code><a class="el" href="structdg_1_1_shared_vector_tag.html" title="Indicate a contiguous chunk of shared memory.">SharedVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp)</code></li>
<li><code>int</code>, <code>double</code> and other primitive types ... </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb834f2824e513f17fe6a1b9035e9fb8" name="gadb834f2824e513f17fe6a1b9035e9fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb834f2824e513f17fe6a1b9035e9fb8">&#9670;&#160;</a></span>stencil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorType , class MatrixType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::stencil </td>
          <td>(</td>
          <td class="paramtype">FunctorType</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( F(M, x, y)\) </p>
<p>This routine calls </p><p class="formulaDsp">
\[ F(i, [M], x, y) \]
</p>
<p> for all \( i \in [0,N[\), where N is the number of rows in M, using <code><a class="el" href="#ga32ba87da1fb9557331d42393db507b3a" title="; Customizable and generic for loop">dg::blas2::parallel_for</a></code>, where [M] depends on the matrix type:</p><ul>
<li>for a csr matrix it is [M] = m.row_offsets, m.column_indices, m.values</li>
</ul>
<p>Possible shared memory implementation </p><div class="fragment"><div class="line"><a class="code hl_function" href="#ga32ba87da1fb9557331d42393db507b3a">dg::blas2::parallel_for</a>( F, <a class="code hl_variableRef" href="../../matrix/html/lanczos__b_8cpp.html#a9990e99e87d163c58817550b21d35a83">m</a>.num_rows, <a class="code hl_variableRef" href="../../matrix/html/lanczos__b_8cpp.html#a9990e99e87d163c58817550b21d35a83">m</a>.row_offsets, <a class="code hl_variableRef" href="../../matrix/html/lanczos__b_8cpp.html#a9990e99e87d163c58817550b21d35a83">m</a>.column_indices, <a class="code hl_variableRef" href="../../matrix/html/lanczos__b_8cpp.html#a9990e99e87d163c58817550b21d35a83">m</a>.values, x, <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>);</div>
<div class="ttc" id="agroup__blas2_html_ga32ba87da1fb9557331d42393db507b3a"><div class="ttname"><a href="#ga32ba87da1fb9557331d42393db507b3a">dg::blas2::parallel_for</a></div><div class="ttdeci">void parallel_for(Stencil f, unsigned N, ContainerType &amp;&amp;x, ContainerTypes &amp;&amp;... xs)</div><div class="ttdoc">; Customizable and generic for loop</div><div class="ttdef"><b>Definition</b> blas2.h:413</div></div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">dg::coo2d::y</a></div><div class="ttdeci">@ y</div><div class="ttdoc">y direction</div></div>
<div class="ttc" id="alanczos__b_8cpp_html_a9990e99e87d163c58817550b21d35a83"><div class="ttname"><a href="../../matrix/html/lanczos__b_8cpp.html#a9990e99e87d163c58817550b21d35a83">m</a></div><div class="ttdeci">const double m</div></div>
</div><!-- fragment --><p> Other matrix types have not yet been implemented. </p><dl class="section note"><dt>Note</dt><dd>Since the matrix is known, a communication pattern is available and thus the function works in parallel for MPI (unlike <code><a class="el" href="#ga32ba87da1fb9557331d42393db507b3a" title="; Customizable and generic for loop">dg::blas2::parallel_for</a></code>). </dd>
<dd>
In a way this function is a generalization of <code><a class="el" href="#ga32ba87da1fb9557331d42393db507b3a" title="; Customizable and generic for loop">dg::blas2::parallel_for</a></code> to MPI vectors at the cost of having to encode the communication stencil in the matrix <code>M</code> and only one vector argument</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The filter function is called like <code> f(i, m.row_offsets_ptr, m.column_indices_ptr, m.values_ptr, x_ptr, y_ptr) </code> </td></tr>
    <tr><td class="paramname">M</td><td>The Matrix. </td></tr>
    <tr><td class="paramname">x</td><td>input vector </td></tr>
    <tr><td class="paramname">y</td><td>contains the solution on output (may not alias <code>x</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorType</td><td>A type that is callable <code> void operator()( unsigned, pointer, [m_pointers], const_pointer) </code> For GPU vector the functor must be callable on the device. </td></tr>
    <tr><td class="paramname">MatrixType</td><td>So far only one of the <code><a class="el" href="structdg_1_1_sparse_matrix.html" title="A CSR formatted sparse matrix.">dg::SparseMatrix</a></code> types and their MPI variants are allowed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structdg_1_1_c_s_r_median_filter.html" title="Compute (lower) Median of input numbers.">dg::CSRMedianFilter</a>, <a class="el" href="group__stencil.html#gafbbfcdc6f30090130f43c23ca6d4680c" title="A 1d centered window stencil.">dg::create::window_stencil</a>  </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="ga9bd2015d31362b25d61110f91cf3b0b9" name="ga9bd2015d31362b25d61110f91cf3b0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bd2015d31362b25d61110f91cf3b0b9">&#9670;&#160;</a></span>symv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::symv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt;</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">get_value_type</a>&lt; ContainerType1 &gt;</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = \alpha M x + \beta y\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ y = \alpha M x + \beta y \]
</p>
<p> where \( M\) is a matrix (or functor that is called like <code>M(alpha,x,beta,y)</code>). </p><dl class="section note"><dt>Note</dt><dd>There is nothing that prevents <code>M</code> from being non-symmetric or even non-linear. In this sense the term "symv" (symmetrix-Matrix-Vector multiplication) is misleading. For better code readability we introduce aliases: <code><a class="el" href="#ga1b7e3b58697b6e93169eebbda63f3ed3" title="Alias for blas2::symv ;.">dg::blas2::gemv</a></code> (general Matrix-Vector multiplication) and <code><a class="el" href="#gab8d14b7a823d92037add5899d611d7d9" title="Alias for dg::blas2::symv ;.">dg::apply</a></code> (general, possibly non-linear functor application).</dd></dl>
<p>For example </p><div class="fragment"><div class="line"><span class="keyword">auto</span> mat = <a class="code hl_class" href="classdg_1_1_square_matrix.html">dg::SquareMatrix&lt;double&gt;</a>({0,1,2, 3,4,5, 6,7,8});</div>
<div class="line">std::vector&lt;double&gt; vec = {1,2,3}, res(3, 1000);</div>
<div class="line"><a class="code hl_function" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( 0.5, mat, vec, 2., res);</div>
<div class="line">CHECK( res == std::vector&lt;double&gt;{2004, 2013, 2022});</div>
</div><!-- fragment --><p> or a more elaborate use case </p><div class="fragment"><div class="line">        <span class="comment">// This code snippet demonstrates how to derive a function on a device</span></div>
<div class="line"><span class="preprocessor">#ifdef WITH_MPI</span></div>
<div class="line">        <span class="comment">// In an MPI environment define a 2d Cartesian communicator</span></div>
<div class="line">        MPI_Comm comm2d = <a class="code hl_function" href="group__mpi__utility.html#ga492bf8ec7e709603a5cdd5569766fa2e">dg::mpi_cart_create</a>( MPI_COMM_WORLD, {0,0}, {0,1});</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        <span class="comment">// create a grid of the domain [0,2]x[0,2] with 20 cells in x and y and</span></div>
<div class="line">        <span class="comment">// 3 polynomial coefficients</span></div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_real_m_p_i_grid.html">dg::x::Grid2d</a> g2d( 0, 2, 0, 2, 3, 20, 20, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></div>
<div class="line">#ifdef WITH_MPI</div>
<div class="line">        , comm2d <span class="comment">// in MPI distribute among processes</span></div>
<div class="line">#endif</div>
<div class="line">        );</div>
<div class="line">        <span class="comment">// define a function to derive</span></div>
<div class="line">        <span class="keyword">auto</span> function = [](<span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>, <span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>){</div>
<div class="line">            <span class="keywordflow">return</span> sin(x)*sin(y);</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//Define a device matrix</span></div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_m_p_i_sparse_block_mat.html">dg::x::DMatrix</a> <a class="code hl_function" href="group__creation.html#ga1899853dcfaa261709bded73dd40b1df">dx</a> = <a class="code hl_function" href="group__creation.html#ga1899853dcfaa261709bded73dd40b1df">dg::create::dx</a>( g2d);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//discretize the function on the grid and transfer the result to the device</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_struct" href="structdg_1_1_m_p_i___vector.html">dg::x::DVec</a> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a> = <a class="code hl_function" href="group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">dg::evaluate</a>( function, g2d);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//allocate memory for the result</span></div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_m_p_i___vector.html">dg::x::DVec</a> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>=<a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//apply the derivative to x and store result in y</span></div>
<div class="line">        <a class="code hl_function" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>(dx, x, y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//or equivalently</span></div>
<div class="line">        <a class="code hl_function" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>(1., dx, x, 0., y);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>A Scalar </td></tr>
    <tr><td class="paramname">M</td><td>The Matrix. </td></tr>
    <tr><td class="paramname">x</td><td>input vector </td></tr>
    <tr><td class="paramname">beta</td><td>A Scalar </td></tr>
    <tr><td class="paramname">y</td><td>contains the solution on output (may not alias <code>x</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><code>y</code> may not alias <code>x</code>, the only exception is if <code>MatrixType</code> has the <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> </dd>
<dd>
If y on input contains a NaN or Inf, it may contain NaN or Inf on output as well even if beta is zero.  </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and defines a tensor_category derived from <code><a class="el" href="structdg_1_1_any_matrix_tag.html" title="tensor_category base class">AnyMatrixTag</a></code>. Furthermore, any functor/lambda type with signature <code> void operator()( const ContainerType0&amp;, ContainerType1&amp;) </code>. For example<ul>
<li><code>scalar</code> or <code>Container:</code> Scalars and containers act as diagonal matrices.</li>
<li><code> std::function&lt;void( const ContainerType0&amp;, ContainerType1&amp;)&gt; </code></li>
<li><code><a class="el" href="group__typedefs.html#gae8a29dbadfe53ca55ab6a5b0b417ac2a" title="Host Matrix for derivatives.">dg::HMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga0574e9a1653d69754216f030cd8d4e18">dg::IHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a></code> or <code>std::vector&lt;dg::HVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#ga70cec5715da312a590711436b8b125ff" title="Device Matrix for derivatives.">dg::DMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga813f1498b206af847ea78d2f674643c0">dg::IDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> or <code>std::vector&lt;dg::DVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#ga5511f10a68d58cbd28067c9dbae45977" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code>std::vector&lt;dg::MHVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaa86748811132d3c72c739710777d2b39" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> or <code>std::vector&lt;dg::MDVec&gt;</code> </li>
</ul>
In case of <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> only those <code><a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a></code> functions that have a corresponding member function in the Matrix class (e.g. <code> symv( const ContainerType0&amp;, ContainerType1&amp;); </code> ) can be called. If a <code>Container</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, then the matrix is applied to each of the elements unless the type has the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> or is a Functor type.     </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="gac3840941bd2bb1d64c6ca3fef1f1b960" name="gac3840941bd2bb1d64c6ca3fef1f1b960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3840941bd2bb1d64c6ca3fef1f1b960">&#9670;&#160;</a></span>symv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class ContainerType1 , class ContainerType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::symv </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType1 &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType2 &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = M x\) </p>
<p>This routine computes </p><p class="formulaDsp">
\[ y = M x \]
</p>
<p> where \( M\) is a matrix (or functor that is called like <code>M(x,y)</code>). </p><dl class="section note"><dt>Note</dt><dd>There is nothing that prevents <code>M</code> from being non-symmetric or even non-linear. In this sense the term "symv" (symmetrix-Matrix-Vector multiplication) is misleading. For better code readability we introduce aliases: <code><a class="el" href="#ga1b7e3b58697b6e93169eebbda63f3ed3" title="Alias for blas2::symv ;.">dg::blas2::gemv</a></code> (general Matrix-Vector multiplication) and <code><a class="el" href="#gab8d14b7a823d92037add5899d611d7d9" title="Alias for dg::blas2::symv ;.">dg::apply</a></code> (general, possibly non-linear functor application)</dd></dl>
<p>For example </p><div class="fragment"><div class="line"><span class="keyword">auto</span> mat = <a class="code hl_class" href="classdg_1_1_square_matrix.html">dg::SquareMatrix&lt;double&gt;</a>({0,1,2, 3,4,5, 6,7,8});</div>
<div class="line">std::vector&lt;double&gt; vec = {1,2,3}, res(3);</div>
<div class="line"><a class="code hl_function" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( mat, vec, res);</div>
<div class="line">CHECK( res == std::vector&lt;double&gt;{8, 26, 44});</div>
</div><!-- fragment --><p> or a more elaborate use case </p><div class="fragment"><div class="line">        <span class="comment">// This code snippet demonstrates how to derive a function on a device</span></div>
<div class="line"><span class="preprocessor">#ifdef WITH_MPI</span></div>
<div class="line">        <span class="comment">// In an MPI environment define a 2d Cartesian communicator</span></div>
<div class="line">        MPI_Comm comm2d = <a class="code hl_function" href="group__mpi__utility.html#ga492bf8ec7e709603a5cdd5569766fa2e">dg::mpi_cart_create</a>( MPI_COMM_WORLD, {0,0}, {0,1});</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        <span class="comment">// create a grid of the domain [0,2]x[0,2] with 20 cells in x and y and</span></div>
<div class="line">        <span class="comment">// 3 polynomial coefficients</span></div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_real_m_p_i_grid.html">dg::x::Grid2d</a> g2d( 0, 2, 0, 2, 3, 20, 20, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></div>
<div class="line">#ifdef WITH_MPI</div>
<div class="line">        , comm2d <span class="comment">// in MPI distribute among processes</span></div>
<div class="line">#endif</div>
<div class="line">        );</div>
<div class="line">        <span class="comment">// define a function to derive</span></div>
<div class="line">        <span class="keyword">auto</span> function = [](<span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>, <span class="keywordtype">double</span> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>){</div>
<div class="line">            <span class="keywordflow">return</span> sin(x)*sin(y);</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//Define a device matrix</span></div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_m_p_i_sparse_block_mat.html">dg::x::DMatrix</a> <a class="code hl_function" href="group__creation.html#ga1899853dcfaa261709bded73dd40b1df">dx</a> = <a class="code hl_function" href="group__creation.html#ga1899853dcfaa261709bded73dd40b1df">dg::create::dx</a>( g2d);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//discretize the function on the grid and transfer the result to the device</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_struct" href="structdg_1_1_m_p_i___vector.html">dg::x::DVec</a> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a> = <a class="code hl_function" href="group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">dg::evaluate</a>( function, g2d);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//allocate memory for the result</span></div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_m_p_i___vector.html">dg::x::DVec</a> <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>=<a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//apply the derivative to x and store result in y</span></div>
<div class="line">        <a class="code hl_function" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>(dx, x, y);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//or equivalently</span></div>
<div class="line">        <a class="code hl_function" href="#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>(1., dx, x, 0., y);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The Matrix. </td></tr>
    <tr><td class="paramname">x</td><td>input vector </td></tr>
    <tr><td class="paramname">y</td><td>contains the solution on output (may not alias <code>x</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><code>y</code> may not alias <code>x</code>, the only exception is if <code>MatrixType</code> has the <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code>ContainerType1</code> ==<code>ContainerType2</code> </dd>
<dd>
If y on input contains a NaN or Inf it is not a prioriy clear if it will contain a NaN or Inf on output as well. Our own matrix formats overwrite y and work correctly but for third-party libraries it is worth double-checking.  </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and defines a tensor_category derived from <code><a class="el" href="structdg_1_1_any_matrix_tag.html" title="tensor_category base class">AnyMatrixTag</a></code>. Furthermore, any functor/lambda type with signature <code> void operator()( const ContainerType0&amp;, ContainerType1&amp;) </code>. For example<ul>
<li><code>scalar</code> or <code>Container:</code> Scalars and containers act as diagonal matrices.</li>
<li><code> std::function&lt;void( const ContainerType0&amp;, ContainerType1&amp;)&gt; </code></li>
<li><code><a class="el" href="group__typedefs.html#gae8a29dbadfe53ca55ab6a5b0b417ac2a" title="Host Matrix for derivatives.">dg::HMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga0574e9a1653d69754216f030cd8d4e18">dg::IHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a></code> or <code>std::vector&lt;dg::HVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#ga70cec5715da312a590711436b8b125ff" title="Device Matrix for derivatives.">dg::DMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga813f1498b206af847ea78d2f674643c0">dg::IDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> or <code>std::vector&lt;dg::DVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#ga5511f10a68d58cbd28067c9dbae45977" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code>std::vector&lt;dg::MHVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaa86748811132d3c72c739710777d2b39" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> or <code>std::vector&lt;dg::MDVec&gt;</code> </li>
</ul>
In case of <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> only those <code><a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a></code> functions that have a corresponding member function in the Matrix class (e.g. <code> symv( const ContainerType0&amp;, ContainerType1&amp;); </code> ) can be called. If a <code>Container</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, then the matrix is applied to each of the elements unless the type has the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> or is a Functor type.     </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>

</div>
</div>
<a id="ga53701ba3118a2256a93a4d92a7a8a597" name="ga53701ba3118a2256a93a4d92a7a8a597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53701ba3118a2256a93a4d92a7a8a597">&#9670;&#160;</a></span>transfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class AnotherMatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::blas2::transfer </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnotherMatrixType &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\( y = x\); Generic way to copy and/or convert a Matrix type to a different Matrix type </p>
<p>e.g. from CPU to GPU, or double to float, etc.  </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and defines a tensor_category derived from <code><a class="el" href="structdg_1_1_any_matrix_tag.html" title="tensor_category base class">AnyMatrixTag</a></code>. Furthermore, any functor/lambda type with signature <code> void operator()( const ContainerType0&amp;, ContainerType1&amp;) </code>. For example<ul>
<li><code>scalar</code> or <code>Container:</code> Scalars and containers act as diagonal matrices.</li>
<li><code> std::function&lt;void( const ContainerType0&amp;, ContainerType1&amp;)&gt; </code></li>
<li><code><a class="el" href="group__typedefs.html#gae8a29dbadfe53ca55ab6a5b0b417ac2a" title="Host Matrix for derivatives.">dg::HMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga0574e9a1653d69754216f030cd8d4e18">dg::IHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a></code> or <code>std::vector&lt;dg::HVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#ga70cec5715da312a590711436b8b125ff" title="Device Matrix for derivatives.">dg::DMatrix</a></code> and <code><a class="el" href="group__typedefs.html#ga813f1498b206af847ea78d2f674643c0">dg::IDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a></code> or <code>std::vector&lt;dg::DVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#ga5511f10a68d58cbd28067c9dbae45977" title="MPI Host Matrix for derivatives.">dg::MHMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a></code> or <code>std::vector&lt;dg::MHVec&gt;</code> </li>
<li><code><a class="el" href="group__typedefs.html#gaa86748811132d3c72c739710777d2b39" title="MPI Device Matrix for derivatives.">dg::MDMatrix</a></code> with <code><a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a></code> or <code>std::vector&lt;dg::MDVec&gt;</code> </li>
</ul>
In case of <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> only those <code><a class="el" href="namespacedg_1_1blas2.html" title="BLAS Level 2 routines.">blas2</a></code> functions that have a corresponding member function in the Matrix class (e.g. <code> symv( const ContainerType0&amp;, ContainerType1&amp;); </code> ) can be called. If a <code>Container</code> has the <code><a class="el" href="structdg_1_1_recursive_vector_tag.html" title="This tag indicates composition/recursion.">RecursiveVectorTag</a></code>, then the matrix is applied to each of the elements unless the type has the <code><a class="el" href="structdg_1_1_self_made_matrix_tag.html" title="Indicates that the type has a member function with the same name and interface (up to the matrix itse...">SelfMadeMatrixTag</a></code> or is a Functor type.    </td></tr>
    <tr><td class="paramname">AnotherMatrix</td><td>Another Matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>source </td></tr>
    <tr><td class="paramname">y</td><td>sink </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>y gets resized properly </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:30 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
