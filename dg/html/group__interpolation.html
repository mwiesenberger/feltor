<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: Interpolation, Projection, Transformation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__interpolation.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Interpolation, Projection, Transformation<div class="ingroups"><a class="el" href="group__level3.html">Level 3: Topology and Geometry</a> &raquo; <a class="el" href="group__grid.html">Topological grids and operations</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Interpolation, Projection, Transformation:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__interpolation.svg" width="584" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fast__interpolation.html">Fast interpolation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga37e647e598ec3bc216567a9bc4de69d7" id="r_ga37e647e598ec3bc216567a9bc4de69d7"><td class="memTemplParams" colspan="2">template&lt;class Topology &gt; </td></tr>
<tr class="memitem:ga37e647e598ec3bc216567a9bc4de69d7"><td class="memTemplItemLeft" align="right" valign="top">Topology::host_vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga37e647e598ec3bc216567a9bc4de69d7">dg::forward_transform</a> (const typename Topology::host_vector &amp;in, const Topology &amp;g)</td></tr>
<tr class="memdesc:ga37e647e598ec3bc216567a9bc4de69d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a vector from <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a> (nodal values) to <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> (modal values)  <br /></td></tr>
<tr class="separator:ga37e647e598ec3bc216567a9bc4de69d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebbccbc4e9b740740cd2e9db394d580f" id="r_gaebbccbc4e9b740740cd2e9db394d580f"><td class="memTemplParams" colspan="2">template&lt;class RecursiveHostVector , class real_type , size_t Nd&gt; </td></tr>
<tr class="memitem:gaebbccbc4e9b740740cd2e9db394d580f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaebbccbc4e9b740740cd2e9db394d580f">dg::create::interpolation</a> (const RecursiveHostVector &amp;x, const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;g, std::array&lt; <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>, Nd &gt; <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#ad558bf6ed28fe209c535b30a0b778812">bcx</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:gaebbccbc4e9b740740cd2e9db394d580f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix of a list of points in given grid.  <br /></td></tr>
<tr class="separator:gaebbccbc4e9b740740cd2e9db394d580f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5408320714b86a738a171d4181bd8019" id="r_ga5408320714b86a738a171d4181bd8019"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class real_type , typename  = std::enable_if_t&lt;dg::is_vector_v&lt;host_vector&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga5408320714b86a738a171d4181bd8019"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5408320714b86a738a171d4181bd8019">dg::create::interpolation</a> (const host_vector &amp;x, const <a class="el" href="group__gridtypes.html#gaad074a7623ceb45cacfb14c46fd721f0">RealGrid1d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#ad558bf6ed28fe209c535b30a0b778812">bcx</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:ga5408320714b86a738a171d4181bd8019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <br /></td></tr>
<tr class="separator:ga5408320714b86a738a171d4181bd8019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495a33999511524f06c6fd90332fce69" id="r_ga495a33999511524f06c6fd90332fce69"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class real_type &gt; </td></tr>
<tr class="memitem:ga495a33999511524f06c6fd90332fce69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga495a33999511524f06c6fd90332fce69">dg::create::interpolation</a> (const host_vector &amp;x, const host_vector &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, const <a class="el" href="group__gridtypes.html#ga1f871b7adbc225c55a572e3e2a1f8857">aRealTopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#ad558bf6ed28fe209c535b30a0b778812">bcx</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a2581340f1c6a2fcb83593d4fb46d28fe">bcy</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:ga495a33999511524f06c6fd90332fce69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <br /></td></tr>
<tr class="separator:ga495a33999511524f06c6fd90332fce69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a53cd4da2918b6a329c6d910eb4d8b" id="r_ga11a53cd4da2918b6a329c6d910eb4d8b"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class real_type &gt; </td></tr>
<tr class="memitem:ga11a53cd4da2918b6a329c6d910eb4d8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga11a53cd4da2918b6a329c6d910eb4d8b">dg::create::interpolation</a> (const host_vector &amp;x, const host_vector &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, const host_vector &amp;<a class="el" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>, const <a class="el" href="group__gridtypes.html#gaf4f6d4e3eca40ba3110f9f25f14bd861">aRealTopology3d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#ad558bf6ed28fe209c535b30a0b778812">bcx</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a2581340f1c6a2fcb83593d4fb46d28fe">bcy</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:ga11a53cd4da2918b6a329c6d910eb4d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <br /></td></tr>
<tr class="separator:ga11a53cd4da2918b6a329c6d910eb4d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada276a4b80de69bcb190e19225116961" id="r_gada276a4b80de69bcb190e19225116961"><td class="memTemplParams" colspan="2">template&lt;class real_type , size_t Nd&gt; </td></tr>
<tr class="memitem:gada276a4b80de69bcb190e19225116961"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gada276a4b80de69bcb190e19225116961">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;g_old, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:gada276a4b80de69bcb190e19225116961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <br /></td></tr>
<tr class="separator:gada276a4b80de69bcb190e19225116961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb4674527d3264c59e62178814e886d" id="r_ga7bb4674527d3264c59e62178814e886d"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class real_type &gt; </td></tr>
<tr class="memitem:ga7bb4674527d3264c59e62178814e886d"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7bb4674527d3264c59e62178814e886d">dg::interpolate</a> (<a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a> sp, const host_vector &amp;v, real_type x, const <a class="el" href="group__gridtypes.html#gaad074a7623ceb45cacfb14c46fd721f0">RealGrid1d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#ad558bf6ed28fe209c535b30a0b778812">bcx</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga7bb4674527d3264c59e62178814e886d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector on a single point on a 1d Grid.  <br /></td></tr>
<tr class="separator:ga7bb4674527d3264c59e62178814e886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6456aba0567011aae119a50375155ed" id="r_gac6456aba0567011aae119a50375155ed"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class real_type &gt; </td></tr>
<tr class="memitem:gac6456aba0567011aae119a50375155ed"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac6456aba0567011aae119a50375155ed">dg::interpolate</a> (<a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a> sp, const host_vector &amp;v, real_type x, real_type <a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, 2 &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#ad558bf6ed28fe209c535b30a0b778812">bcx</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a2581340f1c6a2fcb83593d4fb46d28fe">bcy</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:gac6456aba0567011aae119a50375155ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector on a single point on a 2d Grid.  <br /></td></tr>
<tr class="separator:gac6456aba0567011aae119a50375155ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75ffba50020db3fd28a7492685963725" id="r_ga75ffba50020db3fd28a7492685963725"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga75ffba50020db3fd28a7492685963725"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga75ffba50020db3fd28a7492685963725">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g)</td></tr>
<tr class="memdesc:ga75ffba50020db3fd28a7492685963725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <br /></td></tr>
<tr class="separator:ga75ffba50020db3fd28a7492685963725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a3a6a7051887fb870b6939ca534eb19" id="r_ga9a3a6a7051887fb870b6939ca534eb19"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga9a3a6a7051887fb870b6939ca534eb19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9a3a6a7051887fb870b6939ca534eb19">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> globalbcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga9a3a6a7051887fb870b6939ca534eb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <br /></td></tr>
<tr class="separator:ga9a3a6a7051887fb870b6939ca534eb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593f09a474223e99b2ca0512754d0b06" id="r_ga593f09a474223e99b2ca0512754d0b06"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga593f09a474223e99b2ca0512754d0b06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga593f09a474223e99b2ca0512754d0b06">dg::create::interpolation</a> (const thrust::host_vector&lt; real_type &gt; &amp;x, const thrust::host_vector&lt; real_type &gt; &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, const thrust::host_vector&lt; real_type &gt; &amp;<a class="el" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> globalbcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga593f09a474223e99b2ca0512754d0b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix.  <br /></td></tr>
<tr class="separator:ga593f09a474223e99b2ca0512754d0b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007db18367d36ff3c8280f328a59bacd" id="r_ga007db18367d36ff3c8280f328a59bacd"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga007db18367d36ff3c8280f328a59bacd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga007db18367d36ff3c8280f328a59bacd">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga007db18367d36ff3c8280f328a59bacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <br /></td></tr>
<tr class="separator:ga007db18367d36ff3c8280f328a59bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3aa52ee7dcdd9ad1aeb63969a9f33c" id="r_ga4a3aa52ee7dcdd9ad1aeb63969a9f33c"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga4a3aa52ee7dcdd9ad1aeb63969a9f33c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4a3aa52ee7dcdd9ad1aeb63969a9f33c">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:ga4a3aa52ee7dcdd9ad1aeb63969a9f33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <br /></td></tr>
<tr class="separator:ga4a3aa52ee7dcdd9ad1aeb63969a9f33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1974524f41fa04c9d4a66aa125591a6" id="r_gac1974524f41fa04c9d4a66aa125591a6"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gac1974524f41fa04c9d4a66aa125591a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac1974524f41fa04c9d4a66aa125591a6">dg::create::interpolation</a> (const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gac1974524f41fa04c9d4a66aa125591a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.  <br /></td></tr>
<tr class="separator:gac1974524f41fa04c9d4a66aa125591a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3b02e7ec191c8fcf1fc258599617f7" id="r_ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3f3b02e7ec191c8fcf1fc258599617f7">dg::interpolate</a> (<a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a> sp, const thrust::host_vector&lt; real_type &gt; &amp;v, real_type x, real_type <a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#ad558bf6ed28fe209c535b30a0b778812">bcx</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a2581340f1c6a2fcb83593d4fb46d28fe">bcy</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>)</td></tr>
<tr class="memdesc:ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate a vector on a single point on a 2d Grid.  <br /></td></tr>
<tr class="separator:ga3f3b02e7ec191c8fcf1fc258599617f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab34d0804c06195183a781b3cbdecd637" id="r_gab34d0804c06195183a781b3cbdecd637"><td class="memTemplParams" colspan="2">template&lt;class MPITopology , typename  = std::enable_if_t&lt;dg::is_vector_v&lt;    typename MPITopology::host_vector, MPIVectorTag&gt;&gt;&gt; </td></tr>
<tr class="memitem:gab34d0804c06195183a781b3cbdecd637"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; typename MPITopology::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab34d0804c06195183a781b3cbdecd637">dg::create::interpolation</a> (const MPITopology &amp;g_new, const MPITopology &amp;g_old, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:gab34d0804c06195183a781b3cbdecd637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation between two grids.     <br /></td></tr>
<tr class="separator:gab34d0804c06195183a781b3cbdecd637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9383cf8ef0d0cc6af8c1250ecb31dc58" id="r_ga9383cf8ef0d0cc6af8c1250ecb31dc58"><td class="memTemplParams" colspan="2">template&lt;class MPITopology , typename  = std::enable_if_t&lt;dg::is_vector_v&lt;    typename MPITopology::host_vector, MPIVectorTag&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga9383cf8ef0d0cc6af8c1250ecb31dc58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; typename MPITopology::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9383cf8ef0d0cc6af8c1250ecb31dc58">dg::create::projection</a> (const MPITopology &amp;g_new, const MPITopology &amp;g_old, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:ga9383cf8ef0d0cc6af8c1250ecb31dc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.     <br /></td></tr>
<tr class="separator:ga9383cf8ef0d0cc6af8c1250ecb31dc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16b16ca05d2978f4838cb59c6d62572c" id="r_ga16b16ca05d2978f4838cb59c6d62572c"><td class="memTemplParams" colspan="2">template&lt;class RecursiveHostVector , class real_type , size_t Nd&gt; </td></tr>
<tr class="memitem:ga16b16ca05d2978f4838cb59c6d62572c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga16b16ca05d2978f4838cb59c6d62572c">dg::create::interpolation</a> (const RecursiveHostVector &amp;x, const <a class="el" href="structdg_1_1a_real_m_p_i_topology.html">aRealMPITopology</a>&lt; real_type, Nd &gt; &amp;g, std::array&lt; <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>, Nd &gt; <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#ad558bf6ed28fe209c535b30a0b778812">bcx</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:ga16b16ca05d2978f4838cb59c6d62572c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create interpolation matrix of a list of points in given grid.     <br /></td></tr>
<tr class="separator:ga16b16ca05d2978f4838cb59c6d62572c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a590b06f4dddde89fc62894e4b0a66" id="r_ga45a590b06f4dddde89fc62894e4b0a66"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class real_type &gt; </td></tr>
<tr class="memitem:ga45a590b06f4dddde89fc62894e4b0a66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga45a590b06f4dddde89fc62894e4b0a66">dg::create::interpolation</a> (const host_vector &amp;x, const <a class="el" href="group__gridtypes.html#ga74537ff463fb03f8263a9e76ea6c8518">RealMPIGrid1d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#ad558bf6ed28fe209c535b30a0b778812">bcx</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:ga45a590b06f4dddde89fc62894e4b0a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an MPI row distributed interpolation 1d matrix.  <br /></td></tr>
<tr class="separator:ga45a590b06f4dddde89fc62894e4b0a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a3714a53a8d7193dc17e210234b1d00" id="r_ga2a3714a53a8d7193dc17e210234b1d00"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class real_type &gt; </td></tr>
<tr class="memitem:ga2a3714a53a8d7193dc17e210234b1d00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2a3714a53a8d7193dc17e210234b1d00">dg::create::interpolation</a> (const host_vector &amp;x, const host_vector &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, const <a class="el" href="group__gridtypes.html#ga43e0e52ba9b755712ed56d9acd247396">aRealMPITopology2d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#ad558bf6ed28fe209c535b30a0b778812">bcx</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a2581340f1c6a2fcb83593d4fb46d28fe">bcy</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:ga2a3714a53a8d7193dc17e210234b1d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an MPI row distributed interpolation 2d matrix.  <br /></td></tr>
<tr class="separator:ga2a3714a53a8d7193dc17e210234b1d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70cdde080cfad650685ee4faca594693" id="r_ga70cdde080cfad650685ee4faca594693"><td class="memTemplParams" colspan="2">template&lt;class host_vector , class real_type &gt; </td></tr>
<tr class="memitem:ga70cdde080cfad650685ee4faca594693"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga70cdde080cfad650685ee4faca594693">dg::create::interpolation</a> (const host_vector &amp;x, const host_vector &amp;<a class="el" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, const host_vector &amp;<a class="el" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>, const <a class="el" href="group__gridtypes.html#ga09f163590f7040fb0341c710e9e3b5ee">aRealMPITopology3d</a>&lt; real_type &gt; &amp;g, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#ad558bf6ed28fe209c535b30a0b778812">bcx</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> <a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#a2581340f1c6a2fcb83593d4fb46d28fe">bcy</a>=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz=<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:ga70cdde080cfad650685ee4faca594693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an MPI row distributed interpolation 3d matrix.  <br /></td></tr>
<tr class="separator:ga70cdde080cfad650685ee4faca594693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb04927dd3fd194a8c2b483abf48995" id="r_gaeeb04927dd3fd194a8c2b483abf48995"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gaeeb04927dd3fd194a8c2b483abf48995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaeeb04927dd3fd194a8c2b483abf48995">dg::create::diagonal</a> (const thrust::host_vector&lt; real_type &gt; &amp;diagonal)</td></tr>
<tr class="memdesc:gaeeb04927dd3fd194a8c2b483abf48995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a diagonal matrix.  <br /></td></tr>
<tr class="separator:gaeeb04927dd3fd194a8c2b483abf48995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9fd7987548f9e522b8705c5a2786964" id="r_gaa9fd7987548f9e522b8705c5a2786964"><td class="memTemplParams" colspan="2">template&lt;class real_type , size_t Nd&gt; </td></tr>
<tr class="memitem:gaa9fd7987548f9e522b8705c5a2786964"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa9fd7987548f9e522b8705c5a2786964">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;g_old, std::string method=&quot;dg&quot;)</td></tr>
<tr class="memdesc:gaa9fd7987548f9e522b8705c5a2786964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a projection between two grids.  <br /></td></tr>
<tr class="separator:gaa9fd7987548f9e522b8705c5a2786964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe880360a51752c79b121f72902128b8" id="r_gafe880360a51752c79b121f72902128b8"><td class="memTemplParams" colspan="2">template&lt;class real_type , size_t Nd&gt; </td></tr>
<tr class="memitem:gafe880360a51752c79b121f72902128b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gafe880360a51752c79b121f72902128b8">dg::create::transformation</a> (const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;g_old)</td></tr>
<tr class="memdesc:gafe880360a51752c79b121f72902128b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transformation matrix between two grids.  <br /></td></tr>
<tr class="separator:gafe880360a51752c79b121f72902128b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806b09a999f0b58b468894efb5903aa3" id="r_ga806b09a999f0b58b468894efb5903aa3"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga806b09a999f0b58b468894efb5903aa3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga806b09a999f0b58b468894efb5903aa3">dg::create::projection</a> (const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;g_old, std::string method=&quot;dg&quot;)</td></tr>
<tr class="separator:ga806b09a999f0b58b468894efb5903aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb6157151aaff977747ea3bec9fc7a13" id="r_gafb6157151aaff977747ea3bec9fc7a13"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:gafb6157151aaff977747ea3bec9fc7a13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gafb6157151aaff977747ea3bec9fc7a13">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;g_old, std::string method=&quot;dg&quot;)</td></tr>
<tr class="separator:gafb6157151aaff977747ea3bec9fc7a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43730c3c5dbc66ee6b038f44aec7d11e" id="r_ga43730c3c5dbc66ee6b038f44aec7d11e"><td class="memTemplParams" colspan="2">template&lt;class real_type &gt; </td></tr>
<tr class="memitem:ga43730c3c5dbc66ee6b038f44aec7d11e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga43730c3c5dbc66ee6b038f44aec7d11e">dg::create::projection</a> (const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_new, const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;g_old, std::string method=&quot;dg&quot;)</td></tr>
<tr class="separator:ga43730c3c5dbc66ee6b038f44aec7d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaeeb04927dd3fd194a8c2b483abf48995" name="gaeeb04927dd3fd194a8c2b483abf48995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeb04927dd3fd194a8c2b483abf48995">&#9670;&#160;</a></span>diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::diagonal </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>diagonal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a diagonal matrix. </p>
<p>This matrix is given by \( D_{ij} = d_i \delta_{ij}\) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagonal</td><td>The diagonal elements d_i </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>diagonal matrix </dd></dl>

</div>
</div>
<a id="ga37e647e598ec3bc216567a9bc4de69d7" name="ga37e647e598ec3bc216567a9bc4de69d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37e647e598ec3bc216567a9bc4de69d7">&#9670;&#160;</a></span>forward_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Topology &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Topology::host_vector dg::forward_transform </td>
          <td>(</td>
          <td class="paramtype">const typename Topology::host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Topology &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a vector from <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a> (nodal values) to <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> (modal values) </p>
<p>This can speedup the <a class="el" href="#ga7bb4674527d3264c59e62178814e886d" title="Interpolate a vector on a single point on a 1d Grid.">dg::interpolate</a> function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input </td></tr>
    <tr><td class="paramname">g</td><td>A grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7bb4674527d3264c59e62178814e886d" title="Interpolate a vector on a single point on a 1d Grid.">dg::interpolate</a> </dd></dl>

</div>
</div>
<a id="ga7bb4674527d3264c59e62178814e886d" name="ga7bb4674527d3264c59e62178814e886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bb4674527d3264c59e62178814e886d">&#9670;&#160;</a></span>interpolate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type dg::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a></td>          <td class="paramname"><span class="paramname"><em>sp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__gridtypes.html#gaad074a7623ceb45cacfb14c46fd721f0">RealGrid1d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector on a single point on a 1d Grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td>Indicate whether the elements of the vector v are in xspace (nodal values) or lspace (modal values) (choose <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a> if you don't know what is going on here, It is faster to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> so consider transforming v using <a class="el" href="#ga37e647e598ec3bc216567a9bc4de69d7" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> if you do it very many times) </td></tr>
    <tr><td class="paramname">v</td><td>The vector to interpolate </td></tr>
    <tr><td class="paramname">x</td><td>X-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated point </dd></dl>

</div>
</div>
<a id="gac6456aba0567011aae119a50375155ed" name="gac6456aba0567011aae119a50375155ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6456aba0567011aae119a50375155ed">&#9670;&#160;</a></span>interpolate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type dg::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a></td>          <td class="paramname"><span class="paramname"><em>sp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, 2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector on a single point on a 2d Grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td>Indicate whether the elements of the vector v are in xspace (nodal values) or lspace (modal values) (choose <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a> if you don't know what is going on here, It is faster to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> so consider transforming v using <a class="el" href="#ga37e647e598ec3bc216567a9bc4de69d7" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> if you do it very many times) </td></tr>
    <tr><td class="paramname">v</td><td>The vector to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a>, or <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> s.a. <code><a class="el" href="#ga37e647e598ec3bc216567a9bc4de69d7" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a></code> </td></tr>
    <tr><td class="paramname">x</td><td>X-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.    </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated point </dd></dl>

</div>
</div>
<a id="ga3f3b02e7ec191c8fcf1fc258599617f7" name="ga3f3b02e7ec191c8fcf1fc258599617f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f3b02e7ec191c8fcf1fc258599617f7">&#9670;&#160;</a></span>interpolate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type dg::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga720a6f709941a075d5c8f60ef07c619f">dg::space</a></td>          <td class="paramname"><span class="paramname"><em>sp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_type</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate a vector on a single point on a 2d Grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td>Indicate whether the elements of the vector v are in xspace or lspace (choose <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a> if you don't know what is going on here, It is faster to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> so consider transforming v using <a class="el" href="#ga37e647e598ec3bc216567a9bc4de69d7" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> if you do it very many times) </td></tr>
    <tr><td class="paramname">v</td><td>The vector to interpolate in <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fa235752009881e59ab3ad8de2b904cb85" title="Configuration space &quot;nodal values&quot;.">dg::xspace</a>, or <a class="el" href="group__creation.html#gga720a6f709941a075d5c8f60ef07c619fadb68409ea987968e600f19adcb7b4538" title="DG Polynomial space &quot;modal values&quot;.">dg::lspace</a> s.a. <a class="el" href="#ga37e647e598ec3bc216567a9bc4de69d7" title="Transform a vector from dg::xspace (nodal values) to dg::lspace (modal values)">dg::forward_transform( )</a> </td></tr>
    <tr><td class="paramname">x</td><td>X-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinate of interpolation point </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.    </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated point </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>g.contains(x,y)</code> must return true </dd></dl>

</div>
</div>
<a id="gada276a4b80de69bcb190e19225116961" name="gada276a4b80de69bcb190e19225116961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada276a4b80de69bcb190e19225116961">&#9670;&#160;</a></span>interpolation() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type , size_t Nd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__fast__interpolation.html#ga86f8843f32a0018fc20fb7bba8a6b61e" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid. The boundaries of the new grid must lie within the boundaries of the old grid.  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Explicit zeros in the returned matrix are removed </dd></dl>

</div>
</div>
<a id="ga4a3aa52ee7dcdd9ad1aeb63969a9f33c" name="ga4a3aa52ee7dcdd9ad1aeb63969a9f33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a3aa52ee7dcdd9ad1aeb63969a9f33c">&#9670;&#160;</a></span>interpolation() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_old</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="gac1974524f41fa04c9d4a66aa125591a6" name="gac1974524f41fa04c9d4a66aa125591a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1974524f41fa04c9d4a66aa125591a6">&#9670;&#160;</a></span>interpolation() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_old</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga2a3714a53a8d7193dc17e210234b1d00" name="ga2a3714a53a8d7193dc17e210234b1d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a3714a53a8d7193dc17e210234b1d00">&#9670;&#160;</a></span>interpolation() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__gridtypes.html#ga43e0e52ba9b755712ed56d9acd247396">aRealMPITopology2d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an MPI row distributed interpolation 2d matrix. </p>
<dl class="section note"><dt>Note</dt><dd>In the MPI version each process creates a local interpolation matrix with local row and global column indices using the given points and <div class="fragment"><div class="line"><span class="keyword">auto</span> mat = <a class="code hl_function" href="#gaebbccbc4e9b740740cd2e9db394d580f">dg::create::interpolation</a> ( x,<a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, g.global(), bcx, bcy, method);</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_function" href="group__mpi__matvec.html#ga9057cdd9d1b8f55ed00a91eca7781cb2">dg::make_mpi_matrix</a>( mat, g);</div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">dg::coo2d::y</a></div><div class="ttdeci">@ y</div><div class="ttdoc">y direction</div></div>
<div class="ttc" id="agroup__interpolation_html_gaebbccbc4e9b740740cd2e9db394d580f"><div class="ttname"><a href="#gaebbccbc4e9b740740cd2e9db394d580f">dg::create::interpolation</a></div><div class="ttdeci">dg::SparseMatrix&lt; int, real_type, thrust::host_vector &gt; interpolation(const RecursiveHostVector &amp;x, const aRealTopology&lt; real_type, Nd &gt; &amp;g, std::array&lt; dg::bc, Nd &gt; bcx, std::string method=&quot;dg&quot;)</div><div class="ttdoc">Create interpolation matrix of a list of points in given grid.</div><div class="ttdef"><b>Definition</b> interpolation.h:433</div></div>
<div class="ttc" id="agroup__mpi__matvec_html_ga9057cdd9d1b8f55ed00a91eca7781cb2"><div class="ttname"><a href="group__mpi__matvec.html#ga9057cdd9d1b8f55ed00a91eca7781cb2">dg::make_mpi_matrix</a></div><div class="ttdeci">dg::MIHMatrix_t&lt; real_type &gt; make_mpi_matrix(const dg::IHMatrix_t&lt; real_type &gt; &amp;global_cols, const ConversionPolicy &amp;col_policy)</div><div class="ttdoc">Convert a (row-distributed) matrix with local row and global column indices to a row distributed MPI ...</div><div class="ttdef"><b>Definition</b> mpi_projection.h:50</div></div>
</div><!-- fragment --></dd></dl>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><div class="fragment"><div class="line">        <span class="comment">//create equidistant values</span></div>
<div class="line">        thrust::host_vector&lt;double&gt; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x);</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.ny(); i++)</div>
<div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.nx(); j++)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//intentionally set values outside the grid domain</span></div>
<div class="line">                <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[i*g.Nx()*g.nx() + j] =</div>
<div class="line">                        g.x0() + g.lx() + (j+0.5)*g.hx()/(double)(g.nx());</div>
<div class="line">                <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[i*g.Nx()*g.ny() + j] =</div>
<div class="line">                        g.y0() + 2*g.ly() + (i+0.5)*g.hy()/(double)(g.ny());</div>
<div class="line">            }</div>
<div class="line">        <span class="comment">//use DIR because the coo.2d is zero on the right boundary</span></div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_ell_sparse_block_mat.html">Matrix</a> B = <a class="code hl_function" href="#gaebbccbc4e9b740740cd2e9db394d580f">dg::create::interpolation</a>( x, y, g, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <span class="stringliteral">&quot;dg&quot;</span>);</div>
<div class="line">        <span class="comment">//values outside the grid are mirrored back in</span></div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code hl_function" href="group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">dg::evaluate</a>( function, g);</div>
<div class="line">        thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">        <a class="code hl_function" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.    </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>removes explicit zeros in the interpolation matrix    </dd></dl>

</div>
</div>
<a id="ga495a33999511524f06c6fd90332fce69" name="ga495a33999511524f06c6fd90332fce69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga495a33999511524f06c6fd90332fce69">&#9670;&#160;</a></span>interpolation() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__gridtypes.html#ga1f871b7adbc225c55a572e3e2a1f8857">aRealTopology2d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><div class="fragment"><div class="line">        <span class="comment">//create equidistant values</span></div>
<div class="line">        thrust::host_vector&lt;double&gt; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x);</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.ny(); i++)</div>
<div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.nx(); j++)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//intentionally set values outside the grid domain</span></div>
<div class="line">                <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[i*g.Nx()*g.nx() + j] =</div>
<div class="line">                        g.x0() + g.lx() + (j+0.5)*g.hx()/(double)(g.nx());</div>
<div class="line">                <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[i*g.Nx()*g.ny() + j] =</div>
<div class="line">                        g.y0() + 2*g.ly() + (i+0.5)*g.hy()/(double)(g.ny());</div>
<div class="line">            }</div>
<div class="line">        <span class="comment">//use DIR because the coo.2d is zero on the right boundary</span></div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_ell_sparse_block_mat.html">Matrix</a> B = <a class="code hl_function" href="#gaebbccbc4e9b740740cd2e9db394d580f">dg::create::interpolation</a>( x, y, g, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <span class="stringliteral">&quot;dg&quot;</span>);</div>
<div class="line">        <span class="comment">//values outside the grid are mirrored back in</span></div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code hl_function" href="group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">dg::evaluate</a>( function, g);</div>
<div class="line">        thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">        <a class="code hl_function" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.    </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>removes explicit zeros in the interpolation matrix </dd></dl>

</div>
</div>
<a id="ga70cdde080cfad650685ee4faca594693" name="ga70cdde080cfad650685ee4faca594693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70cdde080cfad650685ee4faca594693">&#9670;&#160;</a></span>interpolation() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__gridtypes.html#ga09f163590f7040fb0341c710e9e3b5ee">aRealMPITopology3d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcz</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an MPI row distributed interpolation 3d matrix. </p>
<dl class="section note"><dt>Note</dt><dd>In the MPI version each process creates a local interpolation matrix with local row and global column indices using the given points <div class="fragment"><div class="line"><span class="keyword">auto</span> mat = <a class="code hl_function" href="#gaebbccbc4e9b740740cd2e9db394d580f">dg::create::interpolation</a> ( x,<a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>,<a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>, g.global(), bcx, bcy, bcz, method);</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_function" href="group__mpi__matvec.html#ga9057cdd9d1b8f55ed00a91eca7781cb2">dg::make_mpi_matrix</a>( mat, g);</div>
<div class="ttc" id="agroup__creation_html_gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7"><div class="ttname"><a href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">dg::coo3d::z</a></div><div class="ttdeci">@ z</div><div class="ttdoc">z direction</div></div>
</div><!-- fragment --></dd></dl>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">        <span class="comment">//create equidistant values</span></div>
<div class="line">        thrust::host_vector&lt;double&gt; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x), <a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>(x);</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> k=0; k&lt;g.nz()*g.Nz(); k++)</div>
<div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.ny(); i++)</div>
<div class="line">                <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.nx(); j++)</div>
<div class="line">                {</div>
<div class="line">                    <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                            g.x0() + (j+0.5)*g.hx()/(double)(g.nx());</div>
<div class="line">                    <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                            g.y0() + (i+0.5)*g.hy()/(double)(g.ny());</div>
<div class="line">                    <a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                            g.z0() + (k+0.5)*g.hz()/(double)(g.nz());</div>
<div class="line">                }</div>
<div class="line">        <span class="keyword">auto</span> method = GENERATE( as&lt;std::string&gt;{}, <span class="stringliteral">&quot;nearest&quot;</span>, <span class="stringliteral">&quot;linear&quot;</span>, <span class="stringliteral">&quot;dg&quot;</span>, <span class="stringliteral">&quot;cubic&quot;</span>);</div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_ell_sparse_block_mat.html">Matrix</a> B = <a class="code hl_function" href="#gaebbccbc4e9b740740cd2e9db394d580f">dg::create::interpolation</a>( x, y, z, g, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>,</div>
<div class="line">                method);</div>
<div class="line">        <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code hl_function" href="group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">dg::evaluate</a>( function, g);</div>
<div class="line">        thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">        <a class="code hl_function" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points (<code>z.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.    </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">bcz</td><td>analogous to <code>bcx</code>, applies to z direction  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>removes explicit zeros from the interpolation matrix </dd>
<dd>
all points (x, y, z) must lie within or on the boundaries of g    </dd></dl>

</div>
</div>
<a id="ga11a53cd4da2918b6a329c6d910eb4d8b" name="ga11a53cd4da2918b6a329c6d910eb4d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11a53cd4da2918b6a329c6d910eb4d8b">&#9670;&#160;</a></span>interpolation() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__gridtypes.html#gaf4f6d4e3eca40ba3110f9f25f14bd861">aRealTopology3d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcz</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. </p><div class="fragment"><div class="line">        <span class="comment">//create equidistant values</span></div>
<div class="line">        thrust::host_vector&lt;double&gt; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>( g.size()), <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>(x), <a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>(x);</div>
<div class="line">        <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> k=0; k&lt;g.nz()*g.Nz(); k++)</div>
<div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;g.Ny()*g.ny(); i++)</div>
<div class="line">                <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;g.Nx()*g.nx(); j++)</div>
<div class="line">                {</div>
<div class="line">                    <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a9dd4e461268c8034f5c8564e155c67a6">x</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                            g.x0() + (j+0.5)*g.hx()/(double)(g.nx());</div>
<div class="line">                    <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                            g.y0() + (i+0.5)*g.hy()/(double)(g.ny());</div>
<div class="line">                    <a class="code hl_enumvalue" href="group__creation.html#gga4de4a3d7cd219a55affa992871e8598fafbade9e36a3f36d3d676c1b808451dd7">z</a>[(k*g.Ny()*g.ny() + i)*g.Nx()*g.nx() + j] =</div>
<div class="line">                            g.z0() + (k+0.5)*g.hz()/(double)(g.nz());</div>
<div class="line">                }</div>
<div class="line">        <span class="keyword">auto</span> method = GENERATE( as&lt;std::string&gt;{}, <span class="stringliteral">&quot;nearest&quot;</span>, <span class="stringliteral">&quot;linear&quot;</span>, <span class="stringliteral">&quot;dg&quot;</span>, <span class="stringliteral">&quot;cubic&quot;</span>);</div>
<div class="line">        <a class="code hl_struct" href="structdg_1_1_ell_sparse_block_mat.html">Matrix</a> B = <a class="code hl_function" href="#gaebbccbc4e9b740740cd2e9db394d580f">dg::create::interpolation</a>( x, y, z, g, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a>, <a class="code hl_enumvalue" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a>,</div>
<div class="line">                method);</div>
<div class="line">        <span class="keyword">const</span> thrust::host_vector&lt;double&gt; vec = <a class="code hl_function" href="group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">dg::evaluate</a>( function, g);</div>
<div class="line">        thrust::host_vector&lt;double&gt; inter(vec);</div>
<div class="line">        <a class="code hl_function" href="group__blas2.html#gac3840941bd2bb1d64c6ca3fef1f1b960">dg::blas2::symv</a>( B, vec, inter);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points (<code>y.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points (<code>z.size()</code> must equal <code>x.size()</code>) </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.    </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">bcz</td><td>analogous to <code>bcx</code>, applies to z direction  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>removes explicit zeros from the interpolation matrix </dd>
<dd>
all points (x, y, z) must lie within or on the boundaries of g </dd></dl>

</div>
</div>
<a id="ga5408320714b86a738a171d4181bd8019" name="ga5408320714b86a738a171d4181bd8019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5408320714b86a738a171d4181bd8019">&#9670;&#160;</a></span>interpolation() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class real_type , typename  = std::enable_if_t&lt;dg::is_vector_v&lt;host_vector&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__gridtypes.html#gaad074a7623ceb45cacfb14c46fd721f0">RealGrid1d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>removes explicit zeros in the interpolation matrix </dd></dl>

</div>
</div>
<a id="ga45a590b06f4dddde89fc62894e4b0a66" name="ga45a590b06f4dddde89fc62894e4b0a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45a590b06f4dddde89fc62894e4b0a66">&#9670;&#160;</a></span>interpolation() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class host_vector , class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const host_vector &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__gridtypes.html#ga74537ff463fb03f8263a9e76ea6c8518">RealMPIGrid1d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an MPI row distributed interpolation 1d matrix. </p>
<dl class="section note"><dt>Note</dt><dd>In the MPI version each process creates a local interpolation matrix with local row and global column indices using the given points and <div class="fragment"><div class="line"><span class="keyword">auto</span> mat = <a class="code hl_function" href="#gaebbccbc4e9b740740cd2e9db394d580f">dg::create::interpolation</a> ( x, g.global(), bcx, method);</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_function" href="group__mpi__matvec.html#ga9057cdd9d1b8f55ed00a91eca7781cb2">dg::make_mpi_matrix</a>( mat, g);</div>
</div><!-- fragment --></dd></dl>
<p>The created matrix has <code>g.size()</code> columns and <code>x.size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n()</code> . When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>removes explicit zeros in the interpolation matrix    </dd></dl>

</div>
</div>
<a id="gab34d0804c06195183a781b3cbdecd637" name="gab34d0804c06195183a781b3cbdecd637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab34d0804c06195183a781b3cbdecd637">&#9670;&#160;</a></span>interpolation() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MPITopology , typename  = std::enable_if_t&lt;dg::is_vector_v&lt;    typename MPITopology::host_vector, MPIVectorTag&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; typename MPITopology::value_type &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const MPITopology &amp;</td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPITopology &amp;</td>          <td class="paramname"><span class="paramname"><em>g_old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids.    </p>
<p>This matrix interpolates vectors on the old grid <code>g_old</code> to the Gaussian nodes of the new grid <code>g_new</code>. The interpolation is of the order <code>g_old.n()</code> </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new grid you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__fast__interpolation.html#ga86f8843f32a0018fc20fb7bba8a6b61e" title="Create interpolation matrix for integer multipliers.">dg::create::fast_interpolation</a> functions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid. The boundaries of the new grid must lie within the boundaries of the old grid.  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix with <code>g_old.size()</code> columns and <code>g_new.size()</code> rows </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Explicit zeros in the returned matrix are removed    </dd></dl>

</div>
</div>
<a id="ga007db18367d36ff3c8280f328a59bacd" name="ga007db18367d36ff3c8280f328a59bacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga007db18367d36ff3c8280f328a59bacd">&#9670;&#160;</a></span>interpolation() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_old</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation between two grids. </p>
<p>This matrix can be applied to vectors defined on the old grid to obtain its values on the new grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new points </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd></dl>

</div>
</div>
<a id="ga16b16ca05d2978f4838cb59c6d62572c" name="ga16b16ca05d2978f4838cb59c6d62572c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16b16ca05d2978f4838cb59c6d62572c">&#9670;&#160;</a></span>interpolation() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RecursiveHostVector , class real_type , size_t Nd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; real_type &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const RecursiveHostVector &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_m_p_i_topology.html">aRealMPITopology</a>&lt; real_type, Nd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>, Nd &gt;</td>          <td class="paramname"><span class="paramname"><em>bcx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix of a list of points in given grid.    </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x[0].size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n(u)</code> in each direction. When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Nd</td><td>Number of dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Must be of size <code>Nd</code> coordinates of interpolation points (<code>x[0]</code> is the list of x-coordinates, <code>x[1]</code> is the list of y-coordinates, etc. </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.       </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebbccbc4e9b740740cd2e9db394d580f" name="gaebbccbc4e9b740740cd2e9db394d580f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebbccbc4e9b740740cd2e9db394d580f">&#9670;&#160;</a></span>interpolation() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RecursiveHostVector , class real_type , size_t Nd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const RecursiveHostVector &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a>, Nd &gt;</td>          <td class="paramname"><span class="paramname"><em>bcx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix of a list of points in given grid. </p>
<p>The created matrix has <code>g.size()</code> columns and <code>x[0].size()</code> rows. Per default it uses polynomial interpolation given by the dG polynomials, i.e. the interpolation has order <code>g.n(u)</code> in each direction. When applied to a vector the result contains the interpolated values at the given interpolation points. The given boundary conditions determine how interpolation points outside the grid domain are treated. </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Nd</td><td>Number of dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Must be of size <code>Nd</code> coordinates of interpolation points (<code>x[0]</code> is the list of x-coordinates, <code>x[1]</code> is the list of y-coordinates, etc. </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcx</td><td>determines what to do when a point lies outside the boundary in x. If <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code>, the point will be shifted topologically back onto the domain. Else the point will be mirrored at the boundary: <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> will then simply interpolate at the resulting point, <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> will take the negative of the interpolation. (<code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ae1ff2b85fda37868973c8059e3ca3a79" title="Dirichlet on left, Neumann on right boundary.">dg::DIR_NEU</a></code> and <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a5832830f6fb508b8932dbafad3d1b57c" title="Neumann on left, Dirichlet on right boundary.">dg::NEU_DIR</a></code> apply <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10" title="Neumann on both boundaries.">dg::NEU</a></code> / <code><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6" title="homogeneous dirichlet boundaries">dg::DIR</a></code> to the respective left or right boundary ) This means the result of the interpolation is as if the interpolated function were Fourier transformed with the correct boundary condition and thus extended beyond the grid boundaries. Note that if a point lies directly on the boundary between two grid cells, the value of the polynomial to the right is taken.     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga75ffba50020db3fd28a7492685963725" name="ga75ffba50020db3fd28a7492685963725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75ffba50020db3fd28a7492685963725">&#9670;&#160;</a></span>interpolation() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="ga9a3a6a7051887fb870b6939ca534eb19" name="ga9a3a6a7051887fb870b6939ca534eb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a3a6a7051887fb870b6939ca534eb19">&#9670;&#160;</a></span>interpolation() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>globalbcz</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">globalbcz</td><td>NEU for common interpolation. DIR for zeros at Box</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>

</div>
</div>
<a id="ga593f09a474223e99b2ca0512754d0b06" name="ga593f09a474223e99b2ca0512754d0b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga593f09a474223e99b2ca0512754d0b06">&#9670;&#160;</a></span>interpolation() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::interpolation </td>
          <td>(</td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thrust::host_vector&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>globalbcz</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create interpolation matrix. </p>
<p>The matrix, when applied to a vector, interpolates its values to the given coordinates. In z-direction only a nearest neighbor interpolation is used </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">z</td><td>Z-coordinates of interpolation points </td></tr>
    <tr><td class="paramname">g</td><td>The Grid on which to operate </td></tr>
    <tr><td class="paramname">globalbcz</td><td>determines what to do if values lie exactly on the boundary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The values of x, y and z must lie within the boundaries of g </dd></dl>

</div>
</div>
<a id="gaa9fd7987548f9e522b8705c5a2786964" name="gaa9fd7987548f9e522b8705c5a2786964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9fd7987548f9e522b8705c5a2786964">&#9670;&#160;</a></span>projection() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type , size_t Nd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids. </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__fast__interpolation.html#gaf7bbb2a10367d2c5a75ce93de72b2004" title="Create projecton matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="#gafe880360a51752c79b121f72902128b8" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid and if the number of polynomial coefficients is lower or the same in the new grid </dd></dl>

</div>
</div>
<a id="gafb6157151aaff977747ea3bec9fc7a13" name="gafb6157151aaff977747ea3bec9fc7a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb6157151aaff977747ea3bec9fc7a13">&#9670;&#160;</a></span>projection() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x2d.html">aRealTopologyX2d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga43730c3c5dbc66ee6b038f44aec7d11e" name="ga43730c3c5dbc66ee6b038f44aec7d11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43730c3c5dbc66ee6b038f44aec7d11e">&#9670;&#160;</a></span>projection() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology_x3d.html">aRealTopologyX3d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9383cf8ef0d0cc6af8c1250ecb31dc58" name="ga9383cf8ef0d0cc6af8c1250ecb31dc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9383cf8ef0d0cc6af8c1250ecb31dc58">&#9670;&#160;</a></span>projection() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MPITopology , typename  = std::enable_if_t&lt;dg::is_vector_v&lt;    typename MPITopology::host_vector, MPIVectorTag&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga52339ea3efd3f2a55110c7bd63b17c9d">dg::MIHMatrix_t</a>&lt; typename MPITopology::value_type &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const MPITopology &amp;</td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPITopology &amp;</td>          <td class="paramname"><span class="paramname"><em>g_old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a projection between two grids.    </p>
<p>This matrix can be applied to vectors defined on the old (fine) grid to obtain its values projected on the new (coarse) grid. (Projection means that the projection integrals over the base polynomials are computed). If the fine grid is a multiple of the coarse grid, the integral value of the projected vector will be conserved and the difference in the L2 norm between old and new vector small. The projection matrix is the adjoint of the interpolation matrix </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a> </dd>
<dd>
for integer multiples between old and new <a class="el" href="group__grid.html">Topological grids and operations</a> you may want <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40" title="Switch for the Timeloop integrate function.">to</a> consider the <a class="el" href="group__fast__interpolation.html#gaf7bbb2a10367d2c5a75ce93de72b2004" title="Create projecton matrix for integer dividers.">dg::create::fast_projection</a> <a class="el" href="group__functions.html" title="For the dg::evaluate and dg::blas1::evaluate functions.">A large collection</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new (coarse) grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old (fine) grid  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Several interpolation methods are available: <b>dg</b> uses the native dG interpolation scheme given by the grid, <b>nearest</b> searches for the nearest point and copies its value, <b>linear</b> searches for the two (in 2d four, etc.) closest points and linearly interpolates their values, <b>cubic</b> searches for the four (in 2d 16, etc) closest points and interpolates a cubic polynomial. Pay attention that <b>linear</b> and <b>cubic</b> entail nearest neighbor <b>communication in mpi</b>.   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projection matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
also check <code><a class="el" href="#gafe880360a51752c79b121f72902128b8" title="Create a transformation matrix between two grids.">dg::create::transformation</a></code>, which is the more general solution </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Projection only works if the number of cells in the fine grid is a multiple of the number of cells in the coarse grid and if the number of polynomial coefficients is lower or the same in the new grid    </dd></dl>

</div>
</div>
<a id="ga806b09a999f0b58b468894efb5903aa3" name="ga806b09a999f0b58b468894efb5903aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga806b09a999f0b58b468894efb5903aa3">&#9670;&#160;</a></span>projection() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1_real_grid_x1d.html">RealGridX1d</a>&lt; real_type &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafe880360a51752c79b121f72902128b8" name="gafe880360a51752c79b121f72902128b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe880360a51752c79b121f72902128b8">&#9670;&#160;</a></span>transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real_type , size_t Nd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_sparse_matrix.html">dg::SparseMatrix</a>&lt; int, real_type, thrust::host_vector &gt; dg::create::transformation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1a_real_topology.html">aRealTopology</a>&lt; real_type, Nd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g_old</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transformation matrix between two grids. </p>
<p>The transformation matrix is probably the most correct way of transforming dG vectors between any two grids of different resolution. It first finds the least common multiple grid (lcm) of the old and the new grid. Then it interpolates the values to the lcm grid and finally projects them back to the new grid. In total we have   </p><p class="formulaDsp">
\[
\mathcal T = P Q
\]
</p>
<p> where \( Q\) is the interpolation matrix and \( P \) the projection. If either new or old grid is already the lcm grid this function reduces to the interpolation/projection function. </p><dl class="section see"><dt>See also</dt><dd><a href="https://www.overleaf.com/read/rpbjsqmmfzyj" target="_blank">Introduction to dg methods</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g_new</td><td>The new grid </td></tr>
    <tr><td class="paramname">g_old</td><td>The old grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformation matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The boundaries of the old grid must lie within the boundaries of the new grid </dd>
<dd>
If the grid are very incompatible the matrix-matrix multiplication can take a while </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:30 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
