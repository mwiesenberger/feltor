<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: MPI utility functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__mpi__utility.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">MPI utility functions<div class="ingroups"><a class="el" href="group__misc.html">Level 99: Miscellaneous additions</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for MPI utility functions:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__mpi__utility.svg" width="598" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mpi__legacy.html">Legacy MPI functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga05ff40a556f837e513fafd7aff7f477e" id="r_ga05ff40a556f837e513fafd7aff7f477e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga05ff40a556f837e513fafd7aff7f477e">dg::mpi_init</a> (int argc, char *argv[])</td></tr>
<tr class="memdesc:ga05ff40a556f837e513fafd7aff7f477e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convencience shortcut: Calls MPI_Init or MPI_Init_thread and inits CUDA devices.  <br /></td></tr>
<tr class="separator:ga05ff40a556f837e513fafd7aff7f477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb9191b679fcecfb09f39dc4ba0fa0a4" id="r_gadb9191b679fcecfb09f39dc4ba0fa0a4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gadb9191b679fcecfb09f39dc4ba0fa0a4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadb9191b679fcecfb09f39dc4ba0fa0a4">dg::mpi_read_as</a> (unsigned num, MPI_Comm comm, std::istream &amp;is=std::cin)</td></tr>
<tr class="memdesc:gadb9191b679fcecfb09f39dc4ba0fa0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read <code>num</code> values from <code>is</code> and broadcast to all processes as type <code>T</code>.  <br /></td></tr>
<tr class="separator:gadb9191b679fcecfb09f39dc4ba0fa0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d17e061d25fe3cd6c334c6a0661100c" id="r_ga6d17e061d25fe3cd6c334c6a0661100c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6d17e061d25fe3cd6c334c6a0661100c">dg::mpi_read_grid</a> (unsigned &amp;<a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#afd53743d1af6bfa2856255b23b5a41a9">n</a>, std::vector&lt; unsigned &gt; &amp;N, MPI_Comm comm, std::istream &amp;is=std::cin, bool verbose=true, std::ostream &amp;os=std::cout)</td></tr>
<tr class="memdesc:ga6d17e061d25fe3cd6c334c6a0661100c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in grid sizes from <code>is</code>.  <br /></td></tr>
<tr class="separator:ga6d17e061d25fe3cd6c334c6a0661100c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab902ed4cf258e7444b5f0d0341101300" id="r_gab902ed4cf258e7444b5f0d0341101300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab902ed4cf258e7444b5f0d0341101300">dg::mpi_read_grid</a> (unsigned &amp;<a class="elRef" href="../../matrix/html/lanczos__b_8cpp.html#afd53743d1af6bfa2856255b23b5a41a9">n</a>, std::vector&lt; unsigned * &gt; N, MPI_Comm comm, std::istream &amp;is=std::cin, bool verbose=true, std::ostream &amp;os=std::cout)</td></tr>
<tr class="memdesc:gab902ed4cf258e7444b5f0d0341101300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience shortcut allowing a call like.  <br /></td></tr>
<tr class="separator:gab902ed4cf258e7444b5f0d0341101300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga492bf8ec7e709603a5cdd5569766fa2e" id="r_ga492bf8ec7e709603a5cdd5569766fa2e"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga492bf8ec7e709603a5cdd5569766fa2e">dg::mpi_cart_create</a> (MPI_Comm comm_old, std::vector&lt; int &gt; dims, std::vector&lt; int &gt; periods, bool reorder=true)</td></tr>
<tr class="memdesc:ga492bf8ec7e709603a5cdd5569766fa2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience call to <code>MPI_Cart_create</code> preceded by <code>MPI_Dims_create</code>.  <br /></td></tr>
<tr class="separator:ga492bf8ec7e709603a5cdd5569766fa2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b6419f3b219e5f5e6f9fc198e3f62f" id="r_gaa8b6419f3b219e5f5e6f9fc198e3f62f"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa8b6419f3b219e5f5e6f9fc198e3f62f">dg::mpi_cart_create</a> (std::vector&lt; <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> &gt; bcs, std::istream &amp;is=std::cin, MPI_Comm comm_old=MPI_COMM_WORLD, bool reorder=true, bool verbose=true, std::ostream &amp;os=std::cout)</td></tr>
<tr class="memdesc:gaa8b6419f3b219e5f5e6f9fc198e3f62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience call: read in number of processses from istream and create Cartesian MPI communicator.  <br /></td></tr>
<tr class="separator:gaa8b6419f3b219e5f5e6f9fc198e3f62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9983503a764d29bffd43cc93878d2ebb" id="r_ga9983503a764d29bffd43cc93878d2ebb"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9983503a764d29bffd43cc93878d2ebb">dg::mpi_cart_sub</a> (MPI_Comm comm, std::vector&lt; int &gt; remain_dims, bool duplicate=false)</td></tr>
<tr class="memdesc:ga9983503a764d29bffd43cc93878d2ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call and register a call to <code>MPI_Cart_sub</code> with the dg library.  <br /></td></tr>
<tr class="separator:ga9983503a764d29bffd43cc93878d2ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb0e11d4d2ad14c3512f6773e351863f" id="r_gacb0e11d4d2ad14c3512f6773e351863f"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacb0e11d4d2ad14c3512f6773e351863f">dg::mpi_cart_kron</a> (std::vector&lt; MPI_Comm &gt; comms)</td></tr>
<tr class="memdesc:gacb0e11d4d2ad14c3512f6773e351863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Form a Kronecker product among Cartesian communicators.  <br /></td></tr>
<tr class="separator:gacb0e11d4d2ad14c3512f6773e351863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4cc0823c0a10616c32e3ec51036aa9" id="r_ga3a4cc0823c0a10616c32e3ec51036aa9"><td class="memTemplParams" colspan="2">template&lt;class Vector &gt; </td></tr>
<tr class="memitem:ga3a4cc0823c0a10616c32e3ec51036aa9"><td class="memTemplItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3a4cc0823c0a10616c32e3ec51036aa9">dg::mpi_cart_kron</a> (Vector comms)</td></tr>
<tr class="memdesc:ga3a4cc0823c0a10616c32e3ec51036aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience shortcut for <code> return mpi_cart_kron( std::vector&lt;MPI_Comm&gt;(comms.begin(), comms.end()));</code>  <br /></td></tr>
<tr class="separator:ga3a4cc0823c0a10616c32e3ec51036aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1746131a15430071db91f54dc3767d1a" id="r_ga1746131a15430071db91f54dc3767d1a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; MPI_Comm &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1746131a15430071db91f54dc3767d1a">dg::mpi_cart_split</a> (MPI_Comm comm)</td></tr>
<tr class="memdesc:ga1746131a15430071db91f54dc3767d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a Cartesian communicator along each dimensions.  <br /></td></tr>
<tr class="separator:ga1746131a15430071db91f54dc3767d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0776a7caa8efc4f5af2225849c393b13" id="r_ga0776a7caa8efc4f5af2225849c393b13"><td class="memTemplParams" colspan="2">template&lt;size_t Nd&gt; </td></tr>
<tr class="memitem:ga0776a7caa8efc4f5af2225849c393b13"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; MPI_Comm, Nd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0776a7caa8efc4f5af2225849c393b13">dg::mpi_cart_split_as</a> (MPI_Comm comm)</td></tr>
<tr class="memdesc:ga0776a7caa8efc4f5af2225849c393b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>mpi_cart_split</code> but differen return type.  <br /></td></tr>
<tr class="separator:ga0776a7caa8efc4f5af2225849c393b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga492bf8ec7e709603a5cdd5569766fa2e" name="ga492bf8ec7e709603a5cdd5569766fa2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga492bf8ec7e709603a5cdd5569766fa2e">&#9670;&#160;</a></span>mpi_cart_create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm dg::mpi_cart_create </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm_old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>periods</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reorder</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience call to <code>MPI_Cart_create</code> preceded by <code>MPI_Dims_create</code>. </p>
<p>This function is equivalent to </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> size;</div>
<div class="line">MPI_Comm_size( comm_old, &amp;size);</div>
<div class="line"><span class="keywordtype">int</span> ndims = dims.size();</div>
<div class="line">MPI_Dims_create( size, ndims, &amp;dims[0]);</div>
<div class="line">MPI_Comm comm_cart;</div>
<div class="line">MPI_Cart_create( comm_old, dims.size(), &amp;dims[0], periods, reorder, &amp;comm_cart);</div>
<div class="line"><span class="keywordflow">return</span> comm_cart;</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm_old</td><td>input communicator (handle) (parameter used in <code>MPI_Cart_create</code>) </td></tr>
    <tr><td class="paramname">dims</td><td>specify number of processes in each dimensions. (<code>dims.size()</code> determines <code>ndims</code> parameter used in <code>MPI_Cart_create</code>). Elements can be 0 in which case a distribution is automatically chosen in that direction. </td></tr>
    <tr><td class="paramname">periods</td><td>logical array of size <code>ndims</code> specifying whether the grid is periodic (true) or not (false) in each dimension (parameter used in <code>MPI_Cart_create</code> </td></tr>
    <tr><td class="paramname">reorder</td><td>(parameter used in <code>MPI_Cart_create</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>most MPI libraries ignore the <code>reorder</code> parameter </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>communicator with new Cartesian topology (handle) </dd></dl>

</div>
</div>
<a id="gaa8b6419f3b219e5f5e6f9fc198e3f62f" name="gaa8b6419f3b219e5f5e6f9fc198e3f62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b6419f3b219e5f5e6f9fc198e3f62f">&#9670;&#160;</a></span>mpi_cart_create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm dg::mpi_cart_create </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>bcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cin</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm_old</em></span><span class="paramdefsep"> = </span><span class="paramdefval">MPI_COMM_WORLD</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reorder</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience call: read in number of processses from istream and create Cartesian MPI communicator. </p>
<p>The intended use for this function is as a setup module for application codes. This function does:</p><ol type="1">
<li>[verbose, rank0] print a query to <code>os</code> </li>
<li>Call <code>auto np = mpi_read_as&lt;int&gt;( bcs.size(), comm_old, is);</code></li>
<li>[rank0] read <code>bcs.size()</code> integers from <code>is</code> </li>
<li>[verbose, rank0] print read integers back to <code>os</code> </li>
<li>[verbose, rank0, cuda_aware_mpi] print GPU information to <code>os</code> </li>
<li>Call <code>MPI_Cart_create</code> and return Cartesian comm</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcs</td><td>if <code>bcs[u]==<a class="el" href="group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3" title="periodic boundaries">dg::PER</a></code> then the communicator is periodic in that dimension </td></tr>
    <tr><td class="paramname">is</td><td>Input stream rank 0 reads <code>bcs.size()</code> parameters (<code>np</code>[u]) </td></tr>
    <tr><td class="paramname">comm_old</td><td>input communicator (handle) (parameter used in <code>MPI_Cart_create</code>) </td></tr>
    <tr><td class="paramname">reorder</td><td>(parameter used in <code>MPI_Cart_create</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>most MPI libraries ignore the <code>reorder</code> parameter </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>If true, rank 0 prints queries and information to <code>os</code> In this case <code>bcs.size()&lt;=6</code> </td></tr>
    <tr><td class="paramname">os</td><td>Output stream used if <code>verbose==true</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>communicator with new Cartesian topology (handle) </dd></dl>

</div>
</div>
<a id="gacb0e11d4d2ad14c3512f6773e351863f" name="gacb0e11d4d2ad14c3512f6773e351863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb0e11d4d2ad14c3512f6773e351863f">&#9670;&#160;</a></span>mpi_cart_kron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm dg::mpi_cart_kron </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; MPI_Comm &gt;</td>          <td class="paramname"><span class="paramname"><em>comms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Form a Kronecker product among Cartesian communicators. </p>
<p>Find communicator as the one that hypothetically generated all input comms through <code>MPI_Cart_sub( return_comm, remain_dims[u],
comms[u]);</code> for all <code>u &lt; comms.size();</code></p>
<p>Unless <code>comms</code> is empty or contains only 1 communicator all input comms must be registered in the dg library as Cartesian communicators that derive from the same root Cartesian communicator. Furthermore the comms must be mutually orthogonal i.e. any <code>true</code> entry in <code>remain_dims</code> can exist in only exactly one comm. The resulting <code>remain_dims</code> of the output is then the union of all <code>remain_dims</code> of the inputs.</p>
<p>For example </p><div class="fragment"><div class="line"><span class="comment">// Create a Cartesian communicator</span></div>
<div class="line">MPI_Comm comm = <a class="code hl_function" href="#ga492bf8ec7e709603a5cdd5569766fa2e">dg::mpi_cart_create</a>( MPI_COMM_WORLD, {0,0,0}, {0,0,0});</div>
<div class="line"><span class="comment">// Split into 3 axes</span></div>
<div class="line">std::array&lt;MPI_Comm,3&gt; axes3d = <a class="code hl_function" href="#ga0776a7caa8efc4f5af2225849c393b13">dg::mpi_cart_split_as&lt;3&gt;</a>( comm);</div>
<div class="line"><span class="comment">// Join the first and third axis</span></div>
<div class="line">MPI_Comm comm_101 = <a class="code hl_function" href="#gacb0e11d4d2ad14c3512f6773e351863f">dg::mpi_cart_kron</a>( {axes3d[0], axes3d[2]});</div>
<div class="line"><span class="comment">// Split up again</span></div>
<div class="line">std::array&lt;MPI_Comm,2&gt; axes2d = <a class="code hl_function" href="#ga0776a7caa8efc4f5af2225849c393b13">dg::mpi_cart_split_as&lt;2&gt;</a>( comm_101);</div>
<div class="line">CHECK( axes2d[0] == axes3d[0]);</div>
<div class="line">CHECK( axes2d[1] == axes3d[2]);</div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>The order of communicators matters. The function will not transpose communicators </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comms</td><td>input communicators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of communicators  </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The reason the dg library provides <code><a class="el" href="#ga9983503a764d29bffd43cc93878d2ebb" title="Call and register a call to MPI_Cart_sub with the dg library.">dg::mpi_cart_sub</a></code> and <code><a class="el" href="#gacb0e11d4d2ad14c3512f6773e351863f" title="Form a Kronecker product among Cartesian communicators.">dg::mpi_cart_kron</a></code> is that unfortunately the MPI standard does not provide a way to form the Kronecker product of Cartesian communicators without manually tracking their parent Cartesian communicators. However, this is needed in the <code><a class="el" href="group__blas1.html#gadb2af43e4e5cf87153ede64c181ba61e" title="(Kronecker evaluation)">dg::blas1::kronecker</a></code> and <code><a class="el" href="group__blas1.html#ga04a5fec2b7e6325a3f4c44ab223cdc81" title="Memory allocating version of dg::blas1::kronecker">dg::kronecker</a></code> functions.    </dd></dl>

</div>
</div>
<a id="ga3a4cc0823c0a10616c32e3ec51036aa9" name="ga3a4cc0823c0a10616c32e3ec51036aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a4cc0823c0a10616c32e3ec51036aa9">&#9670;&#160;</a></span>mpi_cart_kron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm dg::mpi_cart_kron </td>
          <td>(</td>
          <td class="paramtype">Vector</td>          <td class="paramname"><span class="paramname"><em>comms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience shortcut for <code> return mpi_cart_kron( std::vector&lt;MPI_Comm&gt;(comms.begin(), comms.end()));</code> </p>

</div>
</div>
<a id="ga1746131a15430071db91f54dc3767d1a" name="ga1746131a15430071db91f54dc3767d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1746131a15430071db91f54dc3767d1a">&#9670;&#160;</a></span>mpi_cart_split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; MPI_Comm &gt; dg::mpi_cart_split </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a Cartesian communicator along each dimensions. </p>
<p>using repeated calls to <code><a class="el" href="#ga9983503a764d29bffd43cc93878d2ebb" title="Call and register a call to MPI_Cart_sub with the dg library.">dg::mpi_cart_sub</a></code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>input Cartesian communicator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of 1-dimensional Cartesian communicators. The i-th communicator corresponds to the i-th axis in <code>comm</code> </dd></dl>

</div>
</div>
<a id="ga0776a7caa8efc4f5af2225849c393b13" name="ga0776a7caa8efc4f5af2225849c393b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0776a7caa8efc4f5af2225849c393b13">&#9670;&#160;</a></span>mpi_cart_split_as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Nd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; MPI_Comm, Nd &gt; dg::mpi_cart_split_as </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>mpi_cart_split</code> but differen return type. </p>
<div class="fragment"><div class="line"><span class="comment">// Create a Cartesian communicator</span></div>
<div class="line">MPI_Comm comm = <a class="code hl_function" href="#ga492bf8ec7e709603a5cdd5569766fa2e">dg::mpi_cart_create</a>( MPI_COMM_WORLD, {0,0,0}, {0,0,0});</div>
<div class="line"><span class="comment">// Split into 3 axes</span></div>
<div class="line">std::array&lt;MPI_Comm,3&gt; axes3d = <a class="code hl_function" href="#ga0776a7caa8efc4f5af2225849c393b13">dg::mpi_cart_split_as&lt;3&gt;</a>( comm);</div>
<div class="line"><span class="comment">// Join the first and third axis</span></div>
<div class="line">MPI_Comm comm_101 = <a class="code hl_function" href="#gacb0e11d4d2ad14c3512f6773e351863f">dg::mpi_cart_kron</a>( {axes3d[0], axes3d[2]});</div>
<div class="line"><span class="comment">// Split up again</span></div>
<div class="line">std::array&lt;MPI_Comm,2&gt; axes2d = <a class="code hl_function" href="#ga0776a7caa8efc4f5af2225849c393b13">dg::mpi_cart_split_as&lt;2&gt;</a>( comm_101);</div>
<div class="line">CHECK( axes2d[0] == axes3d[0]);</div>
<div class="line">CHECK( axes2d[1] == axes3d[2]);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Nd</td><td>Number of dimensions to copy from <code>mpi_cart_split</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>input Cartesian communicator ( <code>Nd &lt;= comm.ndims</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of 1-dimensional Cartesian communicators </dd></dl>

</div>
</div>
<a id="ga9983503a764d29bffd43cc93878d2ebb" name="ga9983503a764d29bffd43cc93878d2ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9983503a764d29bffd43cc93878d2ebb">&#9670;&#160;</a></span>mpi_cart_sub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm dg::mpi_cart_sub </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>remain_dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>duplicate</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call and register a call to <code>MPI_Cart_sub</code> with the dg library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>communicator with Cartesian structure (handle) (parameter used in <code>MPI_Cart_sub</code>) </td></tr>
    <tr><td class="paramname">remain_dims</td><td>the i-th entry of <code>remain_dims</code> specifies whether the i-th dimension is kept in the subgrid (true) or is dropped (false), must have <code>ndims</code> entries. (parameter used in <code>MPI_Cart_sub</code>) </td></tr>
    <tr><td class="paramname">duplicate</td><td>Determines what happens in case <code>MPI_Cart_sub</code> was already registered with <code>comm</code> and the same <code>remain_dims</code>. True: call <code>MPI_Cart_sub</code> and generate a novel communicator even if a duplicate exists. False: first check if a communicator that was subbed from <code>comm</code> with <code>remain_dims</code> was previously registered. In case one is found <code>return existing_comm;</code>. Else, call and register <code>MPI_Cart_sub</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>communicator containing the subgrid that includes the calling process (handle) (parameter used in <code>MPI_Cart_sub</code>)  </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The reason the dg library provides <code><a class="el" href="#ga9983503a764d29bffd43cc93878d2ebb" title="Call and register a call to MPI_Cart_sub with the dg library.">dg::mpi_cart_sub</a></code> and <code><a class="el" href="#gacb0e11d4d2ad14c3512f6773e351863f" title="Form a Kronecker product among Cartesian communicators.">dg::mpi_cart_kron</a></code> is that unfortunately the MPI standard does not provide a way to form the Kronecker product of Cartesian communicators without manually tracking their parent Cartesian communicators. However, this is needed in the <code><a class="el" href="group__blas1.html#gadb2af43e4e5cf87153ede64c181ba61e" title="(Kronecker evaluation)">dg::blas1::kronecker</a></code> and <code><a class="el" href="group__blas1.html#ga04a5fec2b7e6325a3f4c44ab223cdc81" title="Memory allocating version of dg::blas1::kronecker">dg::kronecker</a></code> functions.    </dd></dl>

</div>
</div>
<a id="ga05ff40a556f837e513fafd7aff7f477e" name="ga05ff40a556f837e513fafd7aff7f477e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05ff40a556f837e513fafd7aff7f477e">&#9670;&#160;</a></span>mpi_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::mpi_init </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>[]&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convencience shortcut: Calls MPI_Init or MPI_Init_thread and inits CUDA devices. </p>
<p>Shortcut for </p><div class="fragment"><div class="line">#ifdef _OPENMP</div>
<div class="line">    int provided, error;</div>
<div class="line">    error = MPI_Init_thread(&amp;argc, &amp;argv, MPI_THREAD_FUNNELED, &amp;provided);</div>
<div class="line">    assert( error == MPI_SUCCESS &amp;&amp; &quot;Threaded MPI lib required!\n&quot;);</div>
<div class="line">#else</div>
<div class="line">    MPI_Init(&amp;argc, &amp;argv);</div>
<div class="line">#endif</div>
<div class="line">    //... init cuda devices if THRUST_DEVICE_SYSTEM_CUDA</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Also sets the GPU a process should use via <code> cudaSetDevice( rank % num_devices_per_node) </code> if <code> THRUST_DEVICE_SYSTEM == THRUST_DEVICE_SYSTEM_CUDA </code>. We assume that the number of GPUs per node is fixed. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Abort program if MPI does not support OpenMP and <code>_OPENMP</code> is defined or if no CUDA capable devices are found in case of <code>THRUST_DEVICE_SYSTEM_CUDA</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>command line argument number </td></tr>
    <tr><td class="paramname">argv</td><td>command line arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb9191b679fcecfb09f39dc4ba0fa0a4" name="gadb9191b679fcecfb09f39dc4ba0fa0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb9191b679fcecfb09f39dc4ba0fa0a4">&#9670;&#160;</a></span>mpi_read_as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; dg::mpi_read_as </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cin</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read <code>num</code> values from <code>is</code> and broadcast to all processes as type <code>T</code>. </p>
<p>Only the rank0 in <code>comm</code> reads from <code>is</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of value to read from <code>is</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The number of values to read </td></tr>
    <tr><td class="paramname">comm</td><td>The communicator to which to broadcast </td></tr>
    <tr><td class="paramname">is</td><td>Input stream rank 0 reads <code>num</code> parameters of type <code>T</code> from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab902ed4cf258e7444b5f0d0341101300" name="gab902ed4cf258e7444b5f0d0341101300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab902ed4cf258e7444b5f0d0341101300">&#9670;&#160;</a></span>mpi_read_grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::mpi_read_grid </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned * &gt;</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cin</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience shortcut allowing a call like. </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ga6d17e061d25fe3cd6c334c6a0661100c">mpi_read_grid</a>( n, {&amp;Nx, &amp;Ny}, comm, is, verbose, os);</div>
<div class="ttc" id="agroup__mpi__utility_html_ga6d17e061d25fe3cd6c334c6a0661100c"><div class="ttname"><a href="#ga6d17e061d25fe3cd6c334c6a0661100c">dg::mpi_read_grid</a></div><div class="ttdeci">void mpi_read_grid(unsigned &amp;n, std::vector&lt; unsigned &gt; &amp;N, MPI_Comm comm, std::istream &amp;is=std::cin, bool verbose=true, std::ostream &amp;os=std::cout)</div><div class="ttdoc">Read in grid sizes from is.</div><div class="ttdef"><b>Definition</b> mpi_init.h:112</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga6d17e061d25fe3cd6c334c6a0661100c" name="ga6d17e061d25fe3cd6c334c6a0661100c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d17e061d25fe3cd6c334c6a0661100c">&#9670;&#160;</a></span>mpi_read_grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::mpi_read_grid </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cin</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read in grid sizes from <code>is</code>. </p>
<p>The intended use for this function is as a setup module for application codes that use our <code><a class="el" href="group__gridtypes.html#gae458354e2d34617dacaf640123264efe">dg::Grid</a></code> s. Basically just</p><ol type="1">
<li>[verbose, rank0] print a query to <code>os</code> </li>
<li>Call <code>auto vals = <a class="el" href="#gadb9191b679fcecfb09f39dc4ba0fa0a4" title="Read num values from is and broadcast to all processes as type T.">dg::mpi_read_as&lt;unsigned&gt;</a>( 1 + N.size(), comm, is);</code></li>
<li>[verbose, rank0] print read values back to <code>os</code> </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>rank 0 reads in from <code>is</code> and broadcasts to all processes in <code>MPI_COMM_WORLD</code> </td></tr>
    <tr><td class="paramname">N</td><td>rank 0 reads in from <code>is</code> and broadcasts to all processes in <code>MPI_COMM_WORLD</code> </td></tr>
    <tr><td class="paramname">comm</td><td>communicator (handle) to which rank0 broadcasts </td></tr>
    <tr><td class="paramname">is</td><td>Input stream rank 0 reads parameters (<code>n</code>, <code>N</code>) </td></tr>
    <tr><td class="paramname">verbose</td><td>If true, rank 0 prints queries and information on <code>os</code> </td></tr>
    <tr><td class="paramname">os</td><td>Output stream used if <code>verbose==true</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>dg::aRealTopologyNd </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:30 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
