<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Discontinuous Galerkin Library: dg::AdaptiveTimeloop&lt; ContainerType &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Discontinuous Galerkin Library
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structdg_1_1_adaptive_timeloop.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1_adaptive_timeloop-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::AdaptiveTimeloop&lt; ContainerType &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__lvevl2.html">Level 2: Basic numerical algorithms</a> &raquo; <a class="el" href="group__time.html">ODE integration</a> &#124; <a class="el" href="group__lvevl2.html">Level 2: Basic numerical algorithms</a> &raquo; <a class="el" href="group__time.html">ODE integration</a> &raquo; <a class="el" href="group__time__utils.html">Utilities for ODE integrators</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Integrate using a while loop.  
 <a href="#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for dg::AdaptiveTimeloop&lt; ContainerType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structdg_1_1_adaptive_timeloop__inherit__graph.svg" width="203" height="139"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8e9c271f576107cfa7782512be9c53bc" id="r_a8e9c271f576107cfa7782512be9c53bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> = <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type</a>&lt;ContainerType&gt;</td></tr>
<tr class="separator:a8e9c271f576107cfa7782512be9c53bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff234445a4d8d449596b38d73164bb1a" id="r_aff234445a4d8d449596b38d73164bb1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff234445a4d8d449596b38d73164bb1a">container_type</a> = ContainerType</td></tr>
<tr class="separator:aff234445a4d8d449596b38d73164bb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structdg_1_1a_timeloop"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_structdg_1_1a_timeloop')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structdg_1_1a_timeloop.html">dg::aTimeloop&lt; ContainerType &gt;</a></td></tr>
<tr class="memitem:aa97380970aecd889291b393b5a047581 inherit pub_types_structdg_1_1a_timeloop" id="r_aa97380970aecd889291b393b5a047581"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_timeloop.html#aa97380970aecd889291b393b5a047581">value_type</a> = <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type</a>&lt;ContainerType&gt;</td></tr>
<tr class="separator:aa97380970aecd889291b393b5a047581 inherit pub_types_structdg_1_1a_timeloop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e0954ef0374e7862ec2e63a0681aa7 inherit pub_types_structdg_1_1a_timeloop" id="r_ab9e0954ef0374e7862ec2e63a0681aa7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_timeloop.html#ab9e0954ef0374e7862ec2e63a0681aa7">container_type</a> = ContainerType</td></tr>
<tr class="separator:ab9e0954ef0374e7862ec2e63a0681aa7 inherit pub_types_structdg_1_1a_timeloop"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a3770c7cb91ece4e647263ae00f09f2" id="r_a3a3770c7cb91ece4e647263ae00f09f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a3770c7cb91ece4e647263ae00f09f2">AdaptiveTimeloop</a> ()=default</td></tr>
<tr class="memdesc:a3a3770c7cb91ece4e647263ae00f09f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">no allocation  <br /></td></tr>
<tr class="separator:a3a3770c7cb91ece4e647263ae00f09f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9664dadb583d01c0d455be20d6495be3" id="r_a9664dadb583d01c0d455be20d6495be3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9664dadb583d01c0d455be20d6495be3">AdaptiveTimeloop</a> (std::function&lt; void(<a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a>, const ContainerType &amp;, <a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> &amp;, ContainerType &amp;, <a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> &amp;)&gt; step)</td></tr>
<tr class="memdesc:a9664dadb583d01c0d455be20d6495be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct using a <code>std::function</code>.  <br /></td></tr>
<tr class="separator:a9664dadb583d01c0d455be20d6495be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567e579368bf581bb608c2537ffe7137" id="r_a567e579368bf581bb608c2537ffe7137"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="structdg_1_1_adaptive.html">Adaptive</a> , class ODE , class ErrorNorm  = value_type( const container_type&amp;), class ControlFunction  = value_type(std::array&lt;value_type,3&gt;,                std::array&lt;value_type,3&gt;, unsigned, unsigned)&gt; </td></tr>
<tr class="memitem:a567e579368bf581bb608c2537ffe7137"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a567e579368bf581bb608c2537ffe7137">AdaptiveTimeloop</a> (<a class="el" href="structdg_1_1_adaptive.html">Adaptive</a> &amp;&amp;adapt, ODE &amp;&amp;ode, ControlFunction control, ErrorNorm norm, <a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> rtol, <a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> atol, <a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> reject_limit=2)</td></tr>
<tr class="memdesc:a567e579368bf581bb608c2537ffe7137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the step function of a <code><a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep ODE integration.">dg::Adaptive</a></code> object.  <br /></td></tr>
<tr class="separator:a567e579368bf581bb608c2537ffe7137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90d2f60c771a2f9bf3f1c4ae6c30f87" id="r_aa90d2f60c771a2f9bf3f1c4ae6c30f87"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:aa90d2f60c771a2f9bf3f1c4ae6c30f87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa90d2f60c771a2f9bf3f1c4ae6c30f87">construct</a> (Params &amp;&amp;...ps)</td></tr>
<tr class="memdesc:aa90d2f60c771a2f9bf3f1c4ae6c30f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect forward parameters to one of the constructors.     <br /></td></tr>
<tr class="separator:aa90d2f60c771a2f9bf3f1c4ae6c30f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a596483d0c88c984843e541cdc2b89" id="r_ab8a596483d0c88c984843e541cdc2b89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8a596483d0c88c984843e541cdc2b89">set_dt</a> (<a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> dt)</td></tr>
<tr class="memdesc:ab8a596483d0c88c984843e541cdc2b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial time-guess in integrate function.  <br /></td></tr>
<tr class="separator:ab8a596483d0c88c984843e541cdc2b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ad1272c722d63824c0f36cfa329c89" id="r_ad5ad1272c722d63824c0f36cfa329c89"><td class="memTemplParams" colspan="2">template&lt;class Domain &gt; </td></tr>
<tr class="memitem:ad5ad1272c722d63824c0f36cfa329c89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5ad1272c722d63824c0f36cfa329c89">integrate_in_domain</a> (<a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> t0, const ContainerType &amp;u0, <a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> &amp;t1, ContainerType &amp;u1, <a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> dt, Domain &amp;&amp;domain, <a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> eps_root)</td></tr>
<tr class="memdesc:ad5ad1272c722d63824c0f36cfa329c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a differential equation within an integration domain.  <br /></td></tr>
<tr class="separator:ad5ad1272c722d63824c0f36cfa329c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c940e50bd0150fbe56575d3d32786b5" id="r_a6c940e50bd0150fbe56575d3d32786b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structdg_1_1_adaptive_timeloop.html">AdaptiveTimeloop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c940e50bd0150fbe56575d3d32786b5">clone</a> () const</td></tr>
<tr class="memdesc:a6c940e50bd0150fbe56575d3d32786b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract copy method that returns a copy of *this on the heap.  <br /></td></tr>
<tr class="separator:a6c940e50bd0150fbe56575d3d32786b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structdg_1_1a_timeloop"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_structdg_1_1a_timeloop')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structdg_1_1a_timeloop.html">dg::aTimeloop&lt; ContainerType &gt;</a></td></tr>
<tr class="memitem:a97075599065d0dbdadac0ada83ffc2b4 inherit pub_methods_structdg_1_1a_timeloop" id="r_a97075599065d0dbdadac0ada83ffc2b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_timeloop.html#a97075599065d0dbdadac0ada83ffc2b4">integrate</a> (<a class="el" href="structdg_1_1a_timeloop.html#aa97380970aecd889291b393b5a047581">value_type</a> t0, const ContainerType &amp;u0, <a class="el" href="structdg_1_1a_timeloop.html#aa97380970aecd889291b393b5a047581">value_type</a> t1, ContainerType &amp;u1)</td></tr>
<tr class="memdesc:a97075599065d0dbdadac0ada83ffc2b4 inherit pub_methods_structdg_1_1a_timeloop"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a differential equation between given bounds.  <br /></td></tr>
<tr class="separator:a97075599065d0dbdadac0ada83ffc2b4 inherit pub_methods_structdg_1_1a_timeloop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9036a6f4dda222cc9a7e3ba16336b4ac inherit pub_methods_structdg_1_1a_timeloop" id="r_a9036a6f4dda222cc9a7e3ba16336b4ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_timeloop.html#a9036a6f4dda222cc9a7e3ba16336b4ac">integrate</a> (<a class="el" href="structdg_1_1a_timeloop.html#aa97380970aecd889291b393b5a047581">value_type</a> &amp;t0, const ContainerType &amp;u0, <a class="el" href="structdg_1_1a_timeloop.html#aa97380970aecd889291b393b5a047581">value_type</a> t1, ContainerType &amp;u1, enum <a class="el" href="group__time__utils.html#ga6da92394b084f50fdbfe42b13506ba40">to</a> mode)</td></tr>
<tr class="memdesc:a9036a6f4dda222cc9a7e3ba16336b4ac inherit pub_methods_structdg_1_1a_timeloop"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build your own timeloop.  <br /></td></tr>
<tr class="separator:a9036a6f4dda222cc9a7e3ba16336b4ac inherit pub_methods_structdg_1_1a_timeloop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb375dbd5716f2981d3ffa772ea2b44e inherit pub_methods_structdg_1_1a_timeloop" id="r_adb375dbd5716f2981d3ffa772ea2b44e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1a_timeloop.html#aa97380970aecd889291b393b5a047581">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_timeloop.html#adb375dbd5716f2981d3ffa772ea2b44e">get_dt</a> () const</td></tr>
<tr class="memdesc:adb375dbd5716f2981d3ffa772ea2b44e inherit pub_methods_structdg_1_1a_timeloop"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current timestep.  <br /></td></tr>
<tr class="separator:adb375dbd5716f2981d3ffa772ea2b44e inherit pub_methods_structdg_1_1a_timeloop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8d819e7f74b65274cb82014baf19bd inherit pub_methods_structdg_1_1a_timeloop" id="r_a6e8d819e7f74b65274cb82014baf19bd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_timeloop.html#a6e8d819e7f74b65274cb82014baf19bd">~aTimeloop</a> ()</td></tr>
<tr class="separator:a6e8d819e7f74b65274cb82014baf19bd inherit pub_methods_structdg_1_1a_timeloop"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_structdg_1_1a_timeloop"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_structdg_1_1a_timeloop')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="structdg_1_1a_timeloop.html">dg::aTimeloop&lt; ContainerType &gt;</a></td></tr>
<tr class="memitem:a329650b38aa89ab76a2bafa56ebc5fc6 inherit pro_methods_structdg_1_1a_timeloop" id="r_a329650b38aa89ab76a2bafa56ebc5fc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_timeloop.html#a329650b38aa89ab76a2bafa56ebc5fc6">aTimeloop</a> ()</td></tr>
<tr class="memdesc:a329650b38aa89ab76a2bafa56ebc5fc6 inherit pro_methods_structdg_1_1a_timeloop"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty  <br /></td></tr>
<tr class="separator:a329650b38aa89ab76a2bafa56ebc5fc6 inherit pro_methods_structdg_1_1a_timeloop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524f4d93bc06e4898b708deb525ad40f inherit pro_methods_structdg_1_1a_timeloop" id="r_a524f4d93bc06e4898b708deb525ad40f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_timeloop.html#a524f4d93bc06e4898b708deb525ad40f">aTimeloop</a> (const <a class="el" href="structdg_1_1a_timeloop.html">aTimeloop</a> &amp;)</td></tr>
<tr class="memdesc:a524f4d93bc06e4898b708deb525ad40f inherit pro_methods_structdg_1_1a_timeloop"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty  <br /></td></tr>
<tr class="separator:a524f4d93bc06e4898b708deb525ad40f inherit pro_methods_structdg_1_1a_timeloop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23ccfbb0a5947ac520569e763042e23 inherit pro_methods_structdg_1_1a_timeloop" id="r_ae23ccfbb0a5947ac520569e763042e23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdg_1_1a_timeloop.html">aTimeloop</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1a_timeloop.html#ae23ccfbb0a5947ac520569e763042e23">operator=</a> (const <a class="el" href="structdg_1_1a_timeloop.html">aTimeloop</a> &amp;)</td></tr>
<tr class="memdesc:ae23ccfbb0a5947ac520569e763042e23 inherit pro_methods_structdg_1_1a_timeloop"><td class="mdescLeft">&#160;</td><td class="mdescRight">return *this  <br /></td></tr>
<tr class="separator:ae23ccfbb0a5947ac520569e763042e23 inherit pro_methods_structdg_1_1a_timeloop"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ContainerType&gt;<br />
struct dg::AdaptiveTimeloop&lt; ContainerType &gt;</div><p>Integrate using a while loop. </p>
<p>well suited for <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep ODE integration.">dg::Adaptive</a>. The timeloop (for positive dt) corresponds to </p><div class="fragment"><div class="line">t = t0; u1 = u0;</div>
<div class="line"><span class="keywordtype">double</span> dt = 1e-6; <span class="comment">// some initial guess</span></div>
<div class="line"><span class="keywordflow">while</span>( t &lt; t1)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>( t + dt &gt; t1)</div>
<div class="line">        dt = t1 - t;</div>
<div class="line">    step( t, u1, t, u1, dt);</div>
<div class="line">}</div>
</div><!-- fragment --><p> In the <code>integrate_at_least</code> function the if statement is removed. </p><dl class="section note"><dt>Note</dt><dd>the current timestep <code>dt</code> is saved by the class and re-used in the next call to integrate unless overwritten by <code>set_dt</code>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The integrator may throw if it detects too small timesteps, too many failures, NaN, Inf, or other non-sanitary behaviour</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structdg_1_1_singlestep_timeloop.html" title="Integrate using a for loop and a fixed time-step.">SinglestepTimeloop</a>, <a class="el" href="structdg_1_1_multistep_timeloop.html" title="Integrate using a for loop and a fixed non-changeable time-step.">MultistepTimeloop</a>  </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>Any class for which a specialization of <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> exists and which fulfills the requirements of the there defined data and execution policies derived from <code><a class="el" href="structdg_1_1_any_vector_tag.html" title="Vector Tag base class, indicates the basic Vector/container concept.">AnyVectorTag</a></code> and <code><a class="el" href="structdg_1_1_any_policy_tag.html" title="Execution Policy base class.">AnyPolicyTag</a></code>. Among others<ul>
<li><code> <a class="el" href="group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef" title="Host Vector.">dg::HVec</a> (serial), <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a> (cuda / omp), <a class="el" href="group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a" title="MPI Host Vector s.a. dg::HVec.">dg::MHVec</a> (mpi + serial) or <a class="el" href="group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56" title="MPI Device Vector s.a. dg::DVec.">dg::MDVec</a> (mpi + cuda / omp) </code></li>
<li><code> std::vector&lt;dg::DVec&gt; </code> (vector of shared device vectors), <code> std::array&lt;double, 4&gt; </code> (array of 4 doubles) or <code> std::map &lt; std::string, <a class="el" href="group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab" title="Device Vector. The device can be an OpenMP parallelized cpu or a gpu. This depends on the value of th...">dg::DVec</a>&gt; </code> ( a map of named vectors)</li>
<li><code> double (scalar)</code> and other primitive types ...</li>
</ul>
If there are several <code>ContainerTypes</code> in the argument list, then <code><a class="el" href="structdg_1_1_tensor_traits.html" title="The vector traits.">TensorTraits</a></code> must exist for all of them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="group__dispatch.html#dispatch">The dg dispatch system</a> for a detailed explanation of our type dispatch system    </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aff234445a4d8d449596b38d73164bb1a" name="aff234445a4d8d449596b38d73164bb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff234445a4d8d449596b38d73164bb1a">&#9670;&#160;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_adaptive_timeloop.html">dg::AdaptiveTimeloop</a>&lt; ContainerType &gt;::container_type = ContainerType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e9c271f576107cfa7782512be9c53bc" name="a8e9c271f576107cfa7782512be9c53bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9c271f576107cfa7782512be9c53bc">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structdg_1_1_adaptive_timeloop.html">dg::AdaptiveTimeloop</a>&lt; ContainerType &gt;<a class="elRef" href="../../matrix/html/tridiaginv__b_8cpp.html#a099c90519d34c2dbab58e4a771aa6f25">::value_type</a> = <a class="el" href="group__dispatch.html#gafb37680870fa007f5c17589781880e92">dg::get_value_type</a>&lt;ContainerType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3a3770c7cb91ece4e647263ae00f09f2" name="a3a3770c7cb91ece4e647263ae00f09f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3770c7cb91ece4e647263ae00f09f2">&#9670;&#160;</a></span>AdaptiveTimeloop() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_adaptive_timeloop.html">dg::AdaptiveTimeloop</a>&lt; ContainerType &gt;::AdaptiveTimeloop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>no allocation </p>

</div>
</div>
<a id="a9664dadb583d01c0d455be20d6495be3" name="a9664dadb583d01c0d455be20d6495be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9664dadb583d01c0d455be20d6495be3">&#9670;&#160;</a></span>AdaptiveTimeloop() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_adaptive_timeloop.html">dg::AdaptiveTimeloop</a>&lt; ContainerType &gt;::AdaptiveTimeloop </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a>, const ContainerType &amp;, <a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> &amp;, ContainerType &amp;, <a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>step</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct using a <code>std::function</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>Called in the timeloop as <code> step( t0, u1, t0, u1, dt) </code>. Has to advance the ode in-place by <code>dt</code> and suggest a new <code>dt</code> for the next step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Useful if you want to do special things in every step <div class="fragment"><div class="line"><span class="keyword">auto</span> step = [=, &amp;ode, &amp;nfailed, adapt = <a class="code hl_struct" href="structdg_1_1_adaptive.html">dg::Adaptive&lt;dg::ERKStep&lt;Vec&gt;</a>(tableau, y0) ](</div>
<div class="line">    <span class="keyword">auto</span> t0, <span class="keyword">auto</span> y0, <span class="keyword">auto</span>&amp; t, <span class="keyword">auto</span>&amp; <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, <span class="keyword">auto</span>&amp; dt) <span class="keyword">mutable</span></div>
<div class="line">{</div>
<div class="line">    adapt.step( ode, t0, y0, t, <a class="code hl_enumvalue" href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">y</a>, dt, control, norm,</div>
<div class="line">            rtol, atol, reject_limit);</div>
<div class="line">    <span class="comment">// do more things here ... for example:</span></div>
<div class="line">    <span class="keywordflow">if</span> ( adapt.failed() )</div>
<div class="line">        nfailed ++;</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"><a class="code hl_struct" href="structdg_1_1_adaptive_timeloop.html">dg::AdaptiveTimeloop&lt;Vec&gt;</a>  timeloop(step);</div>
<div class="ttc" id="agroup__creation_html_ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d"><div class="ttname"><a href="group__creation.html#ggace76090e6c95d39b59a1dee2db968d14a415290769594460e2e485922904f345d">dg::coo2d::y</a></div><div class="ttdeci">@ y</div><div class="ttdoc">y direction</div></div>
<div class="ttc" id="astructdg_1_1_adaptive_html"><div class="ttname"><a href="structdg_1_1_adaptive.html">dg::Adaptive</a></div><div class="ttdoc">Driver class for adaptive timestep ODE integration.</div><div class="ttdef"><b>Definition</b> adaptive.h:233</div></div>
<div class="ttc" id="astructdg_1_1_adaptive_timeloop_html"><div class="ttname"><a href="structdg_1_1_adaptive_timeloop.html">dg::AdaptiveTimeloop</a></div><div class="ttdoc">Integrate using a while loop.</div><div class="ttdef"><b>Definition</b> adaptive.h:500</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a567e579368bf581bb608c2537ffe7137" name="a567e579368bf581bb608c2537ffe7137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567e579368bf581bb608c2537ffe7137">&#9670;&#160;</a></span>AdaptiveTimeloop() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<div class="memtemplate">
template&lt;class <a class="el" href="structdg_1_1_adaptive.html">Adaptive</a> , class ODE , class ErrorNorm  = value_type( const container_type&amp;), class ControlFunction  = value_type(std::array&lt;value_type,3&gt;,                std::array&lt;value_type,3&gt;, unsigned, unsigned)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1_adaptive_timeloop.html">dg::AdaptiveTimeloop</a>&lt; ContainerType &gt;::AdaptiveTimeloop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdg_1_1_adaptive.html">Adaptive</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>adapt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ODE &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>ode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFunction</td>          <td class="paramname"><span class="paramname"><em>control</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorNorm</td>          <td class="paramname"><span class="paramname"><em>norm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a></td>          <td class="paramname"><span class="paramname"><em>rtol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a></td>          <td class="paramname"><span class="paramname"><em>atol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a></td>          <td class="paramname"><span class="paramname"><em>reject_limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the step function of a <code><a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep ODE integration.">dg::Adaptive</a></code> object. </p>
<p>Construct a lambda function that calls the step function of <code>adapt</code> with given parameters and stores it internally in a <code>std::function</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep ODE integration.">Adaptive</a></td><td>a type with a step function as in <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep ODE integration.">dg::Adaptive</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapt</td><td>If constructed in-place (rvalue), will be copied into the lambda. If an lvalue, then the lambda stores a reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>If adapt is an lvalue then you need to make sure that adapt remains valid to avoid a "dangling reference"  </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ODE</td><td>The ExplicitRHS or tuple type that corresponds to what is inserted into the step member of the Stepper </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ode</td><td>rhs or tuple     </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ControlFunction</td><td>function or Functor called as dt' = <code>control</code>( {dt0, dt1, dt2}, {eps0, eps1, eps2}, embedded_order, order), where all parameters are of type value_type except the last two, which are unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>The control function. For explicit and imex methods, <code><a class="el" href="group__time__utils.html#ga3da5b4b68cceaf18e4c0dd80629d9bba">dg::pid_control</a></code> is a good choice with <code><a class="el" href="group__time__utils.html#ga32b696f59effe7da0f61b68275f6b180">dg::ex_control</a></code> or <code><a class="el" href="group__time__utils.html#ga3d078141617f2e4fe33df24f289ac6af" title="h_{n+1} = |ex_control| &lt; |im_control| ? ex_control : im_control">dg::imex_control</a></code> as an alternative if too many steps fail. For implicit methods use the <code><a class="el" href="group__time__utils.html#gacb1d6582ef865f0a098994190f13be15">dg::im_control</a></code>. The task of the control function is to compute a new timestep size based on the old timestep size, the order of the method and the past error(s). The behaviour of the controller is also changed by the <code>set_reject_limit</code> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ErrorNorm</td><td>function or Functor of type <a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type( const
   ContainerType&amp;)</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>The error norm. Usually <code><a class="el" href="group__time__utils.html#ga40758fa443b6728e1499c7ee16820c17" title="Compute  using dg::blas1::dot.">dg::l2norm</a></code> is a good choice, but for very small vector sizes the time for the binary reproducible dot product might become a performance bottleneck. Then <code><a class="el" href="group__time__utils.html#gac821e1bd12a9e5c2917effafc86b16ad" title="Compute  using naive summation.">dg::fast_l2norm</a></code> is a better choice. </td></tr>
    <tr><td class="paramname">rtol</td><td>the desired relative accuracy. Usually 1e-5 is a good choice. </td></tr>
    <tr><td class="paramname">atol</td><td>the desired absolute accuracy. Usually 1e-7 is a good choice. </td></tr>
    <tr><td class="paramname">reject_limit</td><td>the default value is 2. Sometimes even 2 is not enough, for example when the stepsize fluctuates very much and the stepper fails often then it may help to increase the reject_limit further (to 10 say). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The error tolerance is computed such that on average every point in the solution vector fulfills \( |\delta_i| \approx r|u_i| + a\) </dd>
<dd>
Try not to mess with dt. The controller is best left alone and it does a very good job choosing timesteps. But how do I output my solution at certain (equidistant) timesteps? First, think about if you really, really need that. Why is it so bad to have output at non-equidistant timesteps? If you are still firm, then consider using an interpolation scheme (cf. <code><a class="el" href="structdg_1_1_extrapolation.html" title="Extrapolate a polynomial passing through up to three points.">dg::Extrapolation</a></code>). Let choosing the timestep yourself be the very last option if the others are not viable </dd>
<dd>
From Kennedy and Carpenter, Appl. num. Math., (2003): "Step-size control is a means by which accuracy, iteration, and to a lesser extent stability are controlled.
The choice of (t) may be chosen from many criteria, among those are the (t) from the accuracy
based step controller, the (t)_inviscid and (t)_viscous associated with the inviscid and viscous stability
limits of the ERK, and the (t)_iter associated with iteration convergence."</dd></dl>
<p>Our control method is an error based control method. However, due to the CFL (or other stability) condition there might be a sharp barrier in the range of possible stepsizes, i.e the stability limited timestep where the error sharply increses leading to a large number of rejected steps. The pid-controller usually does a good job keeping the timestep "just right" but in future work we may want to consider stability based control methods as well. Furthermore, for implicit or semi-implicit methods the chosen timestep influences how fast the iterative solver converges. If the timestep is too large the solver might take too long to converge and a smaller timestep might be preferable. Even for explicit methods where in each timestep an elliptic equation has to be solved the timestep may influence the convergence rate. Currently, there is no communication implemented between these solvers and the controller, but we may consider it in future releases. </p><dl class="section attention"><dt>Attention</dt><dd>When you use the <a class="el" href="structdg_1_1_a_r_k_step.html" title="Additive Runge Kutta (semi-implicit) time-step with error estimate following The ARKode library">ARKStep</a> in combination with the <a class="el" href="structdg_1_1_adaptive.html" title="Driver class for adaptive timestep ODE integration.">Adaptive</a> time step algorithm pay attention to solve the implicit part with sufficient accuracy. Else, the error propagates into the time controller, which will then choose the timestep as if the implicit part was explicit i.e. far too small. This might have to do with stiffness-leakage [Kennedy and Carpenter, Appl. num. Math., (2003)]: "An essential requirement for the viability of stiff/nonstiff IMEX schemes is that the stiffness remains
truely separable. If this were not the case then stiffness would leak out of the stiff terms and stiffen the
nonstiff terms. It would manifest itself as a loss in stability or a forced reduction in stepsize of the nonstiff
terms. A more expensive fully implicit approach might then be required, and hence, methods that leak
substantial stiffness might best be avoided". </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The exact values of <code>rtol</code> and <code>atol</code> might not be too important. However, don't make <code>rtol</code> too large, <code>1e-1</code> say, since then the controller might get too close to the CFL barrier. The timestepper is still able to crash, mind, even though the chances of that happening are somewhat lower than in a fixed stepsize method.    </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6c940e50bd0150fbe56575d3d32786b5" name="a6c940e50bd0150fbe56575d3d32786b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c940e50bd0150fbe56575d3d32786b5">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structdg_1_1_adaptive_timeloop.html">AdaptiveTimeloop</a> * <a class="el" href="structdg_1_1_adaptive_timeloop.html">dg::AdaptiveTimeloop</a>&lt; ContainerType &gt;::clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abstract copy method that returns a copy of *this on the heap. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this on the heap </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structdg_1_1_clone_ptr.html" title="Manager class that invokes the clone() method on the managed ptr when copied.">dg::ClonePtr</a> </dd></dl>

<p>Implements <a class="el" href="structdg_1_1a_timeloop.html#a0596bedcad6f76fce5fdbdf8227b3fff">dg::aTimeloop&lt; ContainerType &gt;</a>.</p>

</div>
</div>
<a id="aa90d2f60c771a2f9bf3f1c4ae6c30f87" name="aa90d2f60c771a2f9bf3f1c4ae6c30f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90d2f60c771a2f9bf3f1c4ae6c30f87">&#9670;&#160;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_adaptive_timeloop.html">dg::AdaptiveTimeloop</a>&lt; ContainerType &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect forward parameters to one of the constructors.    </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>parameters forwarded to constructors    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5ad1272c722d63824c0f36cfa329c89" name="ad5ad1272c722d63824c0f36cfa329c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ad1272c722d63824c0f36cfa329c89">&#9670;&#160;</a></span>integrate_in_domain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<div class="memtemplate">
template&lt;class Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_adaptive_timeloop.html">dg::AdaptiveTimeloop</a>&lt; ContainerType &gt;::integrate_in_domain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a></td>          <td class="paramname"><span class="paramname"><em>t0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>u0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>u1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a></td>          <td class="paramname"><span class="paramname"><em>dt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Domain &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a></td>          <td class="paramname"><span class="paramname"><em>eps_root</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate a differential equation within an integration domain. </p>
<p>If the integration does not leave the domain then it is equivalent to a call to integrate, else a bisection algorithm is used to find the exact point of exit </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>initial time </td></tr>
    <tr><td class="paramname">u0</td><td>initial value at <code>t0</code> </td></tr>
    <tr><td class="paramname">t1</td><td>(read / write) end time; if the solution leaves the domain contains the last time where the solution still lies within the domain on output </td></tr>
    <tr><td class="paramname">u1</td><td>(write only) contains the result corresponding to t1 on output   Use only if you know a good step-size. </td></tr>
    <tr><td class="paramname">dt</td><td>The initial timestep guess (if 0 the function chooses something for you). The exact value is not really important, the stepper does not even have to succeed. Usually the control function will very(!) quickly adapt the stepsize in just one or two steps (even if it's several orders of magnitude off in the beginning).    </td></tr>
    <tr><td class="paramname">domain</td><td>a restriction of the solution space. The integrator checks after every step if the solution is still within the given domain <code>domain.contains(u1)</code>. If not, the integrator will bisect the exact domain boundary (up to the given tolerances) and return (t1, u1) that lies closest (but within) the domain boundary. </td></tr>
    <tr><td class="paramname">eps_root</td><td>Relative error of root finding algorithm <code>dt</code> &lt; eps( t1 + 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Domain</td><td>Must have the <code>contains(const ContainerType&amp;) const member</code> function returning true if the given solution is part of the domain, false else (can for example be <code><a class="el" href="group__gridtypes.html#ga1f871b7adbc225c55a572e3e2a1f8857">dg::aRealTopology2d</a></code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8a596483d0c88c984843e541cdc2b89" name="ab8a596483d0c88c984843e541cdc2b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a596483d0c88c984843e541cdc2b89">&#9670;&#160;</a></span>set_dt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1_adaptive_timeloop.html">dg::AdaptiveTimeloop</a>&lt; ContainerType &gt;::set_dt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8e9c271f576107cfa7782512be9c53bc">value_type</a></td>          <td class="paramname"><span class="paramname"><em>dt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set initial time-guess in integrate function. </p>
<p>Use only if you know a good step-size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The initial timestep guess (if 0 the function chooses something for you). The exact value is not really important, the stepper does not even have to succeed. Usually the control function will very(!) quickly adapt the stepsize in just one or two steps (even if it's several orders of magnitude off in the beginning). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="adaptive_8h_source.html">adaptive.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedg.html">dg</a></li><li class="navelem"><a class="el" href="structdg_1_1_adaptive_timeloop.html">AdaptiveTimeloop</a></li>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:30 for Discontinuous Galerkin Library by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
