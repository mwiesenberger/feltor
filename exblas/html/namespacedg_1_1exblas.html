<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extension: ExBLAS: dg::exblas Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Extension: ExBLAS
   </div>
   <div id="projectbrief">#include &quot;dg/algorithm.h&quot; (or as a standalone library as &quot;dg/exblas/exblas.h&quot;)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacedg_1_1exblas.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">dg::exblas Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This is the namespace for all functions and classes defined and used in the exblas library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas_1_1cpu.html">cpu</a></td></tr>
<tr class="memdesc:namespacedg_1_1exblas_1_1cpu"><td class="mdescLeft">&#160;</td><td class="mdescRight">cpu versions of the primitive functions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedg_1_1exblas_1_1gpu.html">gpu</a></td></tr>
<tr class="memdesc:namespacedg_1_1exblas_1_1gpu"><td class="mdescLeft">&#160;</td><td class="mdescRight">gpu (CUDA) versions of primitive functions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uniondg_1_1exblas_1_1udouble.html">udouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility union to display all bits of a double (using <a href="https://en.wikipedia.org/wiki/Type_punning">type-punning</a>)  <a href="uniondg_1_1exblas_1_1udouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uniondg_1_1exblas_1_1ufloat.html">ufloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility union to display all bits of a float (using <a href="https://en.wikipedia.org/wiki/Type_punning">type-punning</a>)  <a href="uniondg_1_1exblas_1_1ufloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a48b3fa9c609028c5a26e0280b35fbaa6" id="r_a48b3fa9c609028c5a26e0280b35fbaa6"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 3&gt; </td></tr>
<tr class="memitem:a48b3fa9c609028c5a26e0280b35fbaa6"><td class="memTemplItemLeft" align="right" valign="top">__host__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a48b3fa9c609028c5a26e0280b35fbaa6">exdot_gpu</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, int64_t *d_superacc, int *status)</td></tr>
<tr class="memdesc:a48b3fa9c609028c5a26e0280b35fbaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU version of exact dot product.  <br /></td></tr>
<tr class="separator:a48b3fa9c609028c5a26e0280b35fbaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d1caab696c6453b99cdf9ab52daec8" id="r_a95d1caab696c6453b99cdf9ab52daec8"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 3&gt; </td></tr>
<tr class="memitem:a95d1caab696c6453b99cdf9ab52daec8"><td class="memTemplItemLeft" align="right" valign="top">__host__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a95d1caab696c6453b99cdf9ab52daec8">exdot_gpu</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, PointerOrValue3 x3_ptr, int64_t *d_superacc, int *status)</td></tr>
<tr class="memdesc:a95d1caab696c6453b99cdf9ab52daec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU version of exact dot product.  <br /></td></tr>
<tr class="separator:a95d1caab696c6453b99cdf9ab52daec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b3aef855b6280b5a2fae8e89216e09" id="r_a77b3aef855b6280b5a2fae8e89216e09"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 8&gt; </td></tr>
<tr class="memitem:a77b3aef855b6280b5a2fae8e89216e09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77b3aef855b6280b5a2fae8e89216e09">exdot_omp</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, int64_t *h_superacc, int *status)</td></tr>
<tr class="memdesc:a77b3aef855b6280b5a2fae8e89216e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenMP parallel version of exact triple dot product.  <br /></td></tr>
<tr class="separator:a77b3aef855b6280b5a2fae8e89216e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a5971251a01870e26f2c769fef613d" id="r_aa6a5971251a01870e26f2c769fef613d"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 8&gt; </td></tr>
<tr class="memitem:aa6a5971251a01870e26f2c769fef613d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6a5971251a01870e26f2c769fef613d">exdot_omp</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, PointerOrValue3 x3_ptr, int64_t *h_superacc, int *status)</td></tr>
<tr class="memdesc:aa6a5971251a01870e26f2c769fef613d"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenMP parallel version of exact triple dot product.  <br /></td></tr>
<tr class="separator:aa6a5971251a01870e26f2c769fef613d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020aba11430835ed502b897fe94eab6d" id="r_a020aba11430835ed502b897fe94eab6d"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 8&gt; </td></tr>
<tr class="memitem:a020aba11430835ed502b897fe94eab6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a020aba11430835ed502b897fe94eab6d">exdot_cpu</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, int64_t *h_superacc, int *status)</td></tr>
<tr class="memdesc:a020aba11430835ed502b897fe94eab6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial version of exact dot product.  <br /></td></tr>
<tr class="separator:a020aba11430835ed502b897fe94eab6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5511b744a196e5830b9094b371832bbe" id="r_a5511b744a196e5830b9094b371832bbe"><td class="memTemplParams" colspan="2">template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 8&gt; </td></tr>
<tr class="memitem:a5511b744a196e5830b9094b371832bbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5511b744a196e5830b9094b371832bbe">exdot_cpu</a> (unsigned size, PointerOrValue1 x1_ptr, PointerOrValue2 x2_ptr, PointerOrValue3 x3_ptr, int64_t *h_superacc, int *status)</td></tr>
<tr class="memdesc:a5511b744a196e5830b9094b371832bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial version of exact dot product.  <br /></td></tr>
<tr class="separator:a5511b744a196e5830b9094b371832bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f211c09d47719c9213e789c9cedfdd" id="r_a87f211c09d47719c9213e789c9cedfdd"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N, class Functor , class ... PointerOrValues&gt; </td></tr>
<tr class="memitem:a87f211c09d47719c9213e789c9cedfdd"><td class="memTemplItemLeft" align="right" valign="top">__host__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a87f211c09d47719c9213e789c9cedfdd">fpedot_gpu</a> (int *status, unsigned size, T *fpe, Functor f, PointerOrValues ...xs_ptr)</td></tr>
<tr class="memdesc:a87f211c09d47719c9213e789c9cedfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU version of fpe generalized dot product.  <br /></td></tr>
<tr class="separator:a87f211c09d47719c9213e789c9cedfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36a221f122d652d75a2d40501d0f9e5" id="r_ad36a221f122d652d75a2d40501d0f9e5"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N, class Functor , class ... PointerOrValues&gt; </td></tr>
<tr class="memitem:ad36a221f122d652d75a2d40501d0f9e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad36a221f122d652d75a2d40501d0f9e5">fpedot_omp</a> (int *status, unsigned size, std::array&lt; T, N &gt; &amp;fpe, Functor f, PointerOrValues ...xs_ptr)</td></tr>
<tr class="memdesc:ad36a221f122d652d75a2d40501d0f9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenMP version of fpe generalized dot product.  <br /></td></tr>
<tr class="separator:ad36a221f122d652d75a2d40501d0f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeb0837aac8805f90cbbf6501a41493" id="r_acfeb0837aac8805f90cbbf6501a41493"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N, class Functor , class ... PointerOrValues&gt; </td></tr>
<tr class="memitem:acfeb0837aac8805f90cbbf6501a41493"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfeb0837aac8805f90cbbf6501a41493">fpedot_cpu</a> (int *status, unsigned size, std::array&lt; T, N &gt; &amp;fpe, Functor f, PointerOrValues ...xs_ptr)</td></tr>
<tr class="memdesc:acfeb0837aac8805f90cbbf6501a41493"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial version of extended precision general dot product  <br /></td></tr>
<tr class="separator:acfeb0837aac8805f90cbbf6501a41493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad475f5ccf3ba2655166b2a6cd90f2475" id="r_ad475f5ccf3ba2655166b2a6cd90f2475"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad475f5ccf3ba2655166b2a6cd90f2475">mpi_reduce_communicator</a> (MPI_Comm comm, MPI_Comm *comm_mod, MPI_Comm *comm_mod_reduce)</td></tr>
<tr class="memdesc:ad475f5ccf3ba2655166b2a6cd90f2475"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can be used to partition communicators for the <code><a class="el" href="#aec049a58ea3482c2de1085e8a20bbe0e" title="reduce a number of superaccumulators distributed among mpi processes">exblas::reduce_mpi_cpu</a></code> function.  <br /></td></tr>
<tr class="separator:ad475f5ccf3ba2655166b2a6cd90f2475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec049a58ea3482c2de1085e8a20bbe0e" id="r_aec049a58ea3482c2de1085e8a20bbe0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec049a58ea3482c2de1085e8a20bbe0e">reduce_mpi_cpu</a> (unsigned num_superacc, int64_t *in, int64_t *out, MPI_Comm comm, MPI_Comm comm_mod, MPI_Comm comm_mod_reduce)</td></tr>
<tr class="memdesc:aec049a58ea3482c2de1085e8a20bbe0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">reduce a number of superaccumulators distributed among mpi processes  <br /></td></tr>
<tr class="separator:aec049a58ea3482c2de1085e8a20bbe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the namespace for all functions and classes defined and used in the exblas library. </p>
<p>In principle you can use this as a standalone library but it is much easier to just use the <code>dg::blas1::dot</code> and <code>dg::blas2::dot</code> functions for general purpose usage </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a020aba11430835ed502b897fe94eab6d" name="a020aba11430835ed502b897fe94eab6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020aba11430835ed502b897fe94eab6d">&#9670;&#160;</a></span>exdot_cpu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::exdot_cpu </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1</td>          <td class="paramname"><span class="paramname"><em>x1_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2</td>          <td class="paramname"><span class="paramname"><em>x2_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>h_superacc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serial version of exact dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a8f26aaa4fce96a50841e820f2c1e52e2">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a97a51433cb2c261fe77b27bea7b91dc7">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>host memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5511b744a196e5830b9094b371832bbe" name="a5511b744a196e5830b9094b371832bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5511b744a196e5830b9094b371832bbe">&#9670;&#160;</a></span>exdot_cpu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::exdot_cpu </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1</td>          <td class="paramname"><span class="paramname"><em>x1_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2</td>          <td class="paramname"><span class="paramname"><em>x2_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue3</td>          <td class="paramname"><span class="paramname"><em>x3_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>h_superacc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serial version of exact dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i w_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a8f26aaa4fce96a50841e820f2c1e52e2">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a97a51433cb2c261fe77b27bea7b91dc7">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iw_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array </td></tr>
    <tr><td class="paramname">x3_ptr</td><td>third array     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>host memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48b3fa9c609028c5a26e0280b35fbaa6" name="a48b3fa9c609028c5a26e0280b35fbaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b3fa9c609028c5a26e0280b35fbaa6">&#9670;&#160;</a></span>exdot_gpu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ void dg::exblas::exdot_gpu </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1</td>          <td class="paramname"><span class="paramname"><em>x1_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2</td>          <td class="paramname"><span class="paramname"><em>x2_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>d_superacc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPU version of exact dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a8f26aaa4fce96a50841e820f2c1e52e2">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a97a51433cb2c261fe77b27bea7b91dc7">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>device memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95d1caab696c6453b99cdf9ab52daec8" name="a95d1caab696c6453b99cdf9ab52daec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d1caab696c6453b99cdf9ab52daec8">&#9670;&#160;</a></span>exdot_gpu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ void dg::exblas::exdot_gpu </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1</td>          <td class="paramname"><span class="paramname"><em>x1_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2</td>          <td class="paramname"><span class="paramname"><em>x2_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue3</td>          <td class="paramname"><span class="paramname"><em>x3_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>d_superacc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPU version of exact dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i w_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a8f26aaa4fce96a50841e820f2c1e52e2">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a97a51433cb2c261fe77b27bea7b91dc7">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iw_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array </td></tr>
    <tr><td class="paramname">x3_ptr</td><td>third array     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>device memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77b3aef855b6280b5a2fae8e89216e09" name="a77b3aef855b6280b5a2fae8e89216e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b3aef855b6280b5a2fae8e89216e09">&#9670;&#160;</a></span>exdot_omp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , size_t NBFPE = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::exdot_omp </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1</td>          <td class="paramname"><span class="paramname"><em>x1_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2</td>          <td class="paramname"><span class="paramname"><em>x2_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>h_superacc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenMP parallel version of exact triple dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a8f26aaa4fce96a50841e820f2c1e52e2">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a97a51433cb2c261fe77b27bea7b91dc7">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>host memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6a5971251a01870e26f2c769fef613d" name="aa6a5971251a01870e26f2c769fef613d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a5971251a01870e26f2c769fef613d">&#9670;&#160;</a></span>exdot_omp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PointerOrValue1 , class PointerOrValue2 , class PointerOrValue3 , size_t NBFPE = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::exdot_omp </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue1</td>          <td class="paramname"><span class="paramname"><em>x1_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue2</td>          <td class="paramname"><span class="paramname"><em>x2_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValue3</td>          <td class="paramname"><span class="paramname"><em>x3_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>h_superacc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenMP parallel version of exact triple dot product. </p>
<p>Accumulate the exact sum </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} x_i w_i y_i \]
</p>
<p> into a superaccumulator. The superaccumulator is an array of <code>exblas::BIN_COUNT</code> (39) 64 bit integers that represents a large fixed point number such that the summation is computed with virtually infinite precision and is thus bitwise reproducible even in a parallel environment. </p><dl class="section note"><dt>Note</dt><dd>The superaccumulator can be converted to a double precision number using the Round function: <a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a8f26aaa4fce96a50841e820f2c1e52e2">dg::exblas::cpu::Round</a> for cpu and omp version or <a class="el" href="namespacedg_1_1exblas_1_1gpu.html#a97a51433cb2c261fe77b27bea7b91dc7">dg::exblas::gpu::Round</a> for gpu version </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>the product \( x_iw_iy_i\) of numbers is <b>not</b> computed with infinite precision only the sum is (this does not break the reproducibility) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is described in the paper <a href="https://hal.archives-ouvertes.fr/hal-00949355v3">Sylvain Collange, David Defour, Stef Graillat, Roman Iakymchuk. "Numerical Reproducibility for the Parallel Reduction on Multi- and Many-Core Architectures", 2015. </a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NBFPE</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">PointerOrValue</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is either <code>float</code> or <code>double</code>. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size N of the arrays to sum </td></tr>
    <tr><td class="paramname">x1_ptr</td><td>first array </td></tr>
    <tr><td class="paramname">x2_ptr</td><td>second array </td></tr>
    <tr><td class="paramname">x3_ptr</td><td>third array     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_superacc</td><td>pointer to an array of 64 bit integegers (the superaccumulator) in <b>host memory</b> with size at least <code>exblas::BIN_COUNT</code> (39) (contents are overwritten, the function does not allocate memory i.e. the memory needs to be allocated <b>before</b> calling the function) </td></tr>
    <tr><td class="paramname">status</td><td>0 indicates success, 1 indicates an input value was NaN or Inf    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfeb0837aac8805f90cbbf6501a41493" name="acfeb0837aac8805f90cbbf6501a41493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfeb0837aac8805f90cbbf6501a41493">&#9670;&#160;</a></span>fpedot_cpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N, class Functor , class ... PointerOrValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::fpedot_cpu </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fpe</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValues ...</td>          <td class="paramname"><span class="paramname"><em>xs_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serial version of extended precision general dot product </p>
<p>Computes the extended precision reduction </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} f(x_{0i}, x_{1i}, ... )\]
</p>
<p> using floating point expansions </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the return type of <code>Functor</code>. </td></tr>
    <tr><td class="paramname">N</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">Functor</td><td>a Functor </td></tr>
    <tr><td class="paramname">PointerOrValues</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is a scalar type. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>0 indicates success, 2 means the FPE overflowed </td></tr>
    <tr><td class="paramname">size</td><td>size of the arrays to sum </td></tr>
    <tr><td class="paramname">fpe</td><td>the FPE holding the result (write-only) </td></tr>
    <tr><td class="paramname">f</td><td>the functor </td></tr>
    <tr><td class="paramname">xs_ptr</td><td>the input arrays to sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a8f26aaa4fce96a50841e820f2c1e52e2" title="Convert a superaccumulator to the nearest double precision number (CPU version)">exblas::cpu::Round</a></code> to convert the FPE into a double precision number </dd></dl>

</div>
</div>
<a id="a87f211c09d47719c9213e789c9cedfdd" name="a87f211c09d47719c9213e789c9cedfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f211c09d47719c9213e789c9cedfdd">&#9670;&#160;</a></span>fpedot_gpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N, class Functor , class ... PointerOrValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ void dg::exblas::fpedot_gpu </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>fpe</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValues ...</td>          <td class="paramname"><span class="paramname"><em>xs_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPU version of fpe generalized dot product. </p>
<p>Computes the extended precision reduction </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} f(x_{0i}, x_{1i}, ... )\]
</p>
<p> using floating point expansions </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the return type of <code>Functor</code>. </td></tr>
    <tr><td class="paramname">N</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">Functor</td><td>a Functor </td></tr>
    <tr><td class="paramname">PointerOrValues</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is a scalar type. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>0 indicates success, 2 means the FPE overflowed </td></tr>
    <tr><td class="paramname">size</td><td>size of the arrays to sum </td></tr>
    <tr><td class="paramname">fpe</td><td>the FPE holding the result (write-only) </td></tr>
    <tr><td class="paramname">f</td><td>the functor </td></tr>
    <tr><td class="paramname">xs_ptr</td><td>the input arrays to sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a8f26aaa4fce96a50841e820f2c1e52e2" title="Convert a superaccumulator to the nearest double precision number (CPU version)">exblas::cpu::Round</a></code> to convert the FPE into a double precision number    </dd></dl>

</div>
</div>
<a id="ad36a221f122d652d75a2d40501d0f9e5" name="ad36a221f122d652d75a2d40501d0f9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36a221f122d652d75a2d40501d0f9e5">&#9670;&#160;</a></span>fpedot_omp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N, class Functor , class ... PointerOrValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::fpedot_omp </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fpe</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointerOrValues ...</td>          <td class="paramname"><span class="paramname"><em>xs_ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenMP version of fpe generalized dot product. </p>
<p>Computes the extended precision reduction </p><p class="formulaDsp">
\[ \sum_{i=0}^{N-1} f(x_{0i}, x_{1i}, ... )\]
</p>
<p> using floating point expansions </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the return type of <code>Functor</code>. </td></tr>
    <tr><td class="paramname">N</td><td>size of the floating point expansion (should be between 3 and 8) </td></tr>
    <tr><td class="paramname">Functor</td><td>a Functor </td></tr>
    <tr><td class="paramname">PointerOrValues</td><td>must be one of <code> T, T&amp;&amp;, T&amp;, const T&amp;, T* or const T* </code>, where <code>T</code> is a scalar type. If it is a pointer type, then we iterate through the pointed data from 0 to <code>size</code>, else we consider the value constant in every iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>0 indicates success, 2 means the FPE overflowed </td></tr>
    <tr><td class="paramname">size</td><td>size of the arrays to sum </td></tr>
    <tr><td class="paramname">fpe</td><td>the FPE holding the result (write-only) </td></tr>
    <tr><td class="paramname">f</td><td>the functor </td></tr>
    <tr><td class="paramname">xs_ptr</td><td>the input arrays to sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespacedg_1_1exblas_1_1cpu.html#a8f26aaa4fce96a50841e820f2c1e52e2" title="Convert a superaccumulator to the nearest double precision number (CPU version)">exblas::cpu::Round</a></code> to convert the FPE into a double precision number    </dd></dl>

</div>
</div>
<a id="ad475f5ccf3ba2655166b2a6cd90f2475" name="ad475f5ccf3ba2655166b2a6cd90f2475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad475f5ccf3ba2655166b2a6cd90f2475">&#9670;&#160;</a></span>mpi_reduce_communicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::mpi_reduce_communicator </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm *</td>          <td class="paramname"><span class="paramname"><em>comm_mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm *</td>          <td class="paramname"><span class="paramname"><em>comm_mod_reduce</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function can be used to partition communicators for the <code><a class="el" href="#aec049a58ea3482c2de1085e8a20bbe0e" title="reduce a number of superaccumulators distributed among mpi processes">exblas::reduce_mpi_cpu</a></code> function. </p>
<p>If the ranks in <code>comm</code> are aligned in rows of 128 (or any number &lt;= 256) <code>comm_mod</code> is the 1d communicator for the rows and <code>comm_mod_reduce</code> is the communicator for the columns. The last row may contain fewer than 128 ranks and <code>comm_mod</code> may contain 1 rank fewer than the others in the last columns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>the input communicator (unmodified, may not be <code>MPI_COMM_NULL</code>) </td></tr>
    <tr><td class="paramname">comm_mod</td><td>the line communicator in <code>comm</code>, consists of all rank/mod ranks </td></tr>
    <tr><td class="paramname">comm_mod_reduce</td><td>the column communicator in <code>comm</code> consists of all rankmod ranks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>The creation of new communicators involves communication between all participation processes (comm in this case). In order to avoid excessive creation of new MPI communicators (there is a limit to how many a program can create), the function keeps a (static) record of which communicators it has been called with. If you repeatedly call this function with the same <code>comm</code> only the first call will actually create new communicators. </dd></dl>

</div>
</div>
<a id="aec049a58ea3482c2de1085e8a20bbe0e" name="aec049a58ea3482c2de1085e8a20bbe0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec049a58ea3482c2de1085e8a20bbe0e">&#9670;&#160;</a></span>reduce_mpi_cpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dg::exblas::reduce_mpi_cpu </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>num_superacc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm_mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm_mod_reduce</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reduce a number of superaccumulators distributed among mpi processes </p>
<p>We cannot sum more than 256 accumulators before we need to normalize again, so we need to split the reduction into several steps if more than 256 processes are involved. This function normalizes, reduces, normalizes, reduces and broadcasts the result to all participating processes. As usual the resulting superaccumulator is unnormalized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_superacc</td><td>number of Superaccumulators eaach process holds </td></tr>
    <tr><td class="paramname">in</td><td>unnormalized input superaccumulators ( must be of size num_superacc*<code>exblas::BIN_COUNT</code>, allocated on the cpu) (read/write, undefined on out) </td></tr>
    <tr><td class="paramname">out</td><td>each process contains the result on output( must be of size num_superacc*<code>exblas::BIN_COUNT</code>, allocated on the cpu) (write, may not alias in) </td></tr>
    <tr><td class="paramname">comm</td><td>The complete MPI communicator </td></tr>
    <tr><td class="paramname">comm_mod</td><td>This is the line communicator of up to 128 ranks ( or any other number &lt;256) </td></tr>
    <tr><td class="paramname">comm_mod_reduce</td><td>This is the column communicator consisting of all rank 0, 1, 2, ...,127 processes in all comm_mod </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#ad475f5ccf3ba2655166b2a6cd90f2475" title="This function can be used to partition communicators for the exblas::reduce_mpi_cpu function.">exblas::mpi_reduce_communicator</a></code> to generate the required communicators </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>dg</b></li><li class="navelem"><a class="el" href="namespacedg_1_1exblas.html">exblas</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
