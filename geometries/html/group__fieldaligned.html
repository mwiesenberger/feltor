<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extension: Geometries: 4. Fieldaligned derivatives</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Extension: Geometries
   </div>
   <div id="projectbrief">#include &quot;dg/geometries/geometries.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__fieldaligned.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">4. Fieldaligned derivatives</div></div>
</div><!--header-->
<div class="contents">

<p>\( \nabla_\parallel f\)  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS&lt; ProductGeometry, IMatrix, container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for the evaluation of parallel derivatives.  <a href="structdg_1_1geo_1_1_d_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned&lt; ProductGeometry, IMatrix, container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and manage interpolation matrices from fieldline integration.  <a href="structdg_1_1geo_1_1_fieldaligned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac31adf6f15d6a1b64d5a13d751a9f449" id="r_gac31adf6f15d6a1b64d5a13d751a9f449"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../../dg/html/structdg_1_1_o_n_e.html">ONE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac31adf6f15d6a1b64d5a13d751a9f449">dg::geo::FullLimiter</a></td></tr>
<tr class="memdesc:gac31adf6f15d6a1b64d5a13d751a9f449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full Limiter means there is a limiter everywhere.  <br /></td></tr>
<tr class="separator:gac31adf6f15d6a1b64d5a13d751a9f449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a10e4fdd6338136e629d3e2292bc3da" id="r_ga1a10e4fdd6338136e629d3e2292bc3da"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../../dg/html/structdg_1_1_z_e_r_o.html">ZERO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1a10e4fdd6338136e629d3e2292bc3da">dg::geo::NoLimiter</a></td></tr>
<tr class="memdesc:ga1a10e4fdd6338136e629d3e2292bc3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">No Limiter.  <br /></td></tr>
<tr class="separator:ga1a10e4fdd6338136e629d3e2292bc3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga10e4ac4f15fe73a4ff10569985224101" id="r_ga10e4ac4f15fe73a4ff10569985224101"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10e4ac4f15fe73a4ff10569985224101">dg::geo::whichMatrix</a> { <br />
&#160;&#160;<a class="el" href="#gga10e4ac4f15fe73a4ff10569985224101a3051e3e0498abaac57b76c94c1b94e25">dg::geo::einsPlus</a> = 0
, <a class="el" href="#gga10e4ac4f15fe73a4ff10569985224101a123cc46161ad1c9729aa385716751918">dg::geo::einsPlusT</a>
, <a class="el" href="#gga10e4ac4f15fe73a4ff10569985224101ac4342c25611d86ddd01f4f48a2054f86">dg::geo::einsMinus</a>
, <a class="el" href="#gga10e4ac4f15fe73a4ff10569985224101af101993895ad46716e7324439d6bd226">dg::geo::einsMinusT</a>
, <br />
&#160;&#160;<a class="el" href="#gga10e4ac4f15fe73a4ff10569985224101a1bcea579401004d4225a8ba87b913b40">dg::geo::zeroPlus</a>
, <a class="el" href="#gga10e4ac4f15fe73a4ff10569985224101af7a25c0e42902dabbd5e1d24aa691898">dg::geo::zeroMinus</a>
, <a class="el" href="#gga10e4ac4f15fe73a4ff10569985224101ad912895366d986757ddb2e2a986d56ce">dg::geo::zeroPlusT</a>
, <a class="el" href="#gga10e4ac4f15fe73a4ff10569985224101aa585e71c2f6ad3b442d4201b7bf71e9f">dg::geo::zeroMinusT</a>
, <br />
&#160;&#160;<a class="el" href="#gga10e4ac4f15fe73a4ff10569985224101a486b999831d96a38d14085d217dee1da">dg::geo::zeroForw</a>
<br />
 }</td></tr>
<tr class="memdesc:ga10e4ac4f15fe73a4ff10569985224101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for the use in Fieldaligned.  <a href="#ga10e4ac4f15fe73a4ff10569985224101">More...</a><br /></td></tr>
<tr class="separator:ga10e4ac4f15fe73a4ff10569985224101"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" id="r_ga51aeaeb3bddbb0c3f7f2a2bec74e6db9"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:ga51aeaeb3bddbb0c3f7f2a2bec74e6db9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9">dg::geo::assign_bc_along_field_2nd</a> (const FieldAligned &amp;fa, const container &amp;fm, const container &amp;f, const container &amp;fp, container &amp;fmg, container &amp;fpg, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bound, std::array&lt; double, 2 &gt; boundary_value={0, 0})</td></tr>
<tr class="memdesc:ga51aeaeb3bddbb0c3f7f2a2bec74e6db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.  <br /></td></tr>
<tr class="separator:ga51aeaeb3bddbb0c3f7f2a2bec74e6db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga486225945a8358b59ace571da1304d16" id="r_ga486225945a8358b59ace571da1304d16"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:ga486225945a8358b59ace571da1304d16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga486225945a8358b59ace571da1304d16">dg::geo::assign_bc_along_field_1st</a> (const FieldAligned &amp;fa, const container &amp;fm, const container &amp;fp, container &amp;fmg, container &amp;fpg, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bound, std::array&lt; double, 2 &gt; boundary_value={0, 0})</td></tr>
<tr class="memdesc:ga486225945a8358b59ace571da1304d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)  <br /></td></tr>
<tr class="separator:ga486225945a8358b59ace571da1304d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e1fb3f7160a5350c5cff6144c66fb3" id="r_gaf0e1fb3f7160a5350c5cff6144c66fb3"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:gaf0e1fb3f7160a5350c5cff6144c66fb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3">dg::geo::swap_bc_perp</a> (const FieldAligned &amp;fa, const container &amp;fm, const container &amp;fp, container &amp;fmg, container &amp;fpg)</td></tr>
<tr class="memdesc:gaf0e1fb3f7160a5350c5cff6144c66fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the perp boundary condition.  <br /></td></tr>
<tr class="separator:gaf0e1fb3f7160a5350c5cff6144c66fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8f31458f9eac9d48146217a2a80ec5a" id="r_gac8f31458f9eac9d48146217a2a80ec5a"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:gac8f31458f9eac9d48146217a2a80ec5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac8f31458f9eac9d48146217a2a80ec5a">dg::geo::ds_forward</a> (const FieldAligned &amp;fa, double alpha, const container &amp;f, const container &amp;fp, double beta, container &amp;g)</td></tr>
<tr class="memdesc:gac8f31458f9eac9d48146217a2a80ec5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <br /></td></tr>
<tr class="separator:gac8f31458f9eac9d48146217a2a80ec5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa01e219168bccd2a46e03e07655742" id="r_gabaa01e219168bccd2a46e03e07655742"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:gabaa01e219168bccd2a46e03e07655742"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabaa01e219168bccd2a46e03e07655742">dg::geo::ds_forward2</a> (const FieldAligned &amp;fa, double alpha, const container &amp;f, const container &amp;fp, const container &amp;fpp, double beta, container &amp;g)</td></tr>
<tr class="memdesc:gabaa01e219168bccd2a46e03e07655742"><td class="mdescLeft">&#160;</td><td class="mdescRight">2nd order forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <br /></td></tr>
<tr class="separator:gabaa01e219168bccd2a46e03e07655742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6396aaf776bf66cf08e20b83bb800a54" id="r_ga6396aaf776bf66cf08e20b83bb800a54"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:ga6396aaf776bf66cf08e20b83bb800a54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6396aaf776bf66cf08e20b83bb800a54">dg::geo::ds_backward</a> (const FieldAligned &amp;fa, double alpha, const container &amp;fm, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ga6396aaf776bf66cf08e20b83bb800a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <br /></td></tr>
<tr class="separator:ga6396aaf776bf66cf08e20b83bb800a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab5f8dffb7a25b0f1d071da49f4dc865" id="r_gaab5f8dffb7a25b0f1d071da49f4dc865"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:gaab5f8dffb7a25b0f1d071da49f4dc865"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaab5f8dffb7a25b0f1d071da49f4dc865">dg::geo::ds_backward2</a> (const FieldAligned &amp;fa, double alpha, const container &amp;fmm, const container &amp;fm, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:gaab5f8dffb7a25b0f1d071da49f4dc865"><td class="mdescLeft">&#160;</td><td class="mdescRight">2nd order backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <br /></td></tr>
<tr class="separator:gaab5f8dffb7a25b0f1d071da49f4dc865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d98ba526a42601f26374d4aacddec5" id="r_ga70d98ba526a42601f26374d4aacddec5"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:ga70d98ba526a42601f26374d4aacddec5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga70d98ba526a42601f26374d4aacddec5">dg::geo::ds_centered</a> (const FieldAligned &amp;fa, double alpha, const container &amp;fm, const container &amp;fp, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ga70d98ba526a42601f26374d4aacddec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <br /></td></tr>
<tr class="separator:ga70d98ba526a42601f26374d4aacddec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d0308bf8d169f14efc488419bfa33b6" id="r_ga9d0308bf8d169f14efc488419bfa33b6"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:ga9d0308bf8d169f14efc488419bfa33b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9d0308bf8d169f14efc488419bfa33b6">dg::geo::dss_centered</a> (const FieldAligned &amp;fa, double alpha, const container &amp;fm, const container &amp;f, const container &amp;fp, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ga9d0308bf8d169f14efc488419bfa33b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centered derivative \( g = \alpha (\vec v\cdot \nabla)^2 f + \beta g \).  <br /></td></tr>
<tr class="separator:ga9d0308bf8d169f14efc488419bfa33b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20aa9652f545d6b73c9223aad1754274" id="r_ga20aa9652f545d6b73c9223aad1754274"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:ga20aa9652f545d6b73c9223aad1754274"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga20aa9652f545d6b73c9223aad1754274">dg::geo::dssd_centered</a> (const FieldAligned &amp;fa, double alpha, const container &amp;fm, const container &amp;f, const container &amp;fp, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ga20aa9652f545d6b73c9223aad1754274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centered derivative \( g = \alpha \nabla\cdot(\vec v \vec v\cdot \nabla) f + \beta g \).  <br /></td></tr>
<tr class="separator:ga20aa9652f545d6b73c9223aad1754274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c32a12479eb779a95cfef23008d0fec" id="r_ga7c32a12479eb779a95cfef23008d0fec"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:ga7c32a12479eb779a95cfef23008d0fec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7c32a12479eb779a95cfef23008d0fec">dg::geo::ds_divBackward</a> (const FieldAligned &amp;fa, double alpha, const container &amp;fm, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ga7c32a12479eb779a95cfef23008d0fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward derivative \( g = \alpha \nabla \cdot \vec v f + \beta g\)  <br /></td></tr>
<tr class="separator:ga7c32a12479eb779a95cfef23008d0fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2baeefde9a28c8ce2059a2beca64a8da" id="r_ga2baeefde9a28c8ce2059a2beca64a8da"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:ga2baeefde9a28c8ce2059a2beca64a8da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2baeefde9a28c8ce2059a2beca64a8da">dg::geo::ds_divForward</a> (const FieldAligned &amp;fa, double alpha, const container &amp;f, const container &amp;fp, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ga2baeefde9a28c8ce2059a2beca64a8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward derivative \( g = \alpha \nabla \cdot \vec v f + \beta g\)  <br /></td></tr>
<tr class="separator:ga2baeefde9a28c8ce2059a2beca64a8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab882a17d950be8b3726b0e1d8f88da3f" id="r_gab882a17d950be8b3726b0e1d8f88da3f"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:gab882a17d950be8b3726b0e1d8f88da3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab882a17d950be8b3726b0e1d8f88da3f">dg::geo::ds_divCentered</a> (const FieldAligned &amp;fa, double alpha, const container &amp;fm, const container &amp;fp, double beta, container &amp;g)</td></tr>
<tr class="memdesc:gab882a17d950be8b3726b0e1d8f88da3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered derivative \( g = \alpha \nabla \cdot \vec v f + \beta g\)  <br /></td></tr>
<tr class="separator:gab882a17d950be8b3726b0e1d8f88da3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga496607d89f84f8d1a03f32161f1418f6" id="r_ga496607d89f84f8d1a03f32161f1418f6"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:ga496607d89f84f8d1a03f32161f1418f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga496607d89f84f8d1a03f32161f1418f6">dg::geo::ds_average</a> (const FieldAligned &amp;, double alpha, const container &amp;fm, const container &amp;fp, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ga496607d89f84f8d1a03f32161f1418f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute average along a fieldline \( g = \alpha \frac{f_{k+1} + f_{k-1}}{2} + \beta g\).  <br /></td></tr>
<tr class="separator:ga496607d89f84f8d1a03f32161f1418f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b68bc2345099d81cbe803982e767fc" id="r_gad5b68bc2345099d81cbe803982e767fc"><td class="memTemplParams" colspan="2">template&lt;class FieldAligned , class container &gt; </td></tr>
<tr class="memitem:gad5b68bc2345099d81cbe803982e767fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad5b68bc2345099d81cbe803982e767fc">dg::geo::ds_slope</a> (const FieldAligned &amp;fa, double alpha, const container &amp;fm, const container &amp;fp, double beta, container &amp;g)</td></tr>
<tr class="memdesc:gad5b68bc2345099d81cbe803982e767fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute simple slope along a fieldline \( g = \alpha v^\varphi\frac{f_{k+1} - f_{k-1}}{2\Delta\varphi} + \beta g\).  <br /></td></tr>
<tr class="separator:gad5b68bc2345099d81cbe803982e767fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973b9db1e92a2deb0187730252082f3b" id="r_ga973b9db1e92a2deb0187730252082f3b"><td class="memTemplParams" colspan="2">template&lt;class BinaryOp , class UnaryOp &gt; </td></tr>
<tr class="memitem:ga973b9db1e92a2deb0187730252082f3b"><td class="memTemplItemLeft" align="right" valign="top">thrust::host_vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga973b9db1e92a2deb0187730252082f3b">dg::geo::fieldaligned_evaluate</a> (const <a class="elRef" href="../../dg/html/group__gridtypes.html#ga66b28b21ade7da951d95a8de53a9951a">aProductGeometry3d</a> &amp;grid, const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl0.html">CylindricalVectorLvl0</a> &amp;vec, const BinaryOp &amp;binary, const UnaryOp &amp;unary, unsigned p0, unsigned rounds, double eps=1e-5)</td></tr>
<tr class="memdesc:ga973b9db1e92a2deb0187730252082f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a 2d functor and transform to all planes along the fieldlines  <br /></td></tr>
<tr class="separator:ga973b9db1e92a2deb0187730252082f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9b444a4071f4d2b2ee8097b62166457" id="r_gad9b444a4071f4d2b2ee8097b62166457"><td class="memTemplParams" colspan="2">template&lt;class BinaryOp , class UnaryOp &gt; </td></tr>
<tr class="memitem:gad9b444a4071f4d2b2ee8097b62166457"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../../dg/html/structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; thrust::host_vector&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad9b444a4071f4d2b2ee8097b62166457">dg::geo::fieldaligned_evaluate</a> (const <a class="elRef" href="../../dg/html/group__gridtypes.html#ga4f93074de01f15448f09aa7ce24f6a07">aProductMPIGeometry3d</a> &amp;grid, const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl0.html">CylindricalVectorLvl0</a> &amp;vec, const BinaryOp &amp;binary, const UnaryOp &amp;unary, unsigned p0, unsigned rounds, double eps=1e-5)</td></tr>
<tr class="memdesc:gad9b444a4071f4d2b2ee8097b62166457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a 2d functor and transform to all planes along the fieldlines (MPI Version)  <br /></td></tr>
<tr class="separator:gad9b444a4071f4d2b2ee8097b62166457"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>\( \nabla_\parallel f\) </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gac31adf6f15d6a1b64d5a13d751a9f449" name="gac31adf6f15d6a1b64d5a13d751a9f449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac31adf6f15d6a1b64d5a13d751a9f449">&#9670;&#160;</a></span>FullLimiter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../../dg/html/structdg_1_1_o_n_e.html">ONE</a> <a class="el" href="#gac31adf6f15d6a1b64d5a13d751a9f449">dg::geo::FullLimiter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full Limiter means there is a limiter everywhere. </p>

</div>
</div>
<a id="ga1a10e4fdd6338136e629d3e2292bc3da" name="ga1a10e4fdd6338136e629d3e2292bc3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a10e4fdd6338136e629d3e2292bc3da">&#9670;&#160;</a></span>NoLimiter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../../dg/html/structdg_1_1_z_e_r_o.html">ZERO</a> <a class="el" href="#ga1a10e4fdd6338136e629d3e2292bc3da">dg::geo::NoLimiter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No Limiter. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga10e4ac4f15fe73a4ff10569985224101" name="ga10e4ac4f15fe73a4ff10569985224101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10e4ac4f15fe73a4ff10569985224101">&#9670;&#160;</a></span>whichMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga10e4ac4f15fe73a4ff10569985224101">dg::geo::whichMatrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for the use in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga10e4ac4f15fe73a4ff10569985224101a3051e3e0498abaac57b76c94c1b94e25" name="gga10e4ac4f15fe73a4ff10569985224101a3051e3e0498abaac57b76c94c1b94e25"></a>einsPlus&#160;</td><td class="fielddoc"><p>plus interpolation in next plane </p>
</td></tr>
<tr><td class="fieldname"><a id="gga10e4ac4f15fe73a4ff10569985224101a123cc46161ad1c9729aa385716751918" name="gga10e4ac4f15fe73a4ff10569985224101a123cc46161ad1c9729aa385716751918"></a>einsPlusT&#160;</td><td class="fielddoc"><p>transposed plus interpolation in previous plane </p>
</td></tr>
<tr><td class="fieldname"><a id="gga10e4ac4f15fe73a4ff10569985224101ac4342c25611d86ddd01f4f48a2054f86" name="gga10e4ac4f15fe73a4ff10569985224101ac4342c25611d86ddd01f4f48a2054f86"></a>einsMinus&#160;</td><td class="fielddoc"><p>minus interpolation in previous plane </p>
</td></tr>
<tr><td class="fieldname"><a id="gga10e4ac4f15fe73a4ff10569985224101af101993895ad46716e7324439d6bd226" name="gga10e4ac4f15fe73a4ff10569985224101af101993895ad46716e7324439d6bd226"></a>einsMinusT&#160;</td><td class="fielddoc"><p>transposed minus interpolation in next plane </p>
</td></tr>
<tr><td class="fieldname"><a id="gga10e4ac4f15fe73a4ff10569985224101a1bcea579401004d4225a8ba87b913b40" name="gga10e4ac4f15fe73a4ff10569985224101a1bcea579401004d4225a8ba87b913b40"></a>zeroPlus&#160;</td><td class="fielddoc"><p>plus interpolation in the current plane </p>
</td></tr>
<tr><td class="fieldname"><a id="gga10e4ac4f15fe73a4ff10569985224101af7a25c0e42902dabbd5e1d24aa691898" name="gga10e4ac4f15fe73a4ff10569985224101af7a25c0e42902dabbd5e1d24aa691898"></a>zeroMinus&#160;</td><td class="fielddoc"><p>minus interpolation in the current plane </p>
</td></tr>
<tr><td class="fieldname"><a id="gga10e4ac4f15fe73a4ff10569985224101ad912895366d986757ddb2e2a986d56ce" name="gga10e4ac4f15fe73a4ff10569985224101ad912895366d986757ddb2e2a986d56ce"></a>zeroPlusT&#160;</td><td class="fielddoc"><p>transposed plus interpolation in the current plane </p>
</td></tr>
<tr><td class="fieldname"><a id="gga10e4ac4f15fe73a4ff10569985224101aa585e71c2f6ad3b442d4201b7bf71e9f" name="gga10e4ac4f15fe73a4ff10569985224101aa585e71c2f6ad3b442d4201b7bf71e9f"></a>zeroMinusT&#160;</td><td class="fielddoc"><p>transposed minus interpolation in the current plane </p>
</td></tr>
<tr><td class="fieldname"><a id="gga10e4ac4f15fe73a4ff10569985224101a486b999831d96a38d14085d217dee1da" name="gga10e4ac4f15fe73a4ff10569985224101a486b999831d96a38d14085d217dee1da"></a>zeroForw&#160;</td><td class="fielddoc"><p>from dg to transformed coordinates </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga486225945a8358b59ace571da1304d16" name="ga486225945a8358b59ace571da1304d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga486225945a8358b59ace571da1304d16">&#9670;&#160;</a></span>assign_bc_along_field_1st()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::assign_bc_along_field_1st </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>fmg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>fpg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>boundary_value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{0,0}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldAligned</td><td></td></tr>
    <tr><td class="paramname">container</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm)     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp)    </td></tr>
    <tr><td class="paramname">fmg</td><td>result (can alias fm) </td></tr>
    <tr><td class="paramname">fpg</td><td>result (can alias fp) </td></tr>
    <tr><td class="paramname">bound</td><td>either <a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a> or <a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a> (rest not implemented yet) </td></tr>
    <tr><td class="paramname">boundary_value</td><td>first value is for incoming fieldlines, second one for outgoing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>The boundary condition given as a parameter to this function overrules the boundary conditions used in the given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> object and the ones implicit in the einsPlus and einsMinus interpolations (Independently of whether the magnetic field was periodified or not). In this way it is possible to apply the same <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object to several quantities with different boundary conditions and save quite a bit of memory consumption.    </dd></dl>

</div>
</div>
<a id="ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" name="ga51aeaeb3bddbb0c3f7f2a2bec74e6db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9">&#9670;&#160;</a></span>assign_bc_along_field_2nd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::assign_bc_along_field_2nd </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>fmg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>fpg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>boundary_value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{0,0}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial. </p>
<p><b>Call this function before one of the freestanding ds functions to replace the default boundary conditions with along field boundary conditions</b></p>
<p>This function replaces the values of the plus and minus fields that are outside of the domain with ghost values. These values are constructed by fitting a polynomial through the boundary point, the plus or minus point and the center point. For the exact resulting formula consult the <a href="https://www.overleaf.com/read/jjvstccqzcjv" target="_blank">parallel derivative</a> writeup. This is achieved using masks that mark the points where fieldlines intersect the domain boundary and replace the interpolated boundary values. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldAligned</td><td></td></tr>
    <tr><td class="paramname">container</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances and masking regions  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm)    </td></tr>
    <tr><td class="paramname">f</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp)    </td></tr>
    <tr><td class="paramname">fmg</td><td>resulting eMinus field (can alias fm) </td></tr>
    <tr><td class="paramname">fpg</td><td>resulting ePlus field (can alias fp) </td></tr>
    <tr><td class="paramname">bound</td><td>either <a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a> or <a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364adece0b7644d85f490823799a3b97f7e6">dg::DIR</a> (rest not implemented yet) </td></tr>
    <tr><td class="paramname">boundary_value</td><td>first value is for incoming fieldlines, second one for outgoing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>The boundary condition given as a parameter to this function overrules the boundary conditions used in the given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> object and the ones implicit in the einsPlus and einsMinus interpolations (Independently of whether the magnetic field was periodified or not). In this way it is possible to apply the same <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object to several quantities with different boundary conditions and save quite a bit of memory consumption.    </dd></dl>

</div>
</div>
<a id="ga496607d89f84f8d1a03f32161f1418f6" name="ga496607d89f84f8d1a03f32161f1418f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga496607d89f84f8d1a03f32161f1418f6">&#9670;&#160;</a></span>ds_average()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::ds_average </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute average along a fieldline \( g = \alpha \frac{f_{k+1} + f_{k-1}}{2} + \beta g\). </p>
<dl class="section note"><dt>Note</dt><dd>The idea is to use this function on staggered grid implementations. There it can be used to convert a function from one grid to the staggered grid and back</dd></dl>
<p>[un-named FieldAligned] this object is ignored in this function but it is kept to keep the interface consistent with the other ds-type functions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm)     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp)    </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>

</div>
</div>
<a id="ga6396aaf776bf66cf08e20b83bb800a54" name="ga6396aaf776bf66cf08e20b83bb800a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6396aaf776bf66cf08e20b83bb800a54">&#9670;&#160;</a></span>ds_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::ds_backward </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>backward derivative \( g_i = \alpha \frac{v^\varphi}{\Delta\varphi}(f_{i} - f_{i-1}) + \beta g_i \) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm)   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>

</div>
</div>
<a id="gaab5f8dffb7a25b0f1d071da49f4dc865" name="gaab5f8dffb7a25b0f1d071da49f4dc865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab5f8dffb7a25b0f1d071da49f4dc865">&#9670;&#160;</a></span>ds_backward2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::ds_backward2 </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fmm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2nd order backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>backward derivative \( g_i = \alpha \frac{v^\varphi}{2\Delta\varphi}(3f_{i} - 4f_{i-1} + f_{i-2}) + \beta g_i \) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm) </td></tr>
    <tr><td class="paramname">fmm</td><td>twice apply fieldaligned(einsMinus, f, fm)   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>

</div>
</div>
<a id="ga70d98ba526a42601f26374d4aacddec5" name="ga70d98ba526a42601f26374d4aacddec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70d98ba526a42601f26374d4aacddec5">&#9670;&#160;</a></span>ds_centered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::ds_centered </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>centered derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>The formula used is \( g_i = \alpha \frac{v^\varphi}{2\Delta\varphi}(f_{i+1} - f_{i-1}) + \beta g_i \) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm)     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp)    </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>

</div>
</div>
<a id="ga7c32a12479eb779a95cfef23008d0fec" name="ga7c32a12479eb779a95cfef23008d0fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c32a12479eb779a95cfef23008d0fec">&#9670;&#160;</a></span>ds_divBackward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::ds_divBackward </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>backward derivative \( g = \alpha \nabla \cdot \vec v f + \beta g\) </p>
<p>backward derivative \( g_i = \alpha \frac{1}{\Delta\varphi\sqrt{G_i}}(\sqrt{G_{i}}v^\varphi_{i}f_{i} - \sqrt{G_{i-1}}v^\varphi_{i-1}f_{i-1}) + \beta g_i\) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm)    </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>

</div>
</div>
<a id="gab882a17d950be8b3726b0e1d8f88da3f" name="gab882a17d950be8b3726b0e1d8f88da3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab882a17d950be8b3726b0e1d8f88da3f">&#9670;&#160;</a></span>ds_divCentered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::ds_divCentered </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>centered derivative \( g = \alpha \nabla \cdot \vec v f + \beta g\) </p>
<p>centered derivative \( g_i = \alpha \frac{1}{2\Delta\varphi\sqrt{G_i}}(\sqrt{G_{i+1}}v^\varphi_{i+1}f_{i+1} - \sqrt{G_{i-1}}v^\varphi_{i-1}f_{i-1}) + \beta g_i\) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm)     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp)    </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>

</div>
</div>
<a id="ga2baeefde9a28c8ce2059a2beca64a8da" name="ga2baeefde9a28c8ce2059a2beca64a8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2baeefde9a28c8ce2059a2beca64a8da">&#9670;&#160;</a></span>ds_divForward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::ds_divForward </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>forward derivative \( g = \alpha \nabla \cdot \vec v f + \beta g\) </p>
<p>forward derivative \( g_i = \alpha \frac{1}{\Delta\varphi\sqrt{G_i}}(\sqrt{G_{i+1}}v^\varphi_{i+1}f_{i+1} - \sqrt{G_{i}}v^\varphi_{i}f_{i}) + \beta g_i\) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp)    </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>

</div>
</div>
<a id="gac8f31458f9eac9d48146217a2a80ec5a" name="gac8f31458f9eac9d48146217a2a80ec5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8f31458f9eac9d48146217a2a80ec5a">&#9670;&#160;</a></span>ds_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::ds_forward </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>forward derivative \( g_i = \alpha \frac{v^\varphi}{\Delta\varphi}(f_{i+1} - f_{i}) + \beta g_i\) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp)   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>

</div>
</div>
<a id="gabaa01e219168bccd2a46e03e07655742" name="gabaa01e219168bccd2a46e03e07655742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaa01e219168bccd2a46e03e07655742">&#9670;&#160;</a></span>ds_forward2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::ds_forward2 </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fpp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2nd order forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>forward derivative \( g_i = \alpha \frac{v^\varphi}{2\Delta\varphi}(-f_{i+2} + 4f_{i+1} - 3f_{i}) + \beta g_i\) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp) </td></tr>
    <tr><td class="paramname">fpp</td><td>twice apply fieldaligned(einsPlus, f, fp)   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>

</div>
</div>
<a id="gad5b68bc2345099d81cbe803982e767fc" name="gad5b68bc2345099d81cbe803982e767fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b68bc2345099d81cbe803982e767fc">&#9670;&#160;</a></span>ds_slope()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::ds_slope </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute simple slope along a fieldline \( g = \alpha v^\varphi\frac{f_{k+1} - f_{k-1}}{2\Delta\varphi} + \beta g\). </p>
<dl class="section note"><dt>Note</dt><dd>The idea is to use this function on staggered grid implementations. There it can be used to compute the gradient from one grid onto the staggered grid and vice versa </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances </td></tr>
    <tr><td class="paramname">alpha</td><td>Scalar  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm)     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp)    </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Does exactly the same as <code><a class="el" href="#ga70d98ba526a42601f26374d4aacddec5" title="centered derivative">ds_centered</a></code> </dd></dl>

</div>
</div>
<a id="ga9d0308bf8d169f14efc488419bfa33b6" name="ga9d0308bf8d169f14efc488419bfa33b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d0308bf8d169f14efc488419bfa33b6">&#9670;&#160;</a></span>dss_centered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::dss_centered </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Centered derivative \( g = \alpha (\vec v\cdot \nabla)^2 f + \beta g \). </p>
<p>The formula used is the one that is obtained if one thinks of \( \nabla_\parallel f\) on a staggered grid and then deriving the result i.e. <code><a class="el" href="#gac8f31458f9eac9d48146217a2a80ec5a" title="forward derivative">dg::geo::ds_forward</a></code> followed by <code><a class="el" href="#ga6396aaf776bf66cf08e20b83bb800a54" title="backward derivative">dg::geo::ds_backward</a></code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm)     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp)   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>

</div>
</div>
<a id="ga20aa9652f545d6b73c9223aad1754274" name="ga20aa9652f545d6b73c9223aad1754274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20aa9652f545d6b73c9223aad1754274">&#9670;&#160;</a></span>dssd_centered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::dssd_centered </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Centered derivative \( g = \alpha \nabla\cdot(\vec v \vec v\cdot \nabla) f + \beta g \). </p>
<p>The formula used is </p><p class="formulaDsp">
\[ \Delta_\parallel f = \nabla\cdot (\vec v \nabla_\parallel f )\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get grid distances  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm)     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp)   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function computes the same as the corresponding member function of <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">dg::geo::DS</a></code> but you have to compute the einsPlus and einsMinus interpolations from <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a></code> yourself. The reasoning for this function is that you can re-use the latter interpolations if you compute for example both first and second derivative of a function or even if you compute it for difference boundary conditions using <a class="el" href="#ga51aeaeb3bddbb0c3f7f2a2bec74e6db9" title="Assign boundary conditions along magnetic field lines interpolating a 2nd order polynomial.">dg::geo::assign_bc_along_field_2nd</a>, <a class="el" href="#ga486225945a8358b59ace571da1304d16" title="Assign boundary conditions along magnetic field lines interpolating a 1st order polynomial (a line)">dg::geo::assign_bc_along_field_1st</a> or <a class="el" href="#gaf0e1fb3f7160a5350c5cff6144c66fb3" title="Swap the perp boundary condition.">dg::geo::swap_bc_perp</a>    </dd></dl>

</div>
</div>
<a id="ga973b9db1e92a2deb0187730252082f3b" name="ga973b9db1e92a2deb0187730252082f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga973b9db1e92a2deb0187730252082f3b">&#9670;&#160;</a></span>fieldaligned_evaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BinaryOp , class UnaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">thrust::host_vector&lt; double &gt; dg::geo::fieldaligned_evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../dg/html/group__gridtypes.html#ga66b28b21ade7da951d95a8de53a9951a">aProductGeometry3d</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl0.html">CylindricalVectorLvl0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOp &amp;</td>          <td class="paramname"><span class="paramname"><em>binary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryOp &amp;</td>          <td class="paramname"><span class="paramname"><em>unary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>p0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>rounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>eps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-5</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a 2d functor and transform to all planes along the fieldlines </p>
<p>The algorithm does the equivalent of the following:</p><ul>
<li>Evaluate the given <code>BinaryOp</code> on a 2d plane</li>
<li>integrate fieldlines \( r N_z \Delta\varphi\) in both directions where \( N_z\) is the number of planes in the global 3d grid and \( r\) is the number of rounds. Then evaluate BinaryOp at the resulting points.</li>
<li>Scale the transformations with \( u ( \pm (iN_z + j)\Delta\varphi) \), where <code>u</code> is the given <code>UnarayOp</code>, <code>i</code> in [0..r] is the round index and <code>j</code> in [0..Nz] is the plane index and \(\Delta\varphi\) is the angular distance given in the constructor (can be different from the actual grid distance hz!).</li>
<li>Sum all transformations with the same plane index <code>j</code> , where the minus transformations get the inverted index \( N_z - j\).</li>
<li>Shift the index by \( p_0\)</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>This version of the algorithm is more exact but much slower than the evaluate member contained in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryOp</td><td>Binary Functor </td></tr>
    <tr><td class="paramname">UnaryOp</td><td>Unary Functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>The grid on which to integrate fieldlines. </td></tr>
    <tr><td class="paramname">vec</td><td>The vector field to integrate. Note that you can control how the boundary conditions are represented by changing vec outside the grid domain using e.g. the <code>periodify</code> function. </td></tr>
    <tr><td class="paramname">binary</td><td>Functor to evaluate in x-y </td></tr>
    <tr><td class="paramname">unary</td><td>Functor to evaluate in z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>unary</code> is evaluated such that <code>p0</code> corresponds to z=0, p0+1 corresponds to z=hz, p0-1 to z=-hz, ... </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p0</td><td>The index of the plane to start </td></tr>
    <tr><td class="paramname">rounds</td><td>The number of rounds <code>r</code> to follow a fieldline; can be zero, then the fieldlines are only followed within the current box ( no periodicity) </td></tr>
    <tr><td class="paramname">eps</td><td>The accuracy of the fieldline integrator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3d vector </dd></dl>

</div>
</div>
<a id="gad9b444a4071f4d2b2ee8097b62166457" name="gad9b444a4071f4d2b2ee8097b62166457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9b444a4071f4d2b2ee8097b62166457">&#9670;&#160;</a></span>fieldaligned_evaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BinaryOp , class UnaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../../dg/html/structdg_1_1_m_p_i___vector.html">MPI_Vector</a>&lt; thrust::host_vector&lt; double &gt; &gt; dg::geo::fieldaligned_evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../../dg/html/group__gridtypes.html#ga4f93074de01f15448f09aa7ce24f6a07">aProductMPIGeometry3d</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl0.html">CylindricalVectorLvl0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOp &amp;</td>          <td class="paramname"><span class="paramname"><em>binary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryOp &amp;</td>          <td class="paramname"><span class="paramname"><em>unary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>p0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>rounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>eps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-5</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a 2d functor and transform to all planes along the fieldlines (MPI Version) </p>
<p>The algorithm does the equivalent of the following:</p><ul>
<li>Evaluate the given <code>BinaryOp</code> on a 2d plane</li>
<li>integrate fieldlines \( r N_z \Delta\varphi\) in both directions where \( N_z\) is the number of planes in the global 3d grid and \( r\) is the number of rounds. Then evaluate BinaryOp at the resulting points.</li>
<li>Scale the transformations with \( u ( \pm (iN_z + j)\Delta\varphi) \), where <code>u</code> is the given <code>UnarayOp</code>, <code>i</code> in [0..r] is the round index and <code>j</code> in [0..Nz] is the plane index and \(\Delta\varphi\) is the angular distance given in the constructor (can be different from the actual grid distance hz!).</li>
<li>Sum all transformations with the same plane index <code>j</code> , where the minus transformations get the inverted index \( N_z - j\).</li>
<li>Shift the index by \( p_0\)</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>This version of the algorithm is more exact but much slower than the evaluate member contained in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">dg::geo::Fieldaligned</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryOp</td><td>Binary Functor </td></tr>
    <tr><td class="paramname">UnaryOp</td><td>Unary Functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>The grid on which to integrate fieldlines. </td></tr>
    <tr><td class="paramname">vec</td><td>The vector field to integrate. Note that you can control how the boundary conditions are represented by changing vec outside the grid domain using e.g. the <code>periodify</code> function. </td></tr>
    <tr><td class="paramname">binary</td><td>Functor to evaluate in x-y </td></tr>
    <tr><td class="paramname">unary</td><td>Functor to evaluate in z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>unary</code> is evaluated such that <code>p0</code> corresponds to z=0, p0+1 corresponds to z=hz, p0-1 to z=-hz, ... </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p0</td><td>The index of the plane to start </td></tr>
    <tr><td class="paramname">rounds</td><td>The number of rounds <code>r</code> to follow a fieldline; can be zero, then the fieldlines are only followed within the current box ( no periodicity) </td></tr>
    <tr><td class="paramname">eps</td><td>The accuracy of the fieldline integrator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3d vector    </dd></dl>

</div>
</div>
<a id="gaf0e1fb3f7160a5350c5cff6144c66fb3" name="gaf0e1fb3f7160a5350c5cff6144c66fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0e1fb3f7160a5350c5cff6144c66fb3">&#9670;&#160;</a></span>swap_bc_perp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FieldAligned , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dg::geo::swap_bc_perp </td>
          <td>(</td>
          <td class="paramtype">const FieldAligned &amp;</td>          <td class="paramname"><span class="paramname"><em>fa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>fmg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>fpg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the perp boundary condition. </p>
<p>This function multiplies (-1) to every value that lies outside the box. This effectively swaps the boundary conditions in the Fourier boundary mode, i.e. if NEU was used in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>, then now they are DIR and vice versa.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldAligned</td><td></td></tr>
    <tr><td class="paramname">container</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fa</td><td>this object will be used to get masking regions  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fm</td><td>fieldaligned(einsMinus, f, fm)     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>fieldaligned(einsPlus, f, fp)    </td></tr>
    <tr><td class="paramname">fmg</td><td>resulting eMinus field (can alias fm) </td></tr>
    <tr><td class="paramname">fpg</td><td>resulting ePlus field (can alias fp) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The motivation for this function is to avoid reconstructing a fieldaligned object since its constructor is quite expensive in runtime and memory. The idea is to construct <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> with NEU boundary conditions and then use this function to swap them to DIR whenever needed. </dd>
<dd>
The swapping of bc is not exactly (but almost) the same as re-constructing the fieldaligned object in case the support operator is used (mx, my &gt; 1), this is because the swap is performed only on the coarse grid. In all tests the error is negligible so far. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:36 for Extension: Geometries by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
