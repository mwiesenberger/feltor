<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Extension: Geometries: dg::geo::DS&lt; ProductGeometry, IMatrix, container &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
    <!-- ... doxygen-awesome Fragment copy ... -->
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <!-- ... End doxygen-awesome Fragment copy ... -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-fragment-copy-button.js" rel="stylesheet" type="text/css"/>
<link href="menubar.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Make a nice link to github (copied from doxygen-awesome/doxygen-custom/header.html-->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/feltor-dev/feltor" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="80" height="80" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- End Make a nice link to github -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <!--My own title area-->
  <ul class="menubar">
      <!-- <li><a href="../../../index.html">/</a><li>-->
    <li><a href="../../dg/html/topics.html">dg</a></li>
    <li><a href="../../geometries/html/topics.html">dg::geo</a></li>
    <li><a href="../../file/html/topics.html">dg::file</a></li>
    <li><a href="../../exblas/html/namespacedg_1_1exblas.html">dg::exblas</a></li>
    <li><a href="../../matrix/html/topics.html">dg::mat</a></li>
  </ul>
  <!--End My own title area-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Extension: Geometries
   </div>
   <div id="projectbrief">#include &quot;dg/geometries/geometries.h&quot;</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structdg_1_1geo_1_1_d_s.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdg_1_1geo_1_1_d_s-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dg::geo::DS&lt; ProductGeometry, IMatrix, container &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__fieldaligned.html">4. Fieldaligned derivatives</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Class for the evaluation of parallel derivatives.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2b75936ff587a3f8ab4e3da2f72ac429" id="r_a2b75936ff587a3f8ab4e3da2f72ac429"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt; ProductGeometry, IMatrix, container &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b75936ff587a3f8ab4e3da2f72ac429">FA</a></td></tr>
<tr class="separator:a2b75936ff587a3f8ab4e3da2f72ac429"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8cf677889e86b3bfad852fafd021acf4" id="r_a8cf677889e86b3bfad852fafd021acf4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cf677889e86b3bfad852fafd021acf4">DS</a> ()</td></tr>
<tr class="memdesc:a8cf677889e86b3bfad852fafd021acf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">No memory allocation; all member calls except construct are invalid.  <br /></td></tr>
<tr class="separator:a8cf677889e86b3bfad852fafd021acf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562778db9bad84374085929045df145d" id="r_a562778db9bad84374085929045df145d"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:a562778db9bad84374085929045df145d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a562778db9bad84374085929045df145d">DS</a> (const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;vec, const ProductGeometry &amp;grid, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), double eps=1e-5, unsigned mx=10, unsigned my=10, double deltaPhi=-1, std::string interpolation_method=&quot;dg&quot;, bool benchmark=true)</td></tr>
<tr class="memdesc:a562778db9bad84374085929045df145d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the magnetic unit vector field and construct.  <br /></td></tr>
<tr class="separator:a562778db9bad84374085929045df145d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3448fa9b615a31480ffee32b24d16158" id="r_a3448fa9b615a31480ffee32b24d16158"><td class="memTemplParams" colspan="2">template&lt;class Limiter &gt; </td></tr>
<tr class="memitem:a3448fa9b615a31480ffee32b24d16158"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3448fa9b615a31480ffee32b24d16158">DS</a> (const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl1.html">dg::geo::CylindricalVectorLvl1</a> &amp;vec, const ProductGeometry &amp;grid, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcx=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcy=<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, Limiter limit=<a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>(), double eps=1e-5, unsigned mx=10, unsigned my=10, double deltaPhi=-1, std::string interpolation_method=&quot;dg&quot;, bool benchmark=true)</td></tr>
<tr class="memdesc:a3448fa9b615a31480ffee32b24d16158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the given vector field to construct.  <br /></td></tr>
<tr class="separator:a3448fa9b615a31480ffee32b24d16158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b13a242ab6db8f3fb0cb32a9b38d99a" id="r_a5b13a242ab6db8f3fb0cb32a9b38d99a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b13a242ab6db8f3fb0cb32a9b38d99a">DS</a> (<a class="el" href="#a2b75936ff587a3f8ab4e3da2f72ac429">FA</a> <a class="el" href="#aadefe104d1560a2feefb7ff51ef38b71">fieldaligned</a>)</td></tr>
<tr class="memdesc:a5b13a242ab6db8f3fb0cb32a9b38d99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-construct from a given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> object.  <br /></td></tr>
<tr class="separator:a5b13a242ab6db8f3fb0cb32a9b38d99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ba5f4f4eecb13c7651e22e127e904f" id="r_a64ba5f4f4eecb13c7651e22e127e904f"><td class="memTemplParams" colspan="2">template&lt;class ... Params&gt; </td></tr>
<tr class="memitem:a64ba5f4f4eecb13c7651e22e127e904f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a64ba5f4f4eecb13c7651e22e127e904f">construct</a> (Params &amp;&amp;...ps)</td></tr>
<tr class="memdesc:a64ba5f4f4eecb13c7651e22e127e904f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect forward parameters to one of the constructors.  <br /></td></tr>
<tr class="separator:a64ba5f4f4eecb13c7651e22e127e904f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6b9b87d6cd4c2c213727af599af965" id="r_a5c6b9b87d6cd4c2c213727af599af965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c6b9b87d6cd4c2c213727af599af965">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, double left, double right)</td></tr>
<tr class="memdesc:a5c6b9b87d6cd4c2c213727af599af965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.     <br /></td></tr>
<tr class="separator:a5c6b9b87d6cd4c2c213727af599af965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f99ff7e2291c6a1139e80e200b74c1" id="r_a68f99ff7e2291c6a1139e80e200b74c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68f99ff7e2291c6a1139e80e200b74c1">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;left, const container &amp;right)</td></tr>
<tr class="memdesc:a68f99ff7e2291c6a1139e80e200b74c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.     <br /></td></tr>
<tr class="separator:a68f99ff7e2291c6a1139e80e200b74c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32ac2bd63fba61762f1160b560e037e" id="r_ae32ac2bd63fba61762f1160b560e037e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae32ac2bd63fba61762f1160b560e037e">set_boundaries</a> (<a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bcz, const container &amp;global, double scal_left, double scal_right)</td></tr>
<tr class="memdesc:ae32ac2bd63fba61762f1160b560e037e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boundary conditions in the limiter region.     <br /></td></tr>
<tr class="separator:ae32ac2bd63fba61762f1160b560e037e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985a34d89fd63d5d640a9dd1994dd64d" id="r_a985a34d89fd63d5d640a9dd1994dd64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a985a34d89fd63d5d640a9dd1994dd64d">forward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a985a34d89fd63d5d640a9dd1994dd64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <br /></td></tr>
<tr class="separator:a985a34d89fd63d5d640a9dd1994dd64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1d413e4d312e1bcba6d6ff9a4f6682" id="r_aeb1d413e4d312e1bcba6d6ff9a4f6682"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb1d413e4d312e1bcba6d6ff9a4f6682">forward2</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:aeb1d413e4d312e1bcba6d6ff9a4f6682"><td class="mdescLeft">&#160;</td><td class="mdescRight">2nd order forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <br /></td></tr>
<tr class="separator:aeb1d413e4d312e1bcba6d6ff9a4f6682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ce06edef5f61478606de8d8c67895c" id="r_a09ce06edef5f61478606de8d8c67895c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09ce06edef5f61478606de8d8c67895c">backward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a09ce06edef5f61478606de8d8c67895c"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <br /></td></tr>
<tr class="separator:a09ce06edef5f61478606de8d8c67895c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10864d34e051c2defa9ccdd87685268" id="r_ad10864d34e051c2defa9ccdd87685268"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad10864d34e051c2defa9ccdd87685268">backward2</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:ad10864d34e051c2defa9ccdd87685268"><td class="mdescLeft">&#160;</td><td class="mdescRight">2nd order backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <br /></td></tr>
<tr class="separator:ad10864d34e051c2defa9ccdd87685268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683a013de097e44f8d53f38f816a8abb" id="r_a683a013de097e44f8d53f38f816a8abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a683a013de097e44f8d53f38f816a8abb">centered</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a683a013de097e44f8d53f38f816a8abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\)  <br /></td></tr>
<tr class="separator:a683a013de097e44f8d53f38f816a8abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0f000d91e6f3188ced811e38f86ea7" id="r_a4a0f000d91e6f3188ced811e38f86ea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a0f000d91e6f3188ced811e38f86ea7">centered_bc_along_field</a> (double alpha, const container &amp;f, double beta, container &amp;g, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bound, std::array&lt; double, 2 &gt; boundary_value={0, 0})</td></tr>
<tr class="memdesc:a4a0f000d91e6f3188ced811e38f86ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code><a class="el" href="group__fieldaligned.html#ga70d98ba526a42601f26374d4aacddec5" title="centered derivative">dg::geo::ds_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>.  <br /></td></tr>
<tr class="separator:a4a0f000d91e6f3188ced811e38f86ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b715011f3067fc3b12999efc525c7d" id="r_a14b715011f3067fc3b12999efc525c7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14b715011f3067fc3b12999efc525c7d">backward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a14b715011f3067fc3b12999efc525c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward derivative \( g = \vec v \cdot \nabla f \)  <br /></td></tr>
<tr class="separator:a14b715011f3067fc3b12999efc525c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd2d475a634a5f991507c66b1948fff" id="r_a1fd2d475a634a5f991507c66b1948fff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fd2d475a634a5f991507c66b1948fff">forward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a1fd2d475a634a5f991507c66b1948fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward derivative \( g = \vec v \cdot \nabla f \)  <br /></td></tr>
<tr class="separator:a1fd2d475a634a5f991507c66b1948fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae715c59177d1b0e824f0e6d62b1b7733" id="r_ae715c59177d1b0e824f0e6d62b1b7733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae715c59177d1b0e824f0e6d62b1b7733">centered</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ae715c59177d1b0e824f0e6d62b1b7733"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered derivative \( g = \vec v \cdot \nabla f \)  <br /></td></tr>
<tr class="separator:ae715c59177d1b0e824f0e6d62b1b7733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb40af56b10c73db2fcc18c52bdc183" id="r_adbb40af56b10c73db2fcc18c52bdc183"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbb40af56b10c73db2fcc18c52bdc183">divForward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:adbb40af56b10c73db2fcc18c52bdc183"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <br /></td></tr>
<tr class="separator:adbb40af56b10c73db2fcc18c52bdc183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc3e43d58831703543075575a1ac736" id="r_a2fc3e43d58831703543075575a1ac736"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fc3e43d58831703543075575a1ac736">divBackward</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a2fc3e43d58831703543075575a1ac736"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <br /></td></tr>
<tr class="separator:a2fc3e43d58831703543075575a1ac736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce6a527b77128d97515c3d109067bb6" id="r_a1ce6a527b77128d97515c3d109067bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ce6a527b77128d97515c3d109067bb6">divCentered</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a1ce6a527b77128d97515c3d109067bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\)  <br /></td></tr>
<tr class="separator:a1ce6a527b77128d97515c3d109067bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d92c54f67c86c1ebb76c3e9e5c064ab" id="r_a2d92c54f67c86c1ebb76c3e9e5c064ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d92c54f67c86c1ebb76c3e9e5c064ab">divForward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a2d92c54f67c86c1ebb76c3e9e5c064ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward divergence \( g = \nabla\cdot(\vec v f)\)  <br /></td></tr>
<tr class="separator:a2d92c54f67c86c1ebb76c3e9e5c064ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af683e046f6b59a823278b32e2fb0b787" id="r_af683e046f6b59a823278b32e2fb0b787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af683e046f6b59a823278b32e2fb0b787">divBackward</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:af683e046f6b59a823278b32e2fb0b787"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward divergence \( g = \nabla\cdot(\vec v f)\)  <br /></td></tr>
<tr class="separator:af683e046f6b59a823278b32e2fb0b787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183839b4cebbdf89af7e99c1ec499f86" id="r_a183839b4cebbdf89af7e99c1ec499f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a183839b4cebbdf89af7e99c1ec499f86">divCentered</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a183839b4cebbdf89af7e99c1ec499f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">centered divergence \( g = \nabla\cdot(\vec v f)\)  <br /></td></tr>
<tr class="separator:a183839b4cebbdf89af7e99c1ec499f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af592f11db44e30e033d9df5a2236aa96" id="r_af592f11db44e30e033d9df5a2236aa96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af592f11db44e30e033d9df5a2236aa96">ds</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:af592f11db44e30e033d9df5a2236aa96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \vec v\cdot \nabla f \).  <br /></td></tr>
<tr class="separator:af592f11db44e30e033d9df5a2236aa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe05ed48761f7a4a4a4934d1040ef151" id="r_abe05ed48761f7a4a4a4934d1040ef151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe05ed48761f7a4a4a4934d1040ef151">ds</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:abe05ed48761f7a4a4a4934d1040ef151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \vec v\cdot \nabla f + \beta g \).  <br /></td></tr>
<tr class="separator:abe05ed48761f7a4a4a4934d1040ef151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78cd48c94612d01d464bb381b775c92" id="r_ae78cd48c94612d01d464bb381b775c92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae78cd48c94612d01d464bb381b775c92">div</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:ae78cd48c94612d01d464bb381b775c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \nabla \cdot ( \vec v f) \).  <br /></td></tr>
<tr class="separator:ae78cd48c94612d01d464bb381b775c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf806d00464e8e6c95f71a4bd316c0f" id="r_a0bf806d00464e8e6c95f71a4bd316c0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bf806d00464e8e6c95f71a4bd316c0f">div</a> (<a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a> dir, double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a0bf806d00464e8e6c95f71a4bd316c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \nabla \cdot( \vec v f) + \beta g \).  <br /></td></tr>
<tr class="separator:a0bf806d00464e8e6c95f71a4bd316c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f38d345738a8261627cacf04abab98" id="r_a96f38d345738a8261627cacf04abab98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96f38d345738a8261627cacf04abab98">symv</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a96f38d345738a8261627cacf04abab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \nabla\cdot ( \vec v \vec v \cdot \nabla f )\).  <br /></td></tr>
<tr class="separator:a96f38d345738a8261627cacf04abab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e0fb3a747be784321a8c28bb34fafe" id="r_a21e0fb3a747be784321a8c28bb34fafe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21e0fb3a747be784321a8c28bb34fafe">symv</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a21e0fb3a747be784321a8c28bb34fafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha \nabla\cdot ( \vec v \vec v \cdot \nabla f ) + \beta g\) as a symmetric matrix.  <br /></td></tr>
<tr class="separator:a21e0fb3a747be784321a8c28bb34fafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca167849f022f279455b10b9f32b825" id="r_a4ca167849f022f279455b10b9f32b825"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ca167849f022f279455b10b9f32b825">dss</a> (const container &amp;f, container &amp;g)</td></tr>
<tr class="memdesc:a4ca167849f022f279455b10b9f32b825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = (\vec v\cdot \nabla)^2 f \).  <br /></td></tr>
<tr class="separator:a4ca167849f022f279455b10b9f32b825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6936d46b163e0430f57516b44e8330bd" id="r_a6936d46b163e0430f57516b44e8330bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6936d46b163e0430f57516b44e8330bd">dss</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a6936d46b163e0430f57516b44e8330bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discretizes \( g = \alpha (\vec v\cdot \nabla)^2 f + \beta g \).  <br /></td></tr>
<tr class="separator:a6936d46b163e0430f57516b44e8330bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af515ee483a0c3629a3eaaaa27153c791" id="r_af515ee483a0c3629a3eaaaa27153c791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af515ee483a0c3629a3eaaaa27153c791">dss_bc_along_field</a> (double alpha, const container &amp;f, double beta, container &amp;g, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bound, std::array&lt; double, 2 &gt; boundary_value={0, 0})</td></tr>
<tr class="memdesc:af515ee483a0c3629a3eaaaa27153c791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code><a class="el" href="group__fieldaligned.html#ga9d0308bf8d169f14efc488419bfa33b6" title="Centered derivative .">dg::geo::dss_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>.  <br /></td></tr>
<tr class="separator:af515ee483a0c3629a3eaaaa27153c791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcd6aed8123941867098c83867fb5a3" id="r_a5dcd6aed8123941867098c83867fb5a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dcd6aed8123941867098c83867fb5a3">dssd</a> (double alpha, const container &amp;f, double beta, container &amp;g)</td></tr>
<tr class="memdesc:a5dcd6aed8123941867098c83867fb5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code><a class="el" href="group__fieldaligned.html#ga20aa9652f545d6b73c9223aad1754274" title="Centered derivative .">dg::geo::dssd_centered</a></code>.  <br /></td></tr>
<tr class="separator:a5dcd6aed8123941867098c83867fb5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6fcd8ea9476def0dfd0d726fac1c97" id="r_a8d6fcd8ea9476def0dfd0d726fac1c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d6fcd8ea9476def0dfd0d726fac1c97">dssd_bc_along_field</a> (double alpha, const container &amp;f, double beta, container &amp;g, <a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a> bound, std::array&lt; double, 2 &gt; boundary_value={0, 0})</td></tr>
<tr class="memdesc:a8d6fcd8ea9476def0dfd0d726fac1c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code><a class="el" href="group__fieldaligned.html#ga20aa9652f545d6b73c9223aad1754274" title="Centered derivative .">dg::geo::dssd_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>.  <br /></td></tr>
<tr class="separator:a8d6fcd8ea9476def0dfd0d726fac1c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f27cd79cb9d743080acc55c5a102699" id="r_a4f27cd79cb9d743080acc55c5a102699"><td class="memItemLeft" align="right" valign="top">const container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f27cd79cb9d743080acc55c5a102699">weights</a> () const</td></tr>
<tr class="memdesc:a4f27cd79cb9d743080acc55c5a102699"><td class="mdescLeft">&#160;</td><td class="mdescRight">The volume form with dG weights.  <br /></td></tr>
<tr class="separator:a4f27cd79cb9d743080acc55c5a102699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadefe104d1560a2feefb7ff51ef38b71" id="r_aadefe104d1560a2feefb7ff51ef38b71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2b75936ff587a3f8ab4e3da2f72ac429">FA</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadefe104d1560a2feefb7ff51ef38b71">fieldaligned</a> ()</td></tr>
<tr class="memdesc:aadefe104d1560a2feefb7ff51ef38b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the underlying <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object  <br /></td></tr>
<tr class="separator:aadefe104d1560a2feefb7ff51ef38b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac59e81a1abf0cf0386e55e11dd21a5" id="r_a0ac59e81a1abf0cf0386e55e11dd21a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a2b75936ff587a3f8ab4e3da2f72ac429">FA</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ac59e81a1abf0cf0386e55e11dd21a5">fieldaligned</a> () const</td></tr>
<tr class="separator:a0ac59e81a1abf0cf0386e55e11dd21a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ProductGeometry, class IMatrix, class container&gt;<br />
struct dg::geo::DS&lt; ProductGeometry, IMatrix, container &gt;</div><p>Class for the evaluation of parallel derivatives. </p>
<p>This class discretizes the operators \( \nabla_\parallel = \vec{v}\cdot \nabla = v^\zeta\partial_\zeta + v^\eta\partial_\eta + v^\varphi\partial_\varphi \), \(\nabla_\parallel^\dagger = -\nabla\cdot(\vec v .)\) and \(\Delta_\parallel=-\nabla_\parallel^\dagger\cdot\nabla_\parallel\) in arbitrary coordinates </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code hl_structRef" href="../../dg/html/structdg_1_1_real_cylindrical_m_p_i_grid3d.html">dg::x::CylindricalGrid3d</a> g3d( R_0-a, R_0+a, -a, a, 0, 2.*M_PI, n, Nx, Ny, Nz, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></div>
<div class="line">#ifdef WITH_MPI</div>
<div class="line">    , comm</div>
<div class="line">#endif</div>
<div class="line">    );</div>
<div class="line">    <span class="comment">//create magnetic field</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> mag = <a class="code hl_function" href="group__circular.html#gad29f3061004dbc53e667788458a92eb5">dg::geo::createCircularField</a>( R_0, I_0);</div>
<div class="line">    <span class="keyword">auto</span> bhat = <a class="code hl_function" href="group__magnetic.html#gac7f646da25a618a26e3f6ff9ba3ff09e">dg::geo::createBHat</a>(mag);</div>
<div class="line">    <span class="comment">//create Fieldaligned object and construct DS from it</span></div>
<div class="line">    <a class="code hl_struct" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned&lt;dg::x::aProductGeometry3d,dg::x::IDMatrix,dg::x::DVec&gt;</a>  dsFA(</div>
<div class="line">            bhat, g3d, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_variableRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a>, <a class="code hl_structRef" href="../../dg/html/structdg_1_1_z_e_r_o.html">dg::geo::NoLimiter</a>(), 1e-8, mx[0], mx[1],</div>
<div class="line">            -1, method);</div>
<div class="line">    <a class="code hl_struct" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS&lt;dg::x::aProductGeometry3d, dg::x::IDMatrix, dg::x::DVec&gt;</a></div>
<div class="line">        ds( dsFA );</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The parallel Laplacian cannot be inverted as long as there are closed fieldlines somewhere in the domain (which is virtually always true). </dd>
<dd>
The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ProductGeometry</td><td>must be either <code><a class="elRef" href="../../dg/html/group__gridtypes.html#ga66b28b21ade7da951d95a8de53a9951a">dg::aProductGeometry3d</a></code> or <code><a class="elRef" href="../../dg/html/group__gridtypes.html#ga4f93074de01f15448f09aa7ce24f6a07">dg::aProductMPIGeometry3d</a></code> or any derivative </td></tr>
    <tr><td class="paramname">IMatrix</td><td>The type of the interpolation matrix<ul>
<li><code><a class="elRef" href="../../dg/html/group__typedefs.html#ga0574e9a1653d69754216f030cd8d4e18">dg::IHMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga813f1498b206af847ea78d2f674643c0">dg::IDMatrix</a></code>, <code><a class="elRef" href="../../dg/html/group__typedefs.html#gab622161a256102963db4c7fb181242d2">dg::MIHMatrix</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#gafbfc86f2a3681e765e358f66a851d09b">dg::MIDMatrix</a></code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">container</td><td>The container-class on which the interpolation matrix operates on<ul>
<li><code><a class="elRef" href="../../dg/html/group__typedefs.html#gae96159fd82ffccb3e43d361798b9b1ef">dg::HVec</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga8a6aa043869775ccdd104ec76c203eab">dg::DVec</a></code>, <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga85537b3f4c765fc2fb64542f9e921c8a">dg::MHVec</a></code>, or <code><a class="elRef" href="../../dg/html/group__typedefs.html#ga51c318aff99dd51d76cd666818ce5b56">dg::MDVec</a></code> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code><a class="elRef" href="../../dg/html/structdg_1_1_tensor_traits.html">dg::TensorTraits</a></code> are defined for this class and thus <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">DS</a></code> is usable as a Matrix class (calling <code>symv</code> ) </dd></dl>
<dl class="section see"><dt>See also</dt><dd>The pdf <a href="https://www.overleaf.com/read/jjvstccqzcjv" target="_blank">parallel derivative</a> writeup </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2b75936ff587a3f8ab4e3da2f72ac429" name="a2b75936ff587a3f8ab4e3da2f72ac429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b75936ff587a3f8ab4e3da2f72ac429">&#9670;&#160;</a></span>FA</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html">dg::geo::Fieldaligned</a>&lt;ProductGeometry, IMatrix, container&gt; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::FA</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>conveniently abbreviates underlying <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8cf677889e86b3bfad852fafd021acf4" name="a8cf677889e86b3bfad852fafd021acf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf677889e86b3bfad852fafd021acf4">&#9670;&#160;</a></span>DS() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::DS </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No memory allocation; all member calls except construct are invalid. </p>

</div>
</div>
<a id="a562778db9bad84374085929045df145d" name="a562778db9bad84374085929045df145d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562778db9bad84374085929045df145d">&#9670;&#160;</a></span>DS() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::DS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_tokamak_magnetic_field.html">dg::geo::TokamakMagneticField</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter</td>          <td class="paramname"><span class="paramname"><em>limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>eps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>mx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>my</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>deltaPhi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>interpolation_method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>benchmark</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the magnetic unit vector field and construct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate. Note that you can control how the boundary conditions are represented by changing vec outside the grid domain using e.g. the <code>periodify</code> function. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to integrate fieldlines. </td></tr>
    <tr><td class="paramname">bcx</td><td>This parameter is passed on to <code>dg::create::interpolation(const thrust::host_vector&lt;real_type&gt;&amp;,const thrust::host_vector&lt;real_type&gt;&amp;,const aRealTopology2d&lt;real_type&gt;&amp;,dg::bc,dg::bc,std::string)</code> (see there for more details) function and deterimens what happens when the endpoint of the fieldline integration leaves the domain boundaries of <code>grid</code>. Note that <code>bcx</code> and <code>grid.bcx()</code> have to be either both periodic or both not periodic. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Note that if <code>grid.bcz()==<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code> this parameter is ignored, Default is a limiter everywhere)     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">mx</td><td>refinement factor in X of the fine grid relative to grid (Set to 1, if the x-component of <code>vec</code> vanishes, else as high as possible, 12 is a good start) If the projection method (parsed from <code>interpolation_method</code>) is not "dg" then <code>mx</code> must be a multiple of <code>nx</code> </td></tr>
    <tr><td class="paramname">my</td><td>analogous to <code>mx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>The angular distance that the fieldline-integrator will integrate. Per default this is the distance between planes, which is chosen automatically if you set it &lt;=0, i.e. if deltaPhi &lt;=0 then it will be overwritten to deltaPhi = grid.hz(). Sometimes however, you may want to set it to a different value from <code>grid.hz()</code> for example for 2d problems or for a staggered grid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>deltaPhi influences the interpolation matrices and the parallel modulation in the <a class="elRef" href="../../dg/html/group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">evaluate()</a> member function. </dd>
<dd>
If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpolation_method</td><td>parsed according to</td></tr>
  </table>
  </dd>
</dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">interpolation_method   </th><th class="markdownTableHeadNone">interpolation   </th><th class="markdownTableHeadNone">projection    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"dg"   </td><td class="markdownTableBodyNone">"dg"   </td><td class="markdownTableBodyNone">"dg"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"linear"   </td><td class="markdownTableBodyNone">"linear"   </td><td class="markdownTableBodyNone">"dg"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"cubic"   </td><td class="markdownTableBodyNone">"cubic"   </td><td class="markdownTableBodyNone">"dg"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"nearest"   </td><td class="markdownTableBodyNone">"nearest"   </td><td class="markdownTableBodyNone">"dg"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"linear-nearest" (##)   </td><td class="markdownTableBodyNone">"linear"   </td><td class="markdownTableBodyNone">"nearest"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"cubic-nearest"   </td><td class="markdownTableBodyNone">"cubic"   </td><td class="markdownTableBodyNone">"nearest"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"nearest-nearest"   </td><td class="markdownTableBodyNone">"nearest"   </td><td class="markdownTableBodyNone">"nearest"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"dg-linear"   </td><td class="markdownTableBodyNone">"dg"   </td><td class="markdownTableBodyNone">"linear"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"linear-linear"   </td><td class="markdownTableBodyNone">"linear"   </td><td class="markdownTableBodyNone">"linear"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"cubic-linear"   </td><td class="markdownTableBodyNone">"cubic"   </td><td class="markdownTableBodyNone">"linear"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"nearest-linear"   </td><td class="markdownTableBodyNone">"nearest"   </td><td class="markdownTableBodyNone">"linear"   </td></tr>
</table>
<p>(##) Use "linear-nearest" if in doubt. The table yields one parameter passed to <code><a class="elRef" href="../../dg/html/group__interpolation.html#gaebbccbc4e9b740740cd2e9db394d580f">create::interpolation</a></code> (from the given grid to the fine grid) and one parameter to <code><a class="elRef" href="../../dg/html/group__interpolation.html#ga9383cf8ef0d0cc6af8c1250ecb31dc58">create::projection</a></code> (from the fine grid to the given grid)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">benchmark</td><td>If true write construction timings to std::cout    </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> </dd></dl>

</div>
</div>
<a id="a3448fa9b615a31480ffee32b24d16158" name="a3448fa9b615a31480ffee32b24d16158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3448fa9b615a31480ffee32b24d16158">&#9670;&#160;</a></span>DS() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class Limiter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::DS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdg_1_1geo_1_1_cylindrical_vector_lvl1.html">dg::geo::CylindricalVectorLvl1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProductGeometry &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364ad8a2f69a62e7fdafe1665ae7162e8e10">dg::NEU</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Limiter</td>          <td class="paramname"><span class="paramname"><em>limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__fieldaligned.html#gac31adf6f15d6a1b64d5a13d751a9f449">FullLimiter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>eps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>mx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>my</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>deltaPhi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>interpolation_method</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;dg&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>benchmark</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the given vector field to construct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Limiter</td><td>Class that can be evaluated on a 2d grid, returns 1 if there is a limiter and 0 if there isn't. If a field line crosses the limiter in the plane \( \phi=0\) then the limiter boundary conditions apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector field to integrate. Note that you can control how the boundary conditions are represented by changing vec outside the grid domain using e.g. the <code>periodify</code> function. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid on which to integrate fieldlines. </td></tr>
    <tr><td class="paramname">bcx</td><td>This parameter is passed on to <code>dg::create::interpolation(const thrust::host_vector&lt;real_type&gt;&amp;,const thrust::host_vector&lt;real_type&gt;&amp;,const aRealTopology2d&lt;real_type&gt;&amp;,dg::bc,dg::bc,std::string)</code> (see there for more details) function and deterimens what happens when the endpoint of the fieldline integration leaves the domain boundaries of <code>grid</code>. Note that <code>bcx</code> and <code>grid.bcx()</code> have to be either both periodic or both not periodic. </td></tr>
    <tr><td class="paramname">bcy</td><td>analogous to <code>bcx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">limit</td><td>Instance of the limiter class (Note that if <code>grid.bcz()==<a class="elRef" href="../../dg/html/group__creation.html#gga59440bdf436f2874b49aa52b670ed364a948704f60491461974ce4fe6339778b3">dg::PER</a></code> this parameter is ignored, Default is a limiter everywhere)     </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eps</td><td>Desired accuracy of the fieldline integrator </td></tr>
    <tr><td class="paramname">mx</td><td>refinement factor in X of the fine grid relative to grid (Set to 1, if the x-component of <code>vec</code> vanishes, else as high as possible, 12 is a good start) If the projection method (parsed from <code>interpolation_method</code>) is not "dg" then <code>mx</code> must be a multiple of <code>nx</code> </td></tr>
    <tr><td class="paramname">my</td><td>analogous to <code>mx</code>, applies to y direction </td></tr>
    <tr><td class="paramname">deltaPhi</td><td>The angular distance that the fieldline-integrator will integrate. Per default this is the distance between planes, which is chosen automatically if you set it &lt;=0, i.e. if deltaPhi &lt;=0 then it will be overwritten to deltaPhi = grid.hz(). Sometimes however, you may want to set it to a different value from <code>grid.hz()</code> for example for 2d problems or for a staggered grid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>deltaPhi influences the interpolation matrices and the parallel modulation in the <a class="elRef" href="../../dg/html/group__evaluation.html#gadf4f05776823ffaf1af7d3bb7a065b37">evaluate()</a> member function. </dd>
<dd>
If there is a limiter, the boundary condition on the first/last plane is set by the <code>grid.bcz()</code> variable and can be changed by the set_boundaries function. If there is no limiter, the boundary condition is periodic. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpolation_method</td><td>parsed according to</td></tr>
  </table>
  </dd>
</dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">interpolation_method   </th><th class="markdownTableHeadNone">interpolation   </th><th class="markdownTableHeadNone">projection    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"dg"   </td><td class="markdownTableBodyNone">"dg"   </td><td class="markdownTableBodyNone">"dg"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"linear"   </td><td class="markdownTableBodyNone">"linear"   </td><td class="markdownTableBodyNone">"dg"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"cubic"   </td><td class="markdownTableBodyNone">"cubic"   </td><td class="markdownTableBodyNone">"dg"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"nearest"   </td><td class="markdownTableBodyNone">"nearest"   </td><td class="markdownTableBodyNone">"dg"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"linear-nearest" (##)   </td><td class="markdownTableBodyNone">"linear"   </td><td class="markdownTableBodyNone">"nearest"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"cubic-nearest"   </td><td class="markdownTableBodyNone">"cubic"   </td><td class="markdownTableBodyNone">"nearest"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"nearest-nearest"   </td><td class="markdownTableBodyNone">"nearest"   </td><td class="markdownTableBodyNone">"nearest"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"dg-linear"   </td><td class="markdownTableBodyNone">"dg"   </td><td class="markdownTableBodyNone">"linear"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"linear-linear"   </td><td class="markdownTableBodyNone">"linear"   </td><td class="markdownTableBodyNone">"linear"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"cubic-linear"   </td><td class="markdownTableBodyNone">"cubic"   </td><td class="markdownTableBodyNone">"linear"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"nearest-linear"   </td><td class="markdownTableBodyNone">"nearest"   </td><td class="markdownTableBodyNone">"linear"   </td></tr>
</table>
<p>(##) Use "linear-nearest" if in doubt. The table yields one parameter passed to <code><a class="elRef" href="../../dg/html/group__interpolation.html#gaebbccbc4e9b740740cd2e9db394d580f">create::interpolation</a></code> (from the given grid to the fine grid) and one parameter to <code><a class="elRef" href="../../dg/html/group__interpolation.html#ga9383cf8ef0d0cc6af8c1250ecb31dc58">create::projection</a></code> (from the fine grid to the given grid)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">benchmark</td><td>If true write construction timings to std::cout    </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> </dd></dl>

</div>
</div>
<a id="a5b13a242ab6db8f3fb0cb32a9b38d99a" name="a5b13a242ab6db8f3fb0cb32a9b38d99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b13a242ab6db8f3fb0cb32a9b38d99a">&#9670;&#160;</a></span>DS() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::DS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2b75936ff587a3f8ab4e3da2f72ac429">FA</a></td>          <td class="paramname"><span class="paramname"><em>fieldaligned</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-construct from a given <code><a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a></code> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldaligned</td><td>this object will be used in all further member calls </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a14b715011f3067fc3b12999efc525c7d" name="a14b715011f3067fc3b12999efc525c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b715011f3067fc3b12999efc525c7d">&#9670;&#160;</a></span>backward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::backward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward derivative \( g = \vec v \cdot \nabla f \) </p>
<p>backward derivative \( g_i = \frac{v^\varphi}{\Delta\varphi}(f_{i} - f_{i-1}) \)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="a09ce06edef5f61478606de8d8c67895c" name="a09ce06edef5f61478606de8d8c67895c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ce06edef5f61478606de8d8c67895c">&#9670;&#160;</a></span>backward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::backward </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>backward derivative \( g_i = \alpha \frac{1}{h_z^-}(f_{i} - f_{i-1}) + \beta g_i \)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="ad10864d34e051c2defa9ccdd87685268" name="ad10864d34e051c2defa9ccdd87685268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10864d34e051c2defa9ccdd87685268">&#9670;&#160;</a></span>backward2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::backward2 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2nd order backward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>backward derivative \( g_i = \alpha \frac{1}{2h_z^-}(3f_{i} - 4f_{i-1} + f_{i-2}) + \beta g_i \)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="ae715c59177d1b0e824f0e6d62b1b7733" name="ae715c59177d1b0e824f0e6d62b1b7733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae715c59177d1b0e824f0e6d62b1b7733">&#9670;&#160;</a></span>centered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::centered </td>
          <td>(</td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered derivative \( g = \vec v \cdot \nabla f \) </p>
<p>centered derivative \( g_i = \frac{v^\varphi}{2\Delta\varphi}(f_{i+1} - f_{i-1})\)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="a683a013de097e44f8d53f38f816a8abb" name="a683a013de097e44f8d53f38f816a8abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683a013de097e44f8d53f38f816a8abb">&#9670;&#160;</a></span>centered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::centered </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>The centered derivative is constructed by fitting a polynomial through the plus point the minus point and the center point and evaluating its derivative at the center point. For the exact resulting formula consult the <a href="https://www.overleaf.com/read/jjvstccqzcjv" target="_blank">parallel derivative</a> writeup  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="a4a0f000d91e6f3188ced811e38f86ea7" name="a4a0f000d91e6f3188ced811e38f86ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0f000d91e6f3188ced811e38f86ea7">&#9670;&#160;</a></span>centered_bc_along_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::centered_bc_along_field </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>boundary_value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{0,0}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="group__fieldaligned.html#ga70d98ba526a42601f26374d4aacddec5" title="centered derivative">dg::geo::ds_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>. </p>

</div>
</div>
<a id="a64ba5f4f4eecb13c7651e22e127e904f" name="a64ba5f4f4eecb13c7651e22e127e904f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ba5f4f4eecb13c7651e22e127e904f">&#9670;&#160;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<div class="memtemplate">
template&lt;class ... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perfect forward parameters to one of the constructors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>deduced by the compiler </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>parameters forwarded to constructors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae78cd48c94612d01d464bb381b775c92" name="ae78cd48c94612d01d464bb381b775c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78cd48c94612d01d464bb381b775c92">&#9670;&#160;</a></span>div() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::div </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \nabla \cdot ( \vec v f) \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="el" href="#adbb40af56b10c73db2fcc18c52bdc183" title="forward divergence">divForward()</a></code>, <code><a class="el" href="#a2fc3e43d58831703543075575a1ac736" title="backward divergence">divBackward()</a></code> or <code><a class="el" href="#a1ce6a527b77128d97515c3d109067bb6" title="centered divergence">divCentered()</a></code>  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)    </dd></dl>

</div>
</div>
<a id="a0bf806d00464e8e6c95f71a4bd316c0f" name="a0bf806d00464e8e6c95f71a4bd316c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf806d00464e8e6c95f71a4bd316c0f">&#9670;&#160;</a></span>div() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::div </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \nabla \cdot( \vec v f) + \beta g \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="el" href="#adbb40af56b10c73db2fcc18c52bdc183" title="forward divergence">divForward()</a></code>, <code><a class="el" href="#a2fc3e43d58831703543075575a1ac736" title="backward divergence">divBackward()</a></code> or <code><a class="el" href="#a1ce6a527b77128d97515c3d109067bb6" title="centered divergence">divCentered()</a></code>  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)    </dd></dl>

</div>
</div>
<a id="af683e046f6b59a823278b32e2fb0b787" name="af683e046f6b59a823278b32e2fb0b787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af683e046f6b59a823278b32e2fb0b787">&#9670;&#160;</a></span>divBackward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::divBackward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward divergence \( g = \nabla\cdot(\vec v f)\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)    </dd></dl>

</div>
</div>
<a id="a2fc3e43d58831703543075575a1ac736" name="a2fc3e43d58831703543075575a1ac736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc3e43d58831703543075575a1ac736">&#9670;&#160;</a></span>divBackward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::divBackward </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>backward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)    </dd></dl>

</div>
</div>
<a id="a183839b4cebbdf89af7e99c1ec499f86" name="a183839b4cebbdf89af7e99c1ec499f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183839b4cebbdf89af7e99c1ec499f86">&#9670;&#160;</a></span>divCentered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::divCentered </td>
          <td>(</td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered divergence \( g = \nabla\cdot(\vec v f)\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)    </dd></dl>

</div>
</div>
<a id="a1ce6a527b77128d97515c3d109067bb6" name="a1ce6a527b77128d97515c3d109067bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce6a527b77128d97515c3d109067bb6">&#9670;&#160;</a></span>divCentered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::divCentered </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>centered divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)    </dd></dl>

</div>
</div>
<a id="a2d92c54f67c86c1ebb76c3e9e5c064ab" name="a2d92c54f67c86c1ebb76c3e9e5c064ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d92c54f67c86c1ebb76c3e9e5c064ab">&#9670;&#160;</a></span>divForward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::divForward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward divergence \( g = \nabla\cdot(\vec v f)\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)    </dd></dl>

</div>
</div>
<a id="adbb40af56b10c73db2fcc18c52bdc183" name="adbb40af56b10c73db2fcc18c52bdc183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb40af56b10c73db2fcc18c52bdc183">&#9670;&#160;</a></span>divForward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::divForward </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward divergence \( g = \alpha \nabla\cdot(\vec v f) + \beta g\) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)    </dd></dl>

</div>
</div>
<a id="af592f11db44e30e033d9df5a2236aa96" name="af592f11db44e30e033d9df5a2236aa96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af592f11db44e30e033d9df5a2236aa96">&#9670;&#160;</a></span>ds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::ds </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \vec v\cdot \nabla f \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a573a4a72e7f55df92b88c254a13762f2">forward()</a></code>, <code><a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a3e10d2598f5b58a930631b12774e05cb">backward()</a></code> or <code><a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">centered()</a></code>  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="abe05ed48761f7a4a4a4934d1040ef151" name="abe05ed48761f7a4a4a4934d1040ef151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe05ed48761f7a4a4a4934d1040ef151">&#9670;&#160;</a></span>ds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::ds </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#gabf9ea3df33484cbb5886e257c3899e48">dg::direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \vec v\cdot \nabla f + \beta g \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>redirects to either <code><a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a573a4a72e7f55df92b88c254a13762f2">forward()</a></code>, <code><a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a3e10d2598f5b58a930631b12774e05cb">backward()</a></code> or <code><a class="elRef" href="../../dg/html/group__creation.html#ggabf9ea3df33484cbb5886e257c3899e48a6281b4fc609cb723a615662b5adac9df">centered()</a></code>  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="a4ca167849f022f279455b10b9f32b825" name="a4ca167849f022f279455b10b9f32b825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca167849f022f279455b10b9f32b825">&#9670;&#160;</a></span>dss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::dss </td>
          <td>(</td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = (\vec v\cdot \nabla)^2 f \). </p>
<p>Same as <code>forward</code> followed by <code>backward</code>  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="a6936d46b163e0430f57516b44e8330bd" name="a6936d46b163e0430f57516b44e8330bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6936d46b163e0430f57516b44e8330bd">&#9670;&#160;</a></span>dss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::dss </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha (\vec v\cdot \nabla)^2 f + \beta g \). </p>
<p>Same as <code>forward</code> followed by <code>backward</code>  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="af515ee483a0c3629a3eaaaa27153c791" name="af515ee483a0c3629a3eaaaa27153c791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af515ee483a0c3629a3eaaaa27153c791">&#9670;&#160;</a></span>dss_bc_along_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::dss_bc_along_field </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>boundary_value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{0,0}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="group__fieldaligned.html#ga9d0308bf8d169f14efc488419bfa33b6" title="Centered derivative .">dg::geo::dss_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>. </p>

</div>
</div>
<a id="a5dcd6aed8123941867098c83867fb5a3" name="a5dcd6aed8123941867098c83867fb5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcd6aed8123941867098c83867fb5a3">&#9670;&#160;</a></span>dssd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::dssd </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="group__fieldaligned.html#ga20aa9652f545d6b73c9223aad1754274" title="Centered derivative .">dg::geo::dssd_centered</a></code>. </p>

</div>
</div>
<a id="a8d6fcd8ea9476def0dfd0d726fac1c97" name="a8d6fcd8ea9476def0dfd0d726fac1c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6fcd8ea9476def0dfd0d726fac1c97">&#9670;&#160;</a></span>dssd_bc_along_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::dssd_bc_along_field </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; double, 2 &gt;</td>          <td class="paramname"><span class="paramname"><em>boundary_value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{0,0}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="group__fieldaligned.html#ga20aa9652f545d6b73c9223aad1754274" title="Centered derivative .">dg::geo::dssd_centered</a></code> after <code>dg::geo::ds_assign_bc_along_field_2nd</code>. </p>

</div>
</div>
<a id="aadefe104d1560a2feefb7ff51ef38b71" name="aadefe104d1560a2feefb7ff51ef38b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadefe104d1560a2feefb7ff51ef38b71">&#9670;&#160;</a></span>fieldaligned() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2b75936ff587a3f8ab4e3da2f72ac429">FA</a> &amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::fieldaligned </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the underlying <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object </p>
<dl class="section return"><dt>Returns</dt><dd>acces to <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a> object </dd></dl>

</div>
</div>
<a id="a0ac59e81a1abf0cf0386e55e11dd21a5" name="a0ac59e81a1abf0cf0386e55e11dd21a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac59e81a1abf0cf0386e55e11dd21a5">&#9670;&#160;</a></span>fieldaligned() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a2b75936ff587a3f8ab4e3da2f72ac429">FA</a> &amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::fieldaligned </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fd2d475a634a5f991507c66b1948fff" name="a1fd2d475a634a5f991507c66b1948fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd2d475a634a5f991507c66b1948fff">&#9670;&#160;</a></span>forward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::forward </td>
          <td>(</td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward derivative \( g = \vec v \cdot \nabla f \) </p>
<p>forward derivative \( g_i = \frac{v^\varphi}{\Delta\varphi}(f_{i+1} - f_{i})\)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="a985a34d89fd63d5d640a9dd1994dd64d" name="a985a34d89fd63d5d640a9dd1994dd64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985a34d89fd63d5d640a9dd1994dd64d">&#9670;&#160;</a></span>forward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::forward </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>forward derivative \( g_i = \alpha \frac{1}{h_z^+}(f_{i+1} - f_{i}) + \beta g_i\)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="aeb1d413e4d312e1bcba6d6ff9a4f6682" name="aeb1d413e4d312e1bcba6d6ff9a4f6682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1d413e4d312e1bcba6d6ff9a4f6682">&#9670;&#160;</a></span>forward2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::forward2 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2nd order forward derivative \( g = \alpha \vec v \cdot \nabla f + \beta g\) </p>
<p>forward derivative \( g_i = \alpha \frac{1}{2h_z^+}(-f_{i+2} + 4f_{i+1} - 3f_{i}) + \beta g_i\)  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor    </dd></dl>

</div>
</div>
<a id="ae32ac2bd63fba61762f1160b560e037e" name="ae32ac2bd63fba61762f1160b560e037e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32ac2bd63fba61762f1160b560e037e">&#9670;&#160;</a></span>set_boundaries() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>global</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scal_left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scal_right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region.    </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">global</td><td>3D vector containing boundary values </td></tr>
    <tr><td class="paramname">scal_left</td><td>left scaling factor </td></tr>
    <tr><td class="paramname">scal_right</td><td>right scaling factor    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68f99ff7e2291c6a1139e80e200b74c1" name="a68f99ff7e2291c6a1139e80e200b74c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f99ff7e2291c6a1139e80e200b74c1">&#9670;&#160;</a></span>set_boundaries() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region.    </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>spatially variable left boundary value (2d size) </td></tr>
    <tr><td class="paramname">right</td><td>spatially variable right boundary value (2d size)    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c6b9b87d6cd4c2c213727af599af965" name="a5c6b9b87d6cd4c2c213727af599af965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6b9b87d6cd4c2c213727af599af965">&#9670;&#160;</a></span>set_boundaries() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::set_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../../dg/html/group__creation.html#ga59440bdf436f2874b49aa52b670ed364">dg::bc</a></td>          <td class="paramname"><span class="paramname"><em>bcz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set boundary conditions in the limiter region.    </p>
<p>if Dirichlet boundaries are used the left value is the left function value, if Neumann boundaries are used the left value is the left derivative value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcz</td><td>boundary condition </td></tr>
    <tr><td class="paramname">left</td><td>constant left boundary value </td></tr>
    <tr><td class="paramname">right</td><td>constant right boundary value    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96f38d345738a8261627cacf04abab98" name="a96f38d345738a8261627cacf04abab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f38d345738a8261627cacf04abab98">&#9670;&#160;</a></span>symv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::symv </td>
          <td>(</td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discretizes \( g = \nabla\cdot ( \vec v \vec v \cdot \nabla f )\). </p>
<p>using the <code><a class="el" href="group__fieldaligned.html#ga20aa9652f545d6b73c9223aad1754274" title="Centered derivative .">dg::geo::dssd_centered</a></code> method.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)    </dd>
<dd>
The <code><a class="elRef" href="../../dg/html/structdg_1_1_tensor_traits.html">dg::TensorTraits</a></code> are defined for this class and thus <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">DS</a></code> is usable as a Matrix class (calling <code>symv</code> ) </dd></dl>

</div>
</div>
<a id="a21e0fb3a747be784321a8c28bb34fafe" name="a21e0fb3a747be784321a8c28bb34fafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e0fb3a747be784321a8c28bb34fafe">&#9670;&#160;</a></span>symv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::symv </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">container &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discretizes \( g = \alpha \nabla\cdot ( \vec v \vec v \cdot \nabla f ) + \beta g\) as a symmetric matrix. </p>
<p>using the <code><a class="el" href="group__fieldaligned.html#ga20aa9652f545d6b73c9223aad1754274" title="Centered derivative .">dg::geo::dssd_centered</a></code> method.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar </td></tr>
    <tr><td class="paramname">f</td><td>The vector to derive </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar </td></tr>
    <tr><td class="paramname">g</td><td>contains result on output (may alias input vectors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the vector sizes need to equal the grid size in the constructor     </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>div</code> and <code>symv</code> member functions are close to but not exactly volume conserving (at least if not the linear interpolation is chosen in <a class="el" href="structdg_1_1geo_1_1_fieldaligned.html" title="Create and manage interpolation matrices from fieldline integration.">Fieldaligned</a>)    </dd>
<dd>
The <code><a class="elRef" href="../../dg/html/structdg_1_1_tensor_traits.html">dg::TensorTraits</a></code> are defined for this class and thus <code><a class="el" href="structdg_1_1geo_1_1_d_s.html" title="Class for the evaluation of parallel derivatives.">DS</a></code> is usable as a Matrix class (calling <code>symv</code> ) </dd></dl>

</div>
</div>
<a id="a4f27cd79cb9d743080acc55c5a102699" name="a4f27cd79cb9d743080acc55c5a102699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f27cd79cb9d743080acc55c5a102699">&#9670;&#160;</a></span>weights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProductGeometry , class IMatrix , class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const container &amp; <a class="el" href="structdg_1_1geo_1_1_d_s.html">dg::geo::DS</a>&lt; ProductGeometry, IMatrix, container &gt;::weights </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The volume form with dG weights. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ds_8h_source.html">ds.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>dg</b></li><li class="navelem"><a class="el" href="namespacedg_1_1geo.html">geo</a></li><li class="navelem"><a class="el" href="structdg_1_1geo_1_1_d_s.html">DS</a></li>
    <li class="footer">Generated on Mon Jun 23 2025 12:36:36 for Extension: Geometries by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
